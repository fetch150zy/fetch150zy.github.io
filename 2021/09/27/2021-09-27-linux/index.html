<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="keywords" content="computer science">
    
    <meta name="author" content="fetch150zy">
    <!-- preconnect -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>

    
    <!--- Seo Part-->
    
    <link rel="canonical" href="https://fetch150zy.github.io/2021/09/27/2021-09-27-linux/"/>
    <meta name="robots" content="index,follow">
    <meta name="googlebot" content="index,follow">
    <meta name="revisit-after" content="1 days">
    
        <meta name="description" content="作为任何一个计算机行业相关人事都应该了解学习的操作系统 Linux介绍发行版（ubuntu） 主版本号为当年年份，长期支持版的年份是偶数，测试版本的年份是奇数 副版本号为月份，在4月份发布的为相对稳定版本，在10月份发布的为测试版本  内核   Linux系统从应用角度来看，分为内核空间和用户空间  内核主要由五个子系统组成  进程调度 SCHED    进程调度指的是系统对进程的多种状态之间转换">
<meta property="og:type" content="article">
<meta property="og:title" content="Linux基础">
<meta property="og:url" content="https://fetch150zy.github.io/2021/09/27/2021-09-27-linux/index.html">
<meta property="og:site_name" content="fetch150zy&#39;blog">
<meta property="og:description" content="作为任何一个计算机行业相关人事都应该了解学习的操作系统 Linux介绍发行版（ubuntu） 主版本号为当年年份，长期支持版的年份是偶数，测试版本的年份是奇数 副版本号为月份，在4月份发布的为相对稳定版本，在10月份发布的为测试版本  内核   Linux系统从应用角度来看，分为内核空间和用户空间  内核主要由五个子系统组成  进程调度 SCHED    进程调度指的是系统对进程的多种状态之间转换">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2021-09-27T04:00:00.000Z">
<meta property="article:modified_time" content="2024-03-23T05:43:25.807Z">
<meta property="article:author" content="fetch150zy">
<meta property="article:tag" content="Linux">
<meta name="twitter:card" content="summary">
    
    
    <!--- Icon Part-->
    <link rel="icon" type="image/png" href="/img/pacman.png" sizes="192x192">
    <link rel="apple-touch-icon" sizes="180x180" href="/img/pacman.png">
    <meta name="theme-color" content="#7FCDCD">
    <link rel="shortcut icon" href="/img/pacman.png">
    <!--- Page Info-->
    
    <title>
        
            Linux基础 -
        
        fetch150zy&#39;s blog
    </title>

    
<link rel="stylesheet" href="/fonts/Chillax/chillax.css">


    <!--- Inject Part-->
    

    
        <style>
    :root {
        --preloader-background-color: #fff;
        --preloader-text-color: #000;
    }

    @media (prefers-color-scheme: dark) {
        :root {
            --preloader-background-color: #202124;
            --preloader-text-color: #fff;
        }
    }

    @media (prefers-color-scheme: light) {
        :root {
            --preloader-background-color: #fff;
            --preloader-text-color: #000;
        }
    }

    @media (max-width: 600px) {
        .ml13 {
            font-size: 2.6rem !important; /* Adjust this value as needed */
        }
    }

    .preloader {
        display: flex;
        flex-direction: column;
        gap: 1rem; /* Tailwind 'gap-4' is 1rem */
        align-items: center;
        justify-content: center;
        position: fixed;
        padding: 12px;
        top: 0;
        right: 0;
        bottom: 0;
        left: 0;
        width: 100vw;
        height: 100vh; /* 'h-screen' is 100% of the viewport height */
        background-color: var(--preloader-background-color);
        z-index: 1100; /* 'z-[1100]' sets the z-index */
        transition: opacity 0.2s ease-in-out;
    }

    .ml13 {
        font-size: 3.2rem;
        /* text-transform: uppercase; */
        color: var(--preloader-text-color);
        letter-spacing: -1px;
        font-weight: 500;
        font-family: 'Chillax-Variable', sans-serif;
        text-align: center;
    }

    .ml13 .word {
        display: inline-flex;
        flex-wrap: wrap;
        white-space: nowrap;
    }

    .ml13 .letter {
        display: inline-block;
        line-height: 1em;
    }
</style>

<div class="preloader">
    
<script src="/js/libs/anime.min.js"></script>

    <h1 class="ml13">
        fetch150zy&#39;s blog
    </h1>
    <script>
        var textWrapper = document.querySelector('.ml13');
        // Split text into words
        var words = textWrapper.textContent.trim().split(' ');

        // Clear the existing content
        textWrapper.innerHTML = '';

        // Wrap each word and its letters in spans
        words.forEach(function(word) {
            var wordSpan = document.createElement('span');
            wordSpan.classList.add('word');
            wordSpan.innerHTML = word.replace(/\S/g, "<span class='letter'>$&</span>");
            textWrapper.appendChild(wordSpan);
            textWrapper.appendChild(document.createTextNode(' ')); // Add space between words
        });


        anime.timeline({loop: true})
            .add({
                targets: '.ml13 .letter',
                translateY: [100,0],
                translateZ: 0,
                opacity: [0,1],
                easing: "easeOutExpo",
                duration: 1400,
                delay: (el, i) => 300 + 30 * i
            }).add({
            targets: '.ml13 .letter',
            translateY: [0,-100],
            opacity: [1,0],
            easing: "easeInExpo",
            duration: 1200,
            delay: (el, i) => 100 + 30 * i
        });

        let themeStatus = JSON.parse(localStorage.getItem('REDEFINE-THEME-STATUS'))?.isDark;

        // If the theme status is not found in local storage, check the preferred color scheme
        if (themeStatus === undefined || themeStatus === null) {
            if (window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches) {
                themeStatus = 'dark';
            } else {
                themeStatus = 'light';
            }
        }

        // Now you can use the themeStatus variable in your code
        if (themeStatus) {
            document.documentElement.style.setProperty('--preloader-background-color', '#202124');
            document.documentElement.style.setProperty('--preloader-text-color', '#fff');
        } else {
            document.documentElement.style.setProperty('--preloader-background-color', '#fff');
            document.documentElement.style.setProperty('--preloader-text-color', '#000');
        }

        window.addEventListener('load', function () {
            hidePreloaderAfterTimeout(1000); // Hide after 1000 milliseconds once the window has loaded
        });

        // Backup failsafe: Hide preloader after a maximum of 5000 milliseconds, regardless of the window load event
        hidePreloaderAfterTimeout(5000);

        function hidePreloaderAfterTimeout(delay) {
            setTimeout(function () {
                var preloader = document.querySelector('.preloader');
                preloader.style.opacity = '0';
                setTimeout(function () {
                    preloader.style.display = 'none';
                }, 200);
            }, delay);
        }
    </script>
</div>
    

    
<link rel="stylesheet" href="/css/style.css">


    
        
<link rel="stylesheet" href="/assets/build/styles.css">

    

    
<link rel="stylesheet" href="/fonts/fonts.css">

    
<link rel="stylesheet" href="/fonts/Satoshi/satoshi.css">

    <!--- Font Part-->
    
    
    
    


    <script id="hexo-configurations">
    window.config = {"hostname":"fetch150zy.github.io","root":"/","language":"zh-CN"};
    window.theme = {"articles":{"style":{"font_size":"18px","line_height":1.4,"image_border_radius":"14px","image_alignment":"center","image_caption":false,"link_icon":true,"title_alignment":"center","headings_top_spacing":{"h1":"5rem","h2":"4rem","h3":"2.8rem","h4":"2.5rem","h5":"2.2rem","h6":"2rem"}},"word_count":{"enable":false,"count":false,"min2read":false},"author_label":{"enable":false,"auto":false,"list":[]},"code_block":{"copy":false,"style":"mac","font":{"enable":false,"family":null,"url":null}},"toc":{"enable":true,"max_depth":6,"number":false,"expand":true,"init_open":true},"copyright":{"enable":false,"default":"cc_by_nc_sa"},"lazyload":true,"recommendation":{"enable":false,"title":"推荐阅读","limit":3,"mobile_limit":2,"placeholder":null,"skip_dirs":[]}},"colors":{"primary":"#7FCDCD","secondary":null,"default_mode":"dark"},"global":{"fonts":{"chinese":{"enable":null,"family":null,"url":null},"english":{"enable":null,"family":null,"url":null}},"content_max_width":"1000px","sidebar_width":"210px","hover":{"shadow":true,"scale":true},"scroll_progress":{"bar":false,"percentage":true},"website_counter":{"url":"https://cn.vercount.one/js","enable":false,"site_pv":false,"site_uv":false,"post_pv":false},"single_page":true,"preloader":true,"open_graph":true,"google_analytics":{"enable":false,"id":null}},"home_banner":{"enable":true,"style":"fixed","image":{"light":"/img/bg15.jpg","dark":"/img/bg15.jpg"},"title":"fetch150zy's blog","subtitle":{"text":["年年岁岁花相似，岁岁年年人不同"],"hitokoto":{"enable":false,"api":"https://v1.hitokoto.cn"},"typing_speed":100,"backing_speed":80,"starting_delay":500,"backing_delay":1500,"loop":true,"smart_backspace":true},"text_color":{"light":"#fff","dark":"#d1d1b6"},"text_style":{"title_size":"2.8rem","subtitle_size":"1.5rem","line_height":1.3},"custom_font":{"enable":false,"family":null,"url":null},"social_links":{"enable":true,"style":"default","links":{"github":"https://github.com/fetch150zy","bilibili":"https://space.bilibili.com/505867894","stack-overflow":"https://stackoverflow.com/users/16738249/fetch150zy","email":"mailto:mars_zhewei@outlook.com"},"qrs":{"weixin":"https://pic.fetch150zy.cn/weixin.png"}}},"plugins":{"feed":{"enable":false},"aplayer":{"enable":false,"type":"fixed","audios":[{"name":null,"artist":null,"url":null,"cover":null,"lrc":null}]},"mermaid":{"enable":false,"version":"9.3.0"}},"version":"2.6.1","navbar":{"auto_hide":false,"color":{"left":"#f78736","right":"#367df7","transparency":35},"width":{"home":"1200px","pages":"1000px"},"links":{"Home":{"path":"/","icon":"fa-regular fa-house"},"Archives":{"path":"/archives","icon":"fa-regular fa-archive"},"About":{"icon":"fa-regular fa-user","submenus":{"Me":"/about","Blog":"https://fetch150zy.cn","Github":"https://github.com/fetch150zy"}}},"search":{"enable":false,"preload":true}},"page_templates":{"friends_column":3,"tags_style":"blur"},"home":{"sidebar":{"enable":true,"position":"right","first_item":"info","announcement":null,"show_on_mobile":true,"links":{"Archives":{"path":"/archives","icon":"fa-regular fa-archive"},"Tags":{"path":"/tags","icon":"fa-regular fa-tags"},"Categories":{"path":"/categories","icon":"fa-regular fa-folder"}}},"article_date_format":"YYYY-MM-DD","categories":{"enable":true,"limit":3},"tags":{"enable":true,"limit":3}},"footerStart":null};
    window.lang_ago = {"second":"%s 秒前","minute":"%s 分钟前","hour":"%s 小时前","day":"%s 天前","week":"%s 周前","month":"%s 个月前","year":"%s 年前"};
    window.data = {"masonry":false};
  </script>
    
    <!--- Fontawesome Part-->
    
<link rel="stylesheet" href="/fontawesome/fontawesome.min.css">

    
<link rel="stylesheet" href="/fontawesome/brands.min.css">

    
<link rel="stylesheet" href="/fontawesome/solid.min.css">

    
<link rel="stylesheet" href="/fontawesome/regular.min.css">

    
    
    
    
        
<link rel="stylesheet" href="/fontawesome/sharp-solid.min.css">

    
<meta name="generator" content="Hexo 7.1.1"></head>


<body>
<div class="progress-bar-container">
    

    
        <span class="pjax-progress-bar"></span>
<!--        <span class="swup-progress-icon">-->
<!--            <i class="fa-solid fa-circle-notch fa-spin"></i>-->
<!--        </span>-->
    
</div>


<main class="page-container" id="swup">

    

    <div class="main-content-container">


        <div class="main-content-header">
            <header class="navbar-container px-6 md:px-12">

    <div class="navbar-content ">
        <div class="left">
            
                <a class="logo-image" href="/">
                    <img src="/img/pacman.png">
                </a>
            
            <a class="logo-title" href="/">
                
                fetch150zy&#39;s blog
                
            </a>
        </div>

        <div class="right">
            <!-- PC -->
            <div class="desktop">
                <ul class="navbar-list">
                    
                        
                            

                            <li class="navbar-item">
                                <!-- Menu -->
                                <a class=""
                                   href="/"
                                        >
                                    <i class="fa-regular fa-house fa-fw"></i>
                                    首页
                                    
                                </a>

                                <!-- Submenu -->
                                
                            </li>
                    
                        
                            

                            <li class="navbar-item">
                                <!-- Menu -->
                                <a class=""
                                   href="/archives"
                                        >
                                    <i class="fa-regular fa-archive fa-fw"></i>
                                    归档
                                    
                                </a>

                                <!-- Submenu -->
                                
                            </li>
                    
                        
                            

                            <li class="navbar-item">
                                <!-- Menu -->
                                <a class="has-dropdown"
                                   href="#"
                                        onClick=&#34;return false;&#34;>
                                    <i class="fa-regular fa-user fa-fw"></i>
                                    关于
                                    <i class="fa-solid fa-chevron-down fa-fw"></i>
                                </a>

                                <!-- Submenu -->
                                
                                    <ul class="sub-menu">
                                        
                                            <li>
                                                <a href="/about">
                                                    ME
                                                </a>
                                            </li>
                                        
                                            <li>
                                                <a target="_blank" rel="noopener" href="https://fetch150zy.cn">
                                                    BLOG
                                                </a>
                                            </li>
                                        
                                            <li>
                                                <a target="_blank" rel="noopener" href="https://github.com/fetch150zy">
                                                    GITHUB
                                                </a>
                                            </li>
                                        
                                    </ul>
                                
                            </li>
                    
                    
                </ul>
            </div>
            <!-- Mobile -->
            <div class="mobile">
                
                <div class="icon-item navbar-bar">
                    <div class="navbar-bar-middle"></div>
                </div>
            </div>
        </div>
    </div>

    <!-- Mobile sheet -->
    <div class="navbar-drawer h-screen w-full absolute top-0 left-0 bg-background-color flex flex-col justify-between">
        <ul class="drawer-navbar-list flex flex-col px-4 justify-center items-start">
            
                
                    

                    <li class="drawer-navbar-item text-base my-1.5 flex flex-col w-full">
                        
                        <a class="py-1.5 px-2 flex flex-row items-center justify-between gap-1 hover:!text-primary active:!text-primary text-2xl font-semibold group border-b border-border-color hover:border-primary w-full "
                           href="/"
                        >
                            <span>
                                首页
                            </span>
                            
                                <i class="fa-regular fa-house fa-sm fa-fw"></i>
                            
                        </a>
                        

                        
                    </li>
            
                
                    

                    <li class="drawer-navbar-item text-base my-1.5 flex flex-col w-full">
                        
                        <a class="py-1.5 px-2 flex flex-row items-center justify-between gap-1 hover:!text-primary active:!text-primary text-2xl font-semibold group border-b border-border-color hover:border-primary w-full "
                           href="/archives"
                        >
                            <span>
                                归档
                            </span>
                            
                                <i class="fa-regular fa-archive fa-sm fa-fw"></i>
                            
                        </a>
                        

                        
                    </li>
            
                
                    

                    <li class="drawer-navbar-item-sub text-base my-1.5 flex flex-col w-full">
                        
                        <div class="py-1.5 px-2 flex flex-row items-center justify-between gap-1 hover:!text-primary active:!text-primary cursor-pointer text-2xl font-semibold group border-b border-border-color hover:border-primary w-full "
                             navbar-data-toggle="submenu-About"
                        >
                            <span>
                                关于
                            </span>
                            
                                <i class="fa-solid fa-chevron-right fa-sm fa-fw transition-all"></i>
                            
                        </div>
                        

                        
                            <div class="flex-col items-start px-2 py-2 hidden" data-target="submenu-About">
                                
                                    <div class="drawer-navbar-item text-base flex flex-col justify-center items-start hover:underline active:underline hover:underline-offset-1 rounded-3xl">
                                        <a class=" text-third-text-color text-xl"
                                           href="/about">ME</a>
                                    </div>
                                
                                    <div class="drawer-navbar-item text-base flex flex-col justify-center items-start hover:underline active:underline hover:underline-offset-1 rounded-3xl">
                                        <a class=" text-third-text-color text-xl"
                                           target="_blank" rel="noopener" href="https://fetch150zy.cn">BLOG</a>
                                    </div>
                                
                                    <div class="drawer-navbar-item text-base flex flex-col justify-center items-start hover:underline active:underline hover:underline-offset-1 rounded-3xl">
                                        <a class=" text-third-text-color text-xl"
                                           target="_blank" rel="noopener" href="https://github.com/fetch150zy">GITHUB</a>
                                    </div>
                                
                            </div>
                        
                    </li>
            

            
            
                
                    
                    
                    <li class="drawer-navbar-item text-base my-1.5 flex flex-col w-full">
                        <a class="py-1.5 px-2 flex flex-row items-center justify-between gap-1 hover:!text-primary active:!text-primary text-2xl font-semibold group border-b border-border-color hover:border-primary w-full active"
                           href="/tags"
                        >
                            <span>Tags</span>
                            <i class="fa-regular fa-tags fa-sm fa-fw"></i>
                        </a>
                    </li>
                
                    
                    <li class="drawer-navbar-item text-base my-1.5 flex flex-col w-full">
                        <a class="py-1.5 px-2 flex flex-row items-center justify-between gap-1 hover:!text-primary active:!text-primary text-2xl font-semibold group border-b border-border-color hover:border-primary w-full active"
                           href="/categories"
                        >
                            <span>Categories</span>
                            <i class="fa-regular fa-folder fa-sm fa-fw"></i>
                        </a>
                    </li>
                
            
        </ul>

        <div class="statistics flex justify-around my-2.5">
    <a class="item tag-count-item flex flex-col justify-center items-center w-20" href="/tags">
        <div class="number text-2xl sm:text-xl text-second-text-color font-semibold">20</div>
        <div class="label text-third-text-color text-sm">标签</div>
    </a>
    <a class="item tag-count-item flex flex-col justify-center items-center w-20" href="/categories">
        <div class="number text-2xl sm:text-xl text-second-text-color font-semibold">18</div>
        <div class="label text-third-text-color text-sm">分类</div>
    </a>
    <a class="item tag-count-item flex flex-col justify-center items-center w-20" href="/archives">
        <div class="number text-2xl sm:text-xl text-second-text-color font-semibold">52</div>
        <div class="label text-third-text-color text-sm">文章</div>
    </a>
</div>
    </div>

    <div class="window-mask"></div>

</header>


        </div>

        <div class="main-content-body">

            

            <div class="main-content">

                
                    <div class="post-page-container flex relative justify-between box-border w-full h-full">
    <div class="article-content-container">

        <div class="article-title relative w-full">
            
                
                
                <img src="/../img/bg/6.png" alt="Linux基础" class="w-full h-60 sm:h-72 md:h-80 object-cover sm:rounded-t-large dark:brightness-75"/>
                
                <div class="w-full flex items-center absolute bottom-0 justify-center">
                    <h1 class="article-title-cover text-center mx-6 my-6 text-second-text-color bg-background-color-transparent px-4 py-3 text-3xl sm:text-4xl md:text-5xl font-bold backdrop-blur-lg rounded-xl border border-border-color ">Linux基础</h1>
                </div>
            
            </div>

        
            <div class="article-header flex flex-row gap-2 items-center px-2 sm:px-6 md:px-8">
                <div class="avatar w-[46px] h-[46px] flex-shrink-0 rounded-medium border border-border-color p-[1px]">
                    <img src="/img/avatar.jpg">
                </div>
                <div class="info flex flex-col justify-between">
                    <div class="author flex items-center">
                        <span class="name text-default-text-color text-lg font-semibold">fetch150zy</span>
                        
                    </div>
                    <div class="meta-info">
                        <div class="article-meta-info">
    <span class="article-date article-meta-item">
        <i class="fa-regular fa-pen-fancy"></i>&nbsp;
        <span class="desktop">2021-09-27 12:00</span>
        <span class="mobile">2021-09-27 12:00</span>
        <span class="hover-info">创建</span>
    </span>
    
        <span class="article-date article-meta-item">
            <i class="fa-regular fa-wrench"></i>&nbsp;
            <span class="desktop">2024-03-23 13:43:25</span>
            <span class="mobile">2024-03-23 13:43:25</span>
            <span class="hover-info">更新</span>
        </span>
    

    
        <span class="article-categories article-meta-item">
            <i class="fa-regular fa-folders"></i>&nbsp;
            <ul>
                
                
                    
                        
                        <li>
                            <a href="/categories/Linux/">Linux</a>&nbsp;
                        </li>
                    
                    
                
            </ul>
        </span>
    
    
        <span class="article-tags article-meta-item">
            <i class="fa-regular fa-tags"></i>&nbsp;
            <ul>
                
                    <li>
                        <a href="/tags/Linux/">Linux</a>&nbsp;
                    </li>
                
            </ul>
        </span>
    

    
    
    
    
</div>

                    </div>
                </div>
            </div>
        

        


        <div class="article-content markdown-body px-2 sm:px-6 md:px-8 pb-8">
            <p>作为任何一个计算机行业相关人事都应该了解学习的操作系统</p>
<h1 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h1><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><h3 id="发行版（ubuntu）"><a href="#发行版（ubuntu）" class="headerlink" title="发行版（ubuntu）"></a>发行版（ubuntu）</h3><ul>
<li>主版本号为当年年份，长期支持版的年份是偶数，测试版本的年份是奇数</li>
<li>副版本号为月份，在4月份发布的为相对稳定版本，在10月份发布的为测试版本</li>
</ul>
<h3 id="内核"><a href="#内核" class="headerlink" title="内核"></a>内核</h3><blockquote>
<p>  Linux系统从应用角度来看，分为内核空间和用户空间</p>
</blockquote>
<p>内核主要由五个子系统组成</p>
<ol>
<li><p>进程调度 SCHED</p>
<blockquote>
<p>  进程调度指的是系统对进程的多种状态之间转换的策略</p>
</blockquote>
<ul>
<li>SCHED_OTHER：分时调度策略（默认），用于针对普通进程的时间片轮转调度策略</li>
<li>SCHED_FIFO：实时调度策略，针对运行的实时性要求比较高、运行时间比较短的进程调度策略</li>
<li>SCHED_RR：实时调度策略，针对运行的实时性要求比较高、运行时间比较长的进程调度策略</li>
</ul>
</li>
<li><p>内存管理 MMU</p>
<ul>
<li>内存管理（虚拟内存）是多个进程之间内存共享策略</li>
<li>虚拟内存可以让进程拥有比实际物理内存更大的内存</li>
<li>每个进程的虚拟地址有不同的地址空间，多个进程的虚拟内存不会冲突</li>
</ul>
</li>
<li><p>虚拟文件系统 VFS</p>
<blockquote>
<p>  Linux下支持多种文件系统：ext2 ext3 vfat ntfs proc smb ncp sysv</p>
<ul>
<li>Linux下最常用的文件格式为ext2 ext3</li>
</ul>
</blockquote>
</li>
<li><p>网络接口</p>
<blockquote>
<p>  网络接口分为网络协议和驱动程序</p>
</blockquote>
</li>
<li><p>进程间通信</p>
<blockquote>
<p>  Linux系统支持多进程，进程之间需要进行数据的交流才能完成控制，协同工作等功能</p>
<p>  Linux的进程间通信是从UNIX系统继承过来的</p>
<ul>
<li>管道</li>
<li>信号</li>
<li>消息队列</li>
<li>共享内存</li>
<li>套接字</li>
</ul>
</blockquote>
</li>
</ol>
<h3 id="Linux目录"><a href="#Linux目录" class="headerlink" title="Linux目录"></a>Linux目录</h3><blockquote>
<p>  Linux采用将整个文件系统表示成树状的结构，采用挂载的方式将所有分区放在“根”下的各个目录中</p>
</blockquote>
<h4 id="目录结构（ubuntu）"><a href="#目录结构（ubuntu）" class="headerlink" title="目录结构（ubuntu）"></a>目录结构（ubuntu）</h4><ul>
<li><code>bin</code>：二进制文件目录，存储了可执行程序，执行的命令对应的可执行程序都在这个目录</li>
<li><code>sbin</code>：root用户使用的一些二进制可执行程序</li>
<li><code>etc</code>：配置文件目录</li>
<li><code>lib</code>：存储一些动态库和静态库，给系统和安装的软件使用</li>
<li><code>media</code>：挂载目录，挂载外部设备，像光驱扫描仪等</li>
<li><code>mnt</code>：临时挂载目录，可以将U盘挂载在这</li>
<li><code>proc</code>：内存使用的一个映射目录，供操作系统使用</li>
<li><code>tmp</code>：临时文件目录，存放临时数据，重启电脑后自动删除</li>
<li><code>boot</code>：开机相关设置</li>
<li><code>home</code>：普通用户家目录</li>
<li><code>root</code>：root用户家目录</li>
<li><code>dev</code>：设备目录，Linux下一切皆文件，所有硬件会抽象成文件存储起来</li>
<li><code>lost+found</code>：电脑异常关闭或崩溃时用来存储无家可归的文件，用于用户系统恢复</li>
<li><code>opt</code>：第三方软件的安装目录</li>
<li><code>var</code>：存储系统上一些经常变化的文件，像日志文件</li>
<li><code>usr</code>：系统的资源目录<ul>
<li><code>/usr/bin</code>：可执行的二进制应用程序</li>
<li><code>/usr/games</code>：游戏目录</li>
<li><code>/usr/include</code>：标准头文件目录</li>
<li><code>/usr/local</code>：和<code>opt</code>类似，安装第三方软件</li>
</ul>
</li>
</ul>
<h2 id="文件管理命令"><a href="#文件管理命令" class="headerlink" title="文件管理命令"></a>文件管理命令</h2><h3 id="cd命令"><a href="#cd命令" class="headerlink" title="cd命令"></a>cd命令</h3><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> &lt;path&gt;</span><br></pre></td></tr></table></figure></div>

<ul>
<li><code>path</code>可以是相对目录和绝对目录</li>
<li><code>..</code> 表示上一级目录，<code>.</code>表示当前目录</li>
<li><code>~</code>表示<code>/home/username</code></li>
<li><code>cd -</code>可快速切换到上次所在的目录</li>
</ul>
<h3 id="ls命令"><a href="#ls命令" class="headerlink" title="ls命令"></a>ls命令</h3><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">ls</span> &lt;args&gt;</span><br><span class="line"><span class="built_in">ls</span> -a	<span class="comment"># 查看所有文件</span></span><br><span class="line"><span class="built_in">ls</span> -h	<span class="comment"># 显示单位（文件大小）</span></span><br><span class="line"><span class="built_in">ls</span> -l	<span class="comment"># 查看文件详细信息</span></span><br><span class="line"><span class="comment"># d rwx rwx rx 5 mars mars 4096 Jan 2 17:20 &lt;name&gt;</span></span><br><span class="line"><span class="comment"># 文件类型 文件所有者权限 文件所属组权限 其他人权限 硬链接数目 文件所有者 文件所属组 文件大小 文件最后修改时间 文件名</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">ls</span> &lt;args&gt; path</span><br><span class="line"><span class="built_in">ls</span> &lt;args&gt; filename</span><br></pre></td></tr></table></figure></div>

<ul>
<li><p>文件类型</p>
<ul>
<li><code>-</code>：普通文件</li>
<li><code>d</code>：目录</li>
<li><code>l</code>：软链接（相当于快捷方式）</li>
<li><code>c</code>：字符设备</li>
<li><code>b</code>：块设备</li>
<li><code>p</code>：管道文件</li>
<li><code>s</code>：本地套接字文件</li>
</ul>
</li>
<li><p>用户类型</p>
<ul>
<li><p>文件所有者</p>
<blockquote>
<p>  Linux中的所有文件都有一个所有者，就是文件的主人</p>
</blockquote>
</li>
<li><p>文件所属组</p>
<blockquote>
<p>  文件的主人属于哪个组，这个文件就默认也就属于哪个组</p>
<p>  用户组可以有多个用户，这些组中的其他用户和所有者的权限可以是不一样的</p>
</blockquote>
</li>
<li><p>其他人</p>
<blockquote>
<p>  这个用户既不是文件所有者也不是文件所属组中的用户</p>
<p>  其他人对文件也可以拥有某些权限</p>
</blockquote>
</li>
</ul>
</li>
<li><p>文件权限</p>
<ul>
<li><code>r</code>：读权限</li>
<li><code>w</code>：写权限</li>
<li><code>x</code>：执行权限</li>
<li><code>-</code>：无权限</li>
</ul>
</li>
<li><p>硬链接数目</p>
<blockquote>
<p>  硬链接数N&gt;&#x3D;1，说明在一个或多个目录下公有N个文件，但是这N个文件并不占用多块磁盘空间，使用的是同一块。通过其中一个修改了磁盘数据，其他文件中的内容也就变了</p>
</blockquote>
</li>
<li><p>其它属性</p>
<ul>
<li>文件大小（如果是目录，不包括目录中内容的大小），单位是字节</li>
<li>文件日期，文件最后修改日期</li>
<li>文件名（如果显示形式为<code>link -&gt; /root/file/test</code>，后面路径表示的是快捷方式链接的是哪个磁盘文件）</li>
</ul>
</li>
</ul>
<h3 id="创建删除目录"><a href="#创建删除目录" class="headerlink" title="创建删除目录"></a>创建删除目录</h3><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建单层目录</span></span><br><span class="line"><span class="built_in">mkdir</span> <span class="built_in">dirname</span></span><br><span class="line"><span class="comment"># 创建多层目录</span></span><br><span class="line"><span class="built_in">mkdir</span> -p par/child/dirname</span><br></pre></td></tr></table></figure></div>

<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">rmdir</span> <span class="built_in">dirname</span>	<span class="comment"># 只能删除空目录</span></span><br><span class="line"><span class="built_in">rm</span> -r <span class="built_in">dirname</span>	<span class="comment"># 删除目录需要-r</span></span><br><span class="line"><span class="built_in">rm</span> -i -f filename	<span class="comment"># -i给提示，-f强制删除且不能恢复</span></span><br></pre></td></tr></table></figure></div>

<h3 id="cp命令"><a href="#cp命令" class="headerlink" title="cp命令"></a>cp命令</h3><ul>
<li><p>拷贝文件（文件不存在得到新文件，文件存在就覆盖）</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cp</span> pathA/fileA pathB/fileB</span><br></pre></td></tr></table></figure></div>
</li>
<li><p>拷贝目录（目录不存在得到新目录，该目录被拷贝到存在的目录中）</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 拷贝目录需要参数 -r</span></span><br><span class="line"><span class="built_in">cp</span> -r dirA dirB</span><br><span class="line"><span class="comment"># 拷贝pathA中所有内容到pathB</span></span><br><span class="line"><span class="built_in">cp</span> -r pathA/* pathB</span><br></pre></td></tr></table></figure></div></li>
</ul>
<h3 id="mv命令"><a href="#mv命令" class="headerlink" title="mv命令"></a>mv命令</h3><blockquote>
<p>  既可以移动文件也可以给文件改名</p>
</blockquote>
<ul>
<li><p>文件的移动</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mv</span> pathA/fileA pathB</span><br></pre></td></tr></table></figure></div>
</li>
<li><p>文件改名</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mv</span> pathA/fileA pathA/fileB</span><br></pre></td></tr></table></figure></div>
</li>
<li><p>文件覆盖</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mv</span> pathA/fileA pathB/fileA</span><br></pre></td></tr></table></figure></div></li>
</ul>
<h3 id="查看文件内容"><a href="#查看文件内容" class="headerlink" title="查看文件内容"></a>查看文件内容</h3><blockquote>
<p>  最常用的查看文件方式是使用vim</p>
</blockquote>
<ul>
<li><p><code>cat</code></p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 适合查看比较小的文件</span></span><br><span class="line"><span class="built_in">cat</span> &lt;filename&gt;</span><br></pre></td></tr></table></figure></div>
</li>
<li><p><code>more</code></p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">more &lt;filename&gt;</span><br><span class="line"><span class="comment"># 回车：显示下一行</span></span><br><span class="line"><span class="comment"># 空格：向后翻页</span></span><br><span class="line"><span class="comment"># b：向前翻页</span></span><br><span class="line"><span class="comment"># 上下方向键：前后翻页</span></span><br><span class="line"><span class="comment"># q：退出</span></span><br></pre></td></tr></table></figure></div>
</li>
<li><p><code>less</code></p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">less &lt;filename&gt;</span><br><span class="line"><span class="comment"># b：向前翻页</span></span><br><span class="line"><span class="comment"># 空格：向后翻页</span></span><br><span class="line"><span class="comment"># 回车：显示下一行</span></span><br><span class="line"><span class="comment"># 上下方向键：上下滚动</span></span><br><span class="line"><span class="comment"># q：退出</span></span><br></pre></td></tr></table></figure></div>
</li>
<li><p><code>head</code></p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看文件前n行，默认10行</span></span><br><span class="line"><span class="built_in">head</span> -n &lt;filename&gt;</span><br></pre></td></tr></table></figure></div>
</li>
<li><p><code>tail</code></p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看文件尾若干行，默认10行</span></span><br><span class="line"><span class="built_in">tail</span> -n &lt;filename&gt;</span><br></pre></td></tr></table></figure></div></li>
</ul>
<h3 id="链接的创建"><a href="#链接的创建" class="headerlink" title="链接的创建"></a>链接的创建</h3><blockquote>
<p>  链接分为软链接和硬链接，软链接相当于快捷方式，硬链接只是多出一个新的文件名并且硬链接数加1</p>
</blockquote>
<ul>
<li><p>软链接</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">ln</span> -s &lt;src&gt; &lt;dest&gt;</span><br></pre></td></tr></table></figure></div>
</li>
<li><p>硬链接</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">ln</span> &lt;src&gt; &lt;dest&gt;</span><br></pre></td></tr></table></figure></div>

<blockquote>
<p>  目录是不允许创建硬链接的</p>
</blockquote>
</li>
</ul>
<h3 id="文件属性"><a href="#文件属性" class="headerlink" title="文件属性"></a>文件属性</h3><blockquote>
<p>  文件属性相关的命令主要是修改用户对文件的操作权限，文件所有者，文件所属组的相关信息</p>
</blockquote>
<ul>
<li><p>修改文件权限</p>
<blockquote>
<p>  文件权限是针对文件所有者，文件所属组，其他人</p>
</blockquote>
<ul>
<li><p>文字表示法</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">chmod</span> &lt;<span class="built_in">who</span>&gt; [+ - =] &lt;mod&gt; &lt;filename&gt;</span><br><span class="line"><span class="comment"># who		u	g	o	a</span></span><br><span class="line"><span class="comment"># [+-=]		+	-	=</span></span><br><span class="line"><span class="comment"># mod		r	w	x	-</span></span><br></pre></td></tr></table></figure></div>
</li>
<li><p>数字表示法</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">chmod</span> [+ - =] &lt;mod&gt; &lt;filename&gt;</span><br><span class="line"><span class="comment"># [+-=]		+	 -	=</span></span><br><span class="line"><span class="comment"># mod		7rwx 4r 2w	1x  0-</span></span><br></pre></td></tr></table></figure></div></li>
</ul>
</li>
<li><p>修改文件所有者</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo <span class="built_in">chown</span> &lt;new_ower&gt; &lt;filename&gt;</span><br><span class="line">sudo <span class="built_in">chown</span> &lt;new_ower&gt;:&lt;new_group&gt; &lt;filename&gt;</span><br></pre></td></tr></table></figure></div>
</li>
<li><p>修改文件所有组</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo <span class="built_in">chgrp</span> &lt;new_group&gt; &lt;filename&gt;</span><br></pre></td></tr></table></figure></div></li>
</ul>
<h3 id="其他命令"><a href="#其他命令" class="headerlink" title="其他命令"></a>其他命令</h3><ul>
<li><p><code>tree</code></p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tree &lt;path&gt; [-L n]		<span class="comment"># 显示目录的层数</span></span><br></pre></td></tr></table></figure></div>
</li>
<li><p><code>pwd</code></p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">pwd</span>		<span class="comment"># 查看当前目录</span></span><br></pre></td></tr></table></figure></div>
</li>
<li><p><code>touch</code></p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建文件</span></span><br><span class="line"><span class="built_in">touch</span> &lt;filename&gt;</span><br></pre></td></tr></table></figure></div>
</li>
<li><p><code>which</code></p>
<blockquote>
<p>  查看执行的命令所在的路径</p>
<p>  该命令只能查看非内建的shell指令所在的实际路径，有些命令是写在内核中的，无法查看</p>
<p>  我们使用的大部分命令都是在 <code>/bin</code> <code>/usr/bin</code>目录下</p>
</blockquote>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">which</span> &lt;<span class="built_in">command</span>&gt;</span><br></pre></td></tr></table></figure></div>
</li>
<li><p><code>whatis</code></p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看一个命令执行什么功能</span></span><br><span class="line">whatis <span class="built_in">ls</span></span><br></pre></td></tr></table></figure></div>
</li>
<li><p><code>whereis</code></p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看二进制程序，代码等相关文件路径</span></span><br><span class="line">whereis &lt;filename&gt;</span><br></pre></td></tr></table></figure></div>
</li>
<li><p>重定向</p>
<ul>
<li><p>输入重定向</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="built_in">command</span>&gt; &lt; &lt;data&gt;</span><br></pre></td></tr></table></figure></div>
</li>
<li><p>输出重定向</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="built_in">command</span>&gt; &gt; &lt;res&gt;</span><br><span class="line"><span class="comment"># 将输出内容追加到指定的文件末尾</span></span><br><span class="line">&lt;<span class="built_in">command</span>&gt; &gt;&gt; &lt;res&gt;</span><br></pre></td></tr></table></figure></div></li>
</ul>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python3 a.py &lt; data.in &gt; res.out</span><br></pre></td></tr></table></figure></div></li>
</ul>
<h2 id="用户管理命令"><a href="#用户管理命令" class="headerlink" title="用户管理命令"></a>用户管理命令</h2><h3 id="切换用户"><a href="#切换用户" class="headerlink" title="切换用户"></a>切换用户</h3><blockquote>
<p>  Linux是一个多用户的操作系统，切换用户需要使用<code>su</code>或者<code>su -</code></p>
<p>  <code>su</code>仅会切换用户，不会切换当前工作目录</p>
<p>  <code>su -</code>不仅会切换用户，还会切换当前工作目录到当前用户的家目录</p>
<p>  如果想切换回去，可以直接使用<code>exit</code></p>
</blockquote>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">su &lt;user_name&gt;</span><br><span class="line">su - &lt;user_name&gt;</span><br><span class="line">...</span><br><span class="line"><span class="built_in">exit</span></span><br></pre></td></tr></table></figure></div>

<h3 id="添加删除用户"><a href="#添加删除用户" class="headerlink" title="添加删除用户"></a>添加删除用户</h3><blockquote>
<p>  需要root才能给系统添加新用户，或者给普通用户添加管理员权限</p>
<p>  添加新用户使用<code>adduser/useradd</code></p>
</blockquote>
<ul>
<li><p>添加用户</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sudo useradd -m -s /bin/bash &lt;user_name&gt;</span><br><span class="line">sudo passwd &lt;user_name&gt;	<span class="comment"># 设置密码</span></span><br><span class="line"><span class="comment"># -m 用户家目录不存在则创建</span></span><br><span class="line"><span class="comment"># -s 指定shell</span></span><br></pre></td></tr></table></figure></div>
</li>
<li><p>删除用户</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo userdel -r -f &lt;user_name&gt;</span><br><span class="line"><span class="comment"># -r 一并删除用户的家目录</span></span><br><span class="line"><span class="comment"># -f 强制删除</span></span><br></pre></td></tr></table></figure></div></li>
</ul>
<h3 id="添加删除用户组"><a href="#添加删除用户组" class="headerlink" title="添加删除用户组"></a>添加删除用户组</h3><blockquote>
<p>  默认情况下，创建新用户就会得到一个同名的用户组，并且这个用户属于这个组。如果需要可以使用<code>groupadd</code>添加用户组，使用<code>groupdel</code>删除用户组</p>
</blockquote>
<ul>
<li><p>添加用户组</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">sudo groupadd &lt;group_name&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在创建用户时加入用户组</span></span><br><span class="line">useradd -G &lt;group1&gt; &lt;group2&gt; &lt;user_name&gt;</span><br><span class="line"><span class="comment"># 设置新的主组</span></span><br><span class="line">useradd -g &lt;main_group&gt; -G &lt;sub_group&gt; &lt;user_name&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将已有的用户添加至用户组</span></span><br><span class="line">usermod -a -G &lt;group_name&gt; &lt;user_name&gt;</span><br></pre></td></tr></table></figure></div>
</li>
<li><p>删除用户组</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo groupdel &lt;group_name&gt;</span><br></pre></td></tr></table></figure></div></li>
</ul>
<h3 id="修改密码"><a href="#修改密码" class="headerlink" title="修改密码"></a>修改密码</h3><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 修改当前用户</span></span><br><span class="line">passwd</span><br><span class="line"><span class="comment"># 修改非当前用户</span></span><br><span class="line">sudo passwd &lt;user_name&gt;</span><br><span class="line"><span class="comment"># 修改root</span></span><br><span class="line">sudo passwd root</span><br></pre></td></tr></table></figure></div>

<h3 id="添加sudo权限"><a href="#添加sudo权限" class="headerlink" title="添加sudo权限"></a>添加sudo权限</h3><blockquote>
<p>  <code>sudoers</code>位于<code>/etc</code>下，默认没有写权限</p>
  <div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">su root</span><br><span class="line"><span class="built_in">chmod</span> +200 sudoers</span><br><span class="line"><span class="comment"># 加上</span></span><br><span class="line">username ALL=(ALL:ALL) ALL</span><br></pre></td></tr></table></figure></div>

</blockquote>
<h2 id="压缩命令"><a href="#压缩命令" class="headerlink" title="压缩命令"></a>压缩命令</h2><blockquote>
<p>  Linux上常用压缩格式：<code>tar.gz</code> <code>tgz</code> <code>tar.bz2</code> <code>zip</code> <code>rar</code> <code>tar.xz</code></p>
</blockquote>
<h3 id="tar"><a href="#tar" class="headerlink" title="tar"></a>tar</h3><blockquote>
<p>  Linux上系统自带的两个原始压缩工具：<code>gzip</code> <code>bzip2</code>，但是不能打包压缩文件，压缩之后不会保留源文件</p>
<p>  Linux上自带的打包工具，<code>tar</code>不能进行压缩操作，<code>tar</code>和<code>gzip</code> <code>bzip2</code>结合，最强大的打包压缩工具</p>
</blockquote>
<ul>
<li><p>压缩</p>
<blockquote>
<p>  一般认为<code>tgz</code>文件等同于<code>tar.gz</code>，他们的压缩方式是相同的</p>
<ul>
<li><code>c</code>：创建压缩文件</li>
<li><code>z</code>：使用<code>gzip</code>的方式进行文件压缩</li>
<li><code>j</code>：使用<code>bzip2</code>的方式进行文件压缩</li>
<li><code>v</code>：压缩过程中显示压缩信息，可以省略不写</li>
<li><code>f</code>：指定压缩包的名字</li>
</ul>
</blockquote>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 压缩目录中所有文件（使用gzip）</span></span><br><span class="line">tar czvf all.tar.gz *</span><br><span class="line"><span class="comment"># 压缩指定文件（使用bzip2）</span></span><br><span class="line">tar cjvf all.tar.bz2 &lt;f1 f2 f3...&gt;</span><br></pre></td></tr></table></figure></div>
</li>
<li><p>解压缩</p>
<blockquote>
<ul>
<li><code>x</code>：释放压缩文件内容</li>
<li><code>z</code>：使用<code>gzip</code>的方式进行解压缩</li>
<li><code>j</code>：使用<code>bzip2</code>的方式进行解压缩</li>
<li><code>v</code>：解压缩过程中显示解压缩信息</li>
<li><code>f</code>：指定压缩包的名字</li>
</ul>
<blockquote>
<p>  如果需要解压到指定目录，需要指定参数<code>-C</code></p>
</blockquote>
</blockquote>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 将all.tar.gz解压到&lt;path&gt;目录（gzip）</span></span><br><span class="line">tar xzvf all.tar.gz -C &lt;path&gt;</span><br><span class="line"><span class="comment"># 将all.tar.bz2解压到当前目录（bzip2）</span></span><br><span class="line">tar xjvf all.tar.bz2</span><br></pre></td></tr></table></figure></div></li>
</ul>
<h3 id="zip"><a href="#zip" class="headerlink" title="zip"></a>zip</h3><ul>
<li><p>压缩<code>zip</code></p>
<blockquote>
<p>  使用<code>zip</code>压缩目录需要注意，必须添加<code>-r</code>参数才能将子目录中的文件一并压缩</p>
</blockquote>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 将当前目录下所有内容压缩</span></span><br><span class="line">zip -r all *</span><br></pre></td></tr></table></figure></div>
</li>
<li><p>解压缩<code>unzip</code></p>
<blockquote>
<p>  使用<code>uzip</code>解压缩到指定目录，需要给定<code>-d</code>参数，默认当前目录</p>
</blockquote>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">unzip all.zip -d &lt;path&gt;</span><br></pre></td></tr></table></figure></div></li>
</ul>
<h3 id="rar"><a href="#rar" class="headerlink" title="rar"></a>rar</h3><ul>
<li><p>压缩</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rar a -r all *</span><br></pre></td></tr></table></figure></div>
</li>
<li><p>解压缩</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rar x all.rar &lt;path&gt;</span><br></pre></td></tr></table></figure></div></li>
</ul>
<h3 id="xz"><a href="#xz" class="headerlink" title="xz"></a>xz</h3><blockquote>
<p>  <code>tar.xz</code>格式的文件压缩和解压缩都比较麻烦，通过一个命令是完不成对应的操作的。</p>
<p>  使用<code>tar</code>工具打包，<code>xz</code>工具压缩</p>
</blockquote>
<ul>
<li><p>压缩</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tar cvf all.tar *</span><br><span class="line">xz -z all.tar</span><br></pre></td></tr></table></figure></div>
</li>
<li><p>解压缩</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">xz -d all.tar.xz</span><br><span class="line">tar xvf all.tar</span><br></pre></td></tr></table></figure></div></li>
</ul>
<h2 id="查找命令"><a href="#查找命令" class="headerlink" title="查找命令"></a>查找命令</h2><h3 id="find"><a href="#find" class="headerlink" title="find"></a>find</h3><blockquote>
<p>  根据文件属性查找</p>
</blockquote>
<h4 id="文件名"><a href="#文件名" class="headerlink" title="文件名"></a>文件名</h4><blockquote>
<p>  根据文件名搜索有两种方式：精确查询和模糊查询</p>
<p>  模糊查询必须要使用对应的通配符 <code>* </code>匹配零个或多个字符 <code>?</code>匹配单个字符</p>
<p>  如果我们进行模糊查询，建议将带有通配符的文件名写到引号中</p>
</blockquote>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find &lt;path&gt; -name &lt;filename&gt;</span><br></pre></td></tr></table></figure></div>

<h4 id="文件类型"><a href="#文件类型" class="headerlink" title="文件类型"></a>文件类型</h4><table>
<thead>
<tr>
<th>文件类型</th>
<th>类型的字符描述</th>
</tr>
</thead>
<tbody><tr>
<td>普通文件类型化</td>
<td><code>f</code></td>
</tr>
<tr>
<td>目录类型</td>
<td><code>d</code></td>
</tr>
<tr>
<td>软链接类型</td>
<td><code>l</code></td>
</tr>
<tr>
<td>字符设备类型</td>
<td><code>c</code></td>
</tr>
<tr>
<td>块设备类型</td>
<td><code>b</code></td>
</tr>
<tr>
<td>管道类型</td>
<td><code>p</code></td>
</tr>
<tr>
<td>本地套接字类型</td>
<td><code>s</code></td>
</tr>
</tbody></table>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find &lt;path&gt; -<span class="built_in">type</span> &lt;filetype&gt;</span><br></pre></td></tr></table></figure></div>

<h4 id="文件大小"><a href="#文件大小" class="headerlink" title="文件大小"></a>文件大小</h4><blockquote>
<p>  文件大小的单位 <code>K</code> <code>M</code> <code>G</code></p>
<p>  在进行文件大小判断的时候，需要指定相应的范围 <code>+</code> <code>-</code></p>
</blockquote>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">find . -size +3M				<span class="comment"># file &gt; 3M</span></span><br><span class="line">find . -size -3M				<span class="comment"># 0M &lt;= file &lt;= 2M</span></span><br><span class="line">find . -size 3M					<span class="comment"># 2M &lt; file &lt;= 3M</span></span><br><span class="line">find . -size +1M -size -4M		<span class="comment"># 1M &lt; file &lt;= 3M</span></span><br></pre></td></tr></table></figure></div>

<blockquote>
<p>  <code>-size 4K</code>		<code>(4-1K, 4K]</code></p>
<p>  <code>-size -4K</code>		<code>[0K, 4-1K]</code></p>
<p>  <code>-size +4K</code>		<code>(4K, +inf)</code></p>
</blockquote>
<h4 id="目录层级"><a href="#目录层级" class="headerlink" title="目录层级"></a>目录层级</h4><blockquote>
<p>  Linux的目录是树状结构，可以指定搜索层级<code>-maxdepth</code> <code>-mindepth</code></p>
<ul>
<li><code>maxdepth</code>：最多搜索到多少层目录</li>
<li><code>mindepth</code>：至少从多少层开始搜索</li>
</ul>
</blockquote>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">find . -maxdepth 5 -name <span class="string">&quot;*.txt&quot;</span>	<span class="comment"># 最多搜索五层</span></span><br><span class="line">find . -mindepth 5 -name <span class="string">&quot;*.txt&quot;</span>	<span class="comment"># 至少从第五层开始搜索</span></span><br></pre></td></tr></table></figure></div>

<h4 id="同时执行多个操作"><a href="#同时执行多个操作" class="headerlink" title="同时执行多个操作"></a>同时执行多个操作</h4><blockquote>
<p>  在搜索文件的时候如果想在一个<code>find</code>执行多个操作，通过使用管道<code>|</code>的方式是行不通的</p>
<p>  如果想实现上面的需求，需要在<code>find</code>中使用<code>exec</code> <code>ok</code> <code>xargs</code></p>
</blockquote>
<ul>
<li><p><code>exec</code></p>
<blockquote>
<p>  添加<code>exec</code>后需要在命令的尾部加上<code>&#123;&#125; \;</code></p>
</blockquote>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find &lt;path&gt; &lt;arg&gt; &lt;argv&gt; -<span class="built_in">exec</span> &lt;<span class="built_in">command</span>&gt; &#123;&#125; \;</span><br></pre></td></tr></table></figure></div>

<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find . -maxdepth 3 -name <span class="string">&quot;*.txt&quot;</span> -<span class="built_in">exec</span> <span class="built_in">ls</span> -l &#123;&#125; \;</span><br></pre></td></tr></table></figure></div>
</li>
<li><p><code>ok</code></p>
<blockquote>
<p>  使用方式和<code>exec</code>类似，但是这个参数是交互式的</p>
</blockquote>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find &lt;path&gt; &lt;arg&gt; &lt;argv&gt; -ok &lt;<span class="built_in">command</span>&gt; &#123;&#125; \;</span><br></pre></td></tr></table></figure></div>
</li>
<li><p><code>xargs</code></p>
<blockquote>
<p>  在使用<code>exec</code>和<code>ok</code>时需要在尾部加上<code>&#123;&#125; \;</code>，使用<code>xargs</code>就可以结合管道来完成</p>
</blockquote>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find &lt;path&gt; &lt;arg&gt; &lt;argv&gt; | xargs &lt;<span class="built_in">command</span>&gt;</span><br></pre></td></tr></table></figure></div>

<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find . -name <span class="string">&quot;*.txt&quot;</span> | xargs <span class="built_in">ls</span> -l</span><br></pre></td></tr></table></figure></div></li>
</ul>
<h3 id="grep"><a href="#grep" class="headerlink" title="grep"></a>grep</h3><ul>
<li><code>-r</code>：搜索目录中的文件内容，需要递归操作，指定该参数</li>
<li><code>-i</code>：搜索关键字，忽略字符大小写的差别</li>
<li><code>-n</code>：在显示符合样式那一行之前，表示出该行的列数编号</li>
</ul>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grep &lt;<span class="string">&quot;info&quot;</span>&gt; &lt;path&gt;/&lt;file&gt; &lt;arg&gt;</span><br></pre></td></tr></table></figure></div>

<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">grep <span class="string">&quot;include&quot;</span> a.c</span><br><span class="line">grep <span class="string">&quot;Include&quot;</span> ./ -rin</span><br></pre></td></tr></table></figure></div>

<h3 id="locate"><a href="#locate" class="headerlink" title="locate"></a>locate</h3><blockquote>
<p>  <code>locate</code>可以看做是一个简化版的<code>find</code>，但是他并不在具体的目录中搜索，而是在一个数据库文件中搜索</p>
</blockquote>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用前更新数据库</span></span><br><span class="line">sudo updatedb</span><br></pre></td></tr></table></figure></div>

<ul>
<li><p>搜索以某个关键字开头的文件</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">locate <span class="built_in">test</span></span><br><span class="line"><span class="comment"># 指定目录 /home/user/ 下（必须是绝对路径）</span></span><br><span class="line">locate /home/user/test</span><br></pre></td></tr></table></figure></div>
</li>
<li><p>搜索时忽略大小写<code>-i</code></p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">locate Test -i</span><br></pre></td></tr></table></figure></div>
</li>
<li><p>列出前N个匹配到的文件名称或路径名称<code>-n</code></p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">locate <span class="built_in">test</span> -n 5</span><br></pre></td></tr></table></figure></div>
</li>
<li><p>基于正则表达式<code>-r</code></p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 搜索以.cpp结尾的文件</span></span><br><span class="line">locate -r <span class="string">&quot;\.cpp$&quot;</span></span><br></pre></td></tr></table></figure></div></li>
</ul>
<h2 id="文件描述符"><a href="#文件描述符" class="headerlink" title="文件描述符"></a>文件描述符</h2><h3 id="虚拟地址空间"><a href="#虚拟地址空间" class="headerlink" title="虚拟地址空间"></a>虚拟地址空间</h3><blockquote>
<p>  虚拟地址空间是一个非常抽象的概念</p>
<ul>
<li>它可以用来加载程序数据（数据可能被加载到物理内存上，空间不够就加载到虚拟内存上）</li>
<li>它对应一段连续的内存地址，起始位置为0</li>
<li>之所以说虚拟是因为这个起始的0地址是被虚拟出来的，不是物理内存的0地址</li>
</ul>
</blockquote>
<p>虚拟地址空间大小由操作系统决定，32位操作系统虚拟地址空间大小为2^32字节，4G</p>
<p>当我们运行磁盘上的一个可执行程序时，就会得到一个进程，内核会给每个运行的进程创建一块属于<br>自己的虚拟地址空间，并将应用程序数据装载到虚拟地址空间对应的地址上</p>
<p>进程在运行过程中，程序内部所有指令都是通过CPU处理完成的，CPU只进行数据运算并不具备数据<br>存储的能力，其数据处理都是通过加载物理内存，进程中的数据通过CPU中的内存管理单元MMU从<br>进程的虚拟地址空间映射过去的</p>
<h4 id="存在的意义"><a href="#存在的意义" class="headerlink" title="存在的意义"></a>存在的意义</h4><blockquote>
<p>  直接在物理内存上分配内存会出现以下问题：</p>
<ul>
<li><p>每个进程的地址不隔离，有安全风险</p>
<blockquote>
<p>  由于程序都是直接访问物理内存，恶意程序可以通过内存寻址随意修改别的进程对应的内存</p>
<p>  数据</p>
</blockquote>
</li>
<li><p>内存效率低</p>
<blockquote>
<p>  如果直接使用物理内存，一个进程对应的内存块就是作为一个整体操作的，如果内存不够的</p>
<p>  话，一般是将不常用的进程拷贝到磁盘的交换分区（虚拟地址）中，腾出内存，需要将整个</p>
<p>  进程拷贝走，效率低下</p>
</blockquote>
</li>
<li><p>进程中数据的地址不确定，每次都会发生变化</p>
<blockquote>
<p>  物理内存使用情况一直在动态变化，无法确定内存现在使用到哪里，如果直接将程序加载到</p>
<p>  物理内存，内存中每次存储数据的起始地址1都是不一样的，这样数据的加载要使用相对地</p>
<p>  址，加载效率低</p>
</blockquote>
</li>
</ul>
</blockquote>
<p><code>虚拟地址空间就是一个中间层，相当于在程序和物理内存之间设置了一个屏障，将二者隔离开来。程序中</code></p>
<p><code>访问的内存地址不再是实际的物理内存地址，而是一个虚拟地址，然后由操作系统将这个虚拟地址映射到</code></p>
<p><code>适当的物理内存地址上</code>只要操作系统处理好虚拟地址到物理地址的映射，就可以保证不同的程序最终</p>
<p>访问的内存地址位于不同的区域，彼此没有重叠，可以达到内存地址空间隔离的效果</p>
<h4 id="分区"><a href="#分区" class="headerlink" title="分区"></a>分区</h4><p><strong>从操作系统层级上看，虚拟地址空间主要分为<code>内核区</code>和<code>用户区</code></strong></p>
<ul>
<li>内核区<ul>
<li>内核空间为内核保留，不允许应用程序读写该区域的内容或直接调用内核代码定义的函数</li>
<li>内核总是驻留在内存中，是操作系统的一部分</li>
<li>系统中所有进程对应的虚拟地址空间的内核区都会映射到同一块物理内存上（系统内核只有一个）</li>
</ul>
</li>
<li>用户区：存储用户程序运行中用到的各种数据</li>
</ul>
<blockquote>
<p>  每个进程的虚拟地址都是从0开始的，我们在程序中打印的变量地址也在其虚拟地址空间中的地址，程序是<br>  无法直接访问物理内存的。虚拟地址空间中用户区范围是0~3G（32位系统为例），里面分为多个区块：</p>
<ul>
<li><code>保留区</code>：位于虚拟地址空间的最底部，未赋予物理地址。任何对它的引用都是非法的，程序中的空指针<br>就是指向的这块内存地址</li>
<li><code>.text段</code>：代码段也称正文段或文本段，通常用于存放程序的执行代码（即CPU执行的机器指令），代<br>码段一般情况下是只读的，这是对执行代码的一种保护机制</li>
<li><code>.data段</code>：数据段通常用于存放程序中已初始化且初值不为0的全局变量和静态变量。数据段属于静态内<br>存分配（静态存储区），可读可写</li>
<li><code>.bss段</code>：未初始化以及初始为0的全局变量和静态变量，操作系统会将这些未初始化变量初始化为0</li>
<li><code>堆 heap</code>：用于存放进程运行时动态分配的内存<ul>
<li>堆中内容是匿名的，不能按名字直接访问，只能通过指针间接访问</li>
<li>堆向高地址扩展，是不连续的内存区域。系统用链表来存储空闲内存地址，自然不连续，而链表从<br>低地址向高地址遍历</li>
</ul>
</li>
<li><code>内存映射区 mmap</code>：作为内存映射区加载磁盘文件，或者加载程序运行过程中需要调用的动态库</li>
<li><code>栈 stack</code>：存储函数内部声明的非静态局部变量，函数参数，函数返回地址等，栈内存由编译器自动<br>分配释放。栈向低地址扩展，分配的内存是连续的</li>
<li><code>命令行参数</code>：存储进程执行的时候传递给<code>main()</code>函数的参数</li>
<li><code>环境变量</code>：存储和进程相关的环境变量，工作路径，进程所有者等信息</li>
</ul>
</blockquote>
<h3 id="文件描述符-1"><a href="#文件描述符-1" class="headerlink" title="文件描述符"></a>文件描述符</h3><h4 id="文件描述符-2"><a href="#文件描述符-2" class="headerlink" title="文件描述符"></a>文件描述符</h4><blockquote>
<p>  在Linux操作系统中的一切都被抽象成了文件，使用文件描述符<code>file descriptor(fd)</code>，当进程中打开一个现有文件或者创建一个新文件时，内核向该进程返回一个文件描述符，用于对应这个打开、新建的文件。这些文件描述符都存储在内<br>  核为每个进程维护的一个文件描述符表中</p>
<blockquote>
<p>  在Linux系统中一切皆文件，系统中的一切都被抽象成了文件，对这些文件的读写都需要通过文件描述符来完成</p>
</blockquote>
</blockquote>
<h4 id="文件描述符表"><a href="#文件描述符表" class="headerlink" title="文件描述符表"></a>文件描述符表</h4><blockquote>
<p>  启动一个进程就会得到一个对应的虚拟地址表，这个虚拟地址空间分为两大部分，在内核区有专门用于进程管理的模块</p>
<p>  Linux的进程控制块PCB本质是一个叫做<code>task_struct</code>的结构体，里面包括管理进程所需的各种信息，其中一个结构体<br>  叫做<code>file</code>，我们将它叫做文件描述表，里面有一个整形索引表，用于存储文件描述符</p>
<blockquote>
<p>  内核会为每一个进程维护一个文件描述表，索引表中的值都是从0开始的，所以在不同的进程会看到相同的文件描述<br>  符，但是它们指向的不一定是同一个磁盘文件</p>
</blockquote>
</blockquote>
<ul>
<li><p>打开的最大文件数</p>
<p>每一个进程对应的文件描述符能够存储的打开的文件数是有限制的，默认1024个，可以修改，上限取决于硬件</p>
</li>
<li><p>默认分配的文件描述符</p>
<p>当一个进程被启动之后，内核PCB的文件描述符表中就已经分配了三个文件描述符，这三个文件描述符对应的都<br>是当前启动这个进程的终端文件，在<code>/dev</code>中</p>
<ul>
<li><code>STDIN_FILENO</code>：标准输入，通过该文件描述符将数据输入到终端文件中，宏值为0</li>
<li><code>STDOUT_FILENO</code>：标准输出，通过该文件描述符将数据输出到终端文件中，宏值为1</li>
<li><code>STDERR_FILENO</code>：标准错误，通过该文件描述符将错误信息通过终端输出出来，宏值为2</li>
</ul>
<blockquote>
<p>  这三个默认分配的文件描述符可以通过<code>close()</code>关掉，单数关闭之后当前进程就不能和当前终端进行输入<br>  或者输出的信息交互了</p>
</blockquote>
</li>
<li><p>给新打开的文件分配文件描述符</p>
<ul>
<li><p>进程启动后，文件描述符表中的<code>0 1 2</code>就被分配出去了，因此从<code>3</code>开始分配</p>
</li>
<li><p>在进程中每打开一个文件，就会给这个文件分配一个新的文件描述符</p>
<blockquote>
<p>  使用<code>open()</code>打开一个文件，文件描述符3就被分配给这个文件，再打开一个文件，文件描述符4被分配</p>
<p>  使用之后将文件关闭，文件描述符就被释放</p>
</blockquote>
</li>
</ul>
</li>
</ul>
<h2 id="Linux系统文件IO"><a href="#Linux系统文件IO" class="headerlink" title="Linux系统文件IO"></a>Linux系统文件IO</h2><p><code>系统函数不是内核函数</code>，是系统的专属函数</p>
<p>下面是一些Linux系统IO函数，和标准C库的IO函数使用方法类似</p>
<h3 id="open-close"><a href="#open-close" class="headerlink" title="open&#x2F;close"></a>open&#x2F;close</h3><h4 id="open函数原型"><a href="#open函数原型" class="headerlink" title="open函数原型"></a>open函数原型</h4><div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">open是一个系统函数, 只能在linux系统中使用, windows不支持</span></span><br><span class="line"><span class="comment">fopen 是标准c库函数, 一般都可以跨平台使用, 可以这样理解:</span></span><br><span class="line"><span class="comment">		- 在linux中 fopen底层封装了Linux的系统API open</span></span><br><span class="line"><span class="comment">		- 在window中, fopen底层封装的是 window 的 api</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">// 打开一个已经存在的磁盘文件</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">open</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname, <span class="type">int</span> flags)</span>;</span><br><span class="line"><span class="comment">// 打开磁盘文件, 如果文件不存在, 就会自动创建</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">open</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname, <span class="type">int</span> flags, <span class="type">mode_t</span> mode)</span>;</span><br></pre></td></tr></table></figure></div>

<p> 参数介绍：</p>
<ul>
<li><p><code>pathanme</code>：被打开的文件的文件名</p>
</li>
<li><p><code>flag</code>：使用什么方式打开文件，这个参数对应一些宏值</p>
<ul>
<li><p><code>O_RDONLY</code>：只读</p>
</li>
<li><p><code>O_WRONLY</code>：只写</p>
</li>
<li><p><code>O_RDWR</code>：读写</p>
</li>
<li><p>可选属性</p>
<ul>
<li><p><code>O_APPEND</code>：新数据追加到文件尾部，不会覆盖文件的原来内容</p>
</li>
<li><p><code>O_CREAT</code>：如果文件不存在就创建文件</p>
</li>
<li><p><code>O_EXCL</code>：检测文件是否存在，必须和<code>O_CREAT</code>一起使用：<code>O_CREAT | O_EXCL</code></p>
<blockquote>
<p>  检测到文件不存在就创建文件</p>
<p>  检测到文件存在就返回-1</p>
</blockquote>
</li>
</ul>
</li>
</ul>
</li>
<li><p><code>mode</code>：在创建新文件时才需要指定该参数，用于指定新文件的权限</p>
<ul>
<li><p>这个参数最大值为：<code>0777</code></p>
</li>
<li><p>创建的新文件对应的最终实际权限：<code>mode &amp; ~umask</code></p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">umask</span>	<span class="comment"># 查看umask</span></span><br></pre></td></tr></table></figure></div></li>
</ul>
</li>
</ul>
<p>返回值：</p>
<ul>
<li>成功：返回内核分配的文件描述符，这个值被记录在内核的文件描述符表中</li>
<li>失败：-1</li>
</ul>
<h4 id="close函数原型"><a href="#close函数原型" class="headerlink" title="close函数原型"></a>close函数原型</h4><div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">close</span><span class="params">(<span class="type">int</span> fd)</span>;</span><br></pre></td></tr></table></figure></div>

<ul>
<li>函数参数：<code>fd</code>是文件描述符，是<code>open()</code>函数的返回值</li>
<li>函数返回值：函数调用成功返回值0，调用失败返回-1</li>
</ul>
<h4 id="打开已存在文件"><a href="#打开已存在文件" class="headerlink" title="打开已存在文件"></a>打开已存在文件</h4><blockquote>
<p>  我们可以使用<code>open</code>打开一个本地已经存在的文件</p>
  <div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> fd = open(<span class="string">&quot;file&quot;</span>, O_RDWR);</span><br><span class="line">close(fd);</span><br></pre></td></tr></table></figure></div>
</blockquote>
<h4 id="创建新文件"><a href="#创建新文件" class="headerlink" title="创建新文件"></a>创建新文件</h4><blockquote>
<p>  如果要创建一个新的文件，还是使用<code>open</code>函数，需要添加<code>O_CREAT</code>属性，并且给新文件指定操作权限</p>
  <div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> fd = open(<span class="string">&quot;file&quot;</span>, O_CREAT | O_RDWR, <span class="number">0664</span>);</span><br><span class="line">close(fd);</span><br></pre></td></tr></table></figure></div>
</blockquote>
<h4 id="文件状态判断"><a href="#文件状态判断" class="headerlink" title="文件状态判断"></a>文件状态判断</h4><blockquote>
<p>  在创建新文件的时候我们还可以通过<code>O_EXCL</code>进行文件的检测</p>
  <div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建新文件之前, 先检测是否存在</span></span><br><span class="line"><span class="comment">// 文件存在创建失败, 返回-1, 文件不存在创建成功, 返回分配的文件描述符</span></span><br><span class="line"><span class="type">int</span> fd = open(<span class="string">&quot;file&quot;</span>, O_CREAT | O_EXCL | O_RDWR);</span><br><span class="line">close(fd);</span><br></pre></td></tr></table></figure></div>
</blockquote>
<h3 id="read-write"><a href="#read-write" class="headerlink" title="read&#x2F;write"></a>read&#x2F;write</h3><h4 id="read"><a href="#read" class="headerlink" title="read"></a>read</h4><blockquote>
<p>  <code>read</code>函数用于读取文件内部数据，在通过<code>open</code>打开文件的时候需要指定读权限</p>
  <div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ssize_t</span> <span class="title function_">read</span><span class="params">(<span class="type">int</span> fd, <span class="type">void</span> *buf, <span class="type">size_t</span> count)</span>;</span><br></pre></td></tr></table></figure></div>
</blockquote>
<ul>
<li>参数<ul>
<li><code>fd</code>：文件描述符，open函数的返回值，通过这个参数定位打开的磁盘文件</li>
<li><code>buf</code>：是一个传出参数，指向一块有效的内存，用于存储从文件中读出的数据</li>
<li><code>count</code>：buf指针指向的内存的大小，指定可以存储的最大字节数</li>
</ul>
</li>
<li>返回值<ul>
<li>大于0：从文件中读出的字节数，读文件成功</li>
<li>等于0：文件读完了，读文件成功</li>
<li>-1：读文件失败了</li>
</ul>
</li>
</ul>
<h4 id="write"><a href="#write" class="headerlink" title="write"></a>write</h4><blockquote>
<p>  <code>write</code>函数用于将数据写入到文件内部，在通过open打开文件的时候需要指定写权限</p>
  <div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ssize_t</span> <span class="title function_">write</span><span class="params">(<span class="type">int</span> fd, <span class="type">const</span> <span class="type">void</span> *buf, <span class="type">size_t</span> count)</span>;</span><br></pre></td></tr></table></figure></div>
</blockquote>
<ul>
<li>参数<ul>
<li><code>fd</code>：文件描述符，open函数返回值，通过这个参数定位打开的磁盘文件</li>
<li><code>buf</code>：指向一块有效的内存地址，里面有要写入到磁盘文件中的数据</li>
<li><code>count</code>：要往磁盘文件中写入的字节数，一般情况下就是buf字符串的长度</li>
</ul>
</li>
<li>返回值<ul>
<li>大于0：成功写入到磁盘文件中的字节数</li>
<li>-1：写文件失败了</li>
</ul>
</li>
</ul>
<h4 id="文件拷贝"><a href="#文件拷贝" class="headerlink" title="文件拷贝"></a>文件拷贝</h4><blockquote>
<p>  假设有一个比较大的磁盘文件，打开这个文件得到文件描述符 fd1，然后在创建一个新的磁盘文件得到文件描述符 fd2</p>
<p>  在程序中通过 fd1 将文件内容读出，并通过 fd2 将读出的数据写入到新文件中</p>
</blockquote>
<h3 id="lseek"><a href="#lseek" class="headerlink" title="lseek"></a>lseek</h3><blockquote>
<p>  可以通过<code>lseek</code>函数来移动文件指针，也可以通过这个函数进行文件的扩展</p>
  <div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">off_t</span> <span class="title function_">lseek</span><span class="params">(<span class="type">int</span> fd, <span class="type">off_t</span> offset, <span class="type">int</span> whence)</span>;</span><br></pre></td></tr></table></figure></div>
</blockquote>
<ul>
<li>参数<ul>
<li><code>fd</code>：文件描述符，open函数的返回值，通过这个参数定位打开的磁盘文件</li>
<li><code>offset</code>：偏移量，需要和第三个参数配合使用</li>
<li><code>whence</code>：通过这个参数指定函数实现什么样的功能<ul>
<li><code>SEEK_SET</code>：从文件头部开始偏移offset个字节</li>
<li><code>SEEK_CUR</code>：从当前文件指针的位置向后偏移offset个字节</li>
<li><code>SEEK_END</code>：从文件尾部向后偏移offset个字节</li>
</ul>
</li>
</ul>
</li>
<li>返回值<ul>
<li>成功：文件指针从头部开始计算总的偏移量</li>
<li>失败：-1</li>
</ul>
</li>
</ul>
<h4 id="移动文件指针"><a href="#移动文件指针" class="headerlink" title="移动文件指针"></a>移动文件指针</h4><blockquote>
<p>  通过lseek函数第三个参数的设置，经常使用该函数实现如下几个功能</p>
</blockquote>
<ul>
<li><p>文件指针移动到文件头部</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lseek(fd, <span class="number">0</span>, SEEK_SET);</span><br></pre></td></tr></table></figure></div>
</li>
<li><p>得到当前文件指针的位置</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lseek(fd, <span class="number">0</span>, SEEK_CUR); </span><br></pre></td></tr></table></figure></div>
</li>
<li><p>得到文件总大小</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lseek(fd, <span class="number">0</span>, SEEK_END);</span><br></pre></td></tr></table></figure></div></li>
</ul>
<h4 id="文件扩展"><a href="#文件扩展" class="headerlink" title="文件扩展"></a>文件扩展</h4><blockquote>
<p>  下载大文件时，先进行文件扩展，将一些字符写入到目标文件中，让拓展的文件和即将被下载的文件一样大，这样<br>  磁盘就成功抢到手</p>
<blockquote>
<p>  使用<code>lseek</code>函数进行文件扩展必须要满足下面两个条件：</p>
<ul>
<li>文件指针必须要偏移到文件尾部之后，多出来的就需要被填充</li>
<li>文件扩展之后，必须使用<code>write</code>函数进行一次写操作（写什么都可以，没有字节数要求）</li>
</ul>
</blockquote>
</blockquote>
<h3 id="truncate-ftruncate"><a href="#truncate-ftruncate" class="headerlink" title="truncate&#x2F;ftruncate"></a>truncate&#x2F;ftruncate</h3><p><code>truncate/ftruncate</code>这两个函数功能是一样的，可以对文件进行扩展也可以截断文件。使用这两个扩展文件<br>比使用<code>lseek</code>要简单</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">truncate</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *path, <span class="type">off_t</span> length)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">ftruncate</span><span class="params">(<span class="type">int</span> fd, <span class="type">off_t</span> length)</span>;</span><br></pre></td></tr></table></figure></div>

<ul>
<li>参数<ul>
<li><code>path</code>：要扩展、截断的文件的文件名</li>
<li><code>fd</code>：文件描述符，open函数得到</li>
<li><code>length</code>：文件的最终大小<ul>
<li>文件原来<code>size &gt; length</code>，文件被截断，尾部多余的部分被删除，文件最终长度为<code>length</code></li>
<li>文件原来<code>size &lt; length</code>，文件被拓展，文件最终长度为length</li>
</ul>
</li>
</ul>
</li>
<li>返回值：成功返回0，失败返回-1</li>
</ul>
<blockquote>
<p>  <code>truncate() ftruncate()</code>两个函数最大区别在于一个使用文件名，一个使用文件描述符</p>
</blockquote>
<h3 id="perror"><a href="#perror" class="headerlink" title="perror"></a>perror</h3><blockquote>
<p>  在Linux大多数系统函数中都是通过返回值来描述系统函数的状态</p>
<p>  <code>errno</code>是一个全局变量，只要调用的Linux系统函数有异常（返回-1），错误对应的错误号就会被设置给</p>
<p>  这个全局变量，这个错误号存储在系统的两个头文件中：</p>
<p>  <code>/usr/include/asm-generic/errno-base.h</code></p>
<p>  <code>/usr/include/asm-generic/errno.h</code></p>
<blockquote>
<p>  得到错误号，去查询对应的头文件是非常不方便的，我们可以通过<code>perror</code>函数将错误号对应的信息输出</p>
  <div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="comment">// 参数, 自己指定这个字符串的值就可以, 指定什么就会原样输出, 除此之外还会输出错误号对应的描述信息</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">perror</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *s)</span>;</span><br></pre></td></tr></table></figure></div>
</blockquote>
</blockquote>
<h3 id="错误号"><a href="#错误号" class="headerlink" title="错误号"></a>错误号</h3><blockquote>
<p>  <code>/usr/include/asm-generic/errno-base.h</code></p>
<p>  <code>/usr/include/asm-generic/errno.h</code></p>
</blockquote>
<h2 id="文件属性信息"><a href="#文件属性信息" class="headerlink" title="文件属性信息"></a>文件属性信息</h2><blockquote>
<p>  使用<code>命令</code>或<code>函数</code>查看某一个文件的属性</p>
</blockquote>
<h3 id="file命令"><a href="#file命令" class="headerlink" title="file命令"></a>file命令</h3><blockquote>
<p>  该命令用来识别文件类型，也可用来辨别一些文件的编码格式，通过查看文件头部信息来获取文件类型</p>
</blockquote>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">file &lt;filename&gt; [args]</span><br></pre></td></tr></table></figure></div>

<p><code>file</code>命令的参数是可选项</p>
<table>
<thead>
<tr>
<th align="center">参数</th>
<th align="center">功能</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>-b</code></td>
<td align="center">只显示文件类型和文件编码，不显示文件名</td>
</tr>
<tr>
<td align="center"><code>-i</code></td>
<td align="center">显示文件的MIME类型</td>
</tr>
<tr>
<td align="center"><code>-F</code></td>
<td align="center">设置输出字符串的分隔符</td>
</tr>
<tr>
<td align="center"><code>-L</code></td>
<td align="center">查看软链接文件自身文件属性</td>
</tr>
</tbody></table>
<ul>
<li><p>查看文件类型和编码格式</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">file &lt;filename&gt;</span><br></pre></td></tr></table></figure></div>
</li>
<li><p>只显示文件格式以及编码</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">file &lt;filename&gt; -b</span><br></pre></td></tr></table></figure></div>
</li>
<li><p>显示文件的MIME类型</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">file &lt;filename&gt; -i</span><br></pre></td></tr></table></figure></div>

<blockquote>
<p>  <code>MIME</code>（多用途互联网邮件扩展类型），是设定某种扩展名的文件用一种应用程序来打开的方式类型</p>
</blockquote>
</li>
<li><p>设置输出分隔符</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">file &lt;filename&gt; -F <span class="string">&quot;flag&quot;</span></span><br></pre></td></tr></table></figure></div>

<blockquote>
<p>  默认使用<code>:</code>分隔，可以通过<code>-F</code>参数修改分隔符</p>
</blockquote>
</li>
<li><p>查看软链接文件</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">file &lt;filename&gt; -L</span><br></pre></td></tr></table></figure></div></li>
</ul>
<h3 id="stat命令"><a href="#stat命令" class="headerlink" title="stat命令"></a>stat命令</h3><blockquote>
<p>  <code>stat</code>命令显示文件或目录的详细属性信息包括文件系统状态，比<code>ls</code>命令输出的信息更详细</p>
  <div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">stat</span> [args] &lt;filename&gt;</span><br></pre></td></tr></table></figure></div>

<p>  <code>stat</code>命令的可选参数：</p>
<table>
<thead>
<tr>
<th align="center">参数</th>
<th align="center">功能</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>-f</code></td>
<td align="center">不显示文件本身的信息，显示文件所在文件系统的信息</td>
</tr>
<tr>
<td align="center"><code>-L</code></td>
<td align="center">查看软链接文件关联的文件的属性信息</td>
</tr>
<tr>
<td align="center"><code>-c</code></td>
<td align="center">查看文件某个单个的属性信息</td>
</tr>
<tr>
<td align="center"><code>-t</code></td>
<td align="center">简洁模式，只显示摘要信息，不显示属性描述</td>
</tr>
</tbody></table>
</blockquote>
<ul>
<li><p>显示所有属性</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">stat</span> &lt;filename&gt;</span><br></pre></td></tr></table></figure></div>

<p>在输出中我们可以看到很多属性：</p>
<ul>
<li><code>File</code>：文件名</li>
<li><code>Size</code>：文件大小，单位是字节</li>
<li><code>Blocks</code>：文件使用的数据块总数</li>
<li><code>IO Block</code>：IO块大小</li>
<li><code>regular file</code>：文件的实际类型，文件类型不同，该关键字也会变化</li>
<li><code>Device</code>：设备编号</li>
<li><code>Inode</code>：Inode号，操作系统用inode编号来识别不同的文件，找到文件数据所在的block，读出数据</li>
<li><code>Links</code>：硬链接计数</li>
<li><code>Access</code>：文件所有者+所属组用户+其他人对文件的访问权限</li>
<li><code>Uid</code>：文件所有者名字和所有者ID</li>
<li><code>Gid</code>：文件所有组名字和组ID</li>
<li><code>Access Time</code>：文件访问时间，当文件被访问时这个时间更新</li>
<li><code>Modify Time</code>：文件内容修改时间，当文件内容数据被修改时这个时间更新</li>
<li><code>Change Time</code>：文件状态时间，当文件状态被修改时，这个时间更新</li>
<li><code>Birth</code>：文件生成的日期</li>
</ul>
</li>
<li><p>只显示系统信息</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">stat</span> &lt;filename&gt; -f</span><br></pre></td></tr></table></figure></div>
</li>
<li><p>软链接文件</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">stat</span> &lt;filename&gt; -L</span><br></pre></td></tr></table></figure></div>
</li>
<li><p>简洁输出</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">stat</span> &lt;filename&gt; -t</span><br></pre></td></tr></table></figure></div>
</li>
<li><p>单个属性输出</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">stat</span> &lt;filename&gt; -c %<span class="built_in">fmt</span></span><br></pre></td></tr></table></figure></div>

<table>
<thead>
<tr>
<th align="center">格式化字符</th>
<th align="center">功能</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>%a</code></td>
<td align="center">文件的八进制访问权限（#和 0 是输出标准）</td>
</tr>
<tr>
<td align="center"><code>%A</code></td>
<td align="center">人类可读形式的文件访问权限（rwx）</td>
</tr>
<tr>
<td align="center"><code>%b</code></td>
<td align="center">已分配的块数量</td>
</tr>
<tr>
<td align="center"><code>%B</code></td>
<td align="center">报告的每个块的大小 (以字节为单位)</td>
</tr>
<tr>
<td align="center"><code>%C</code></td>
<td align="center">SELinux 安全上下文字符串</td>
</tr>
<tr>
<td align="center"><code>%d</code></td>
<td align="center">设备编号 （十进制）</td>
</tr>
<tr>
<td align="center"><code>%D</code></td>
<td align="center">设备编号 （十六进制）</td>
</tr>
<tr>
<td align="center"><code>%F</code></td>
<td align="center">文件类型</td>
</tr>
<tr>
<td align="center"><code>%g</code></td>
<td align="center">文件所属组组 ID</td>
</tr>
<tr>
<td align="center"><code>%G</code></td>
<td align="center">文件所属组名字</td>
</tr>
<tr>
<td align="center"><code>%h</code></td>
<td align="center">用连接计数</td>
</tr>
<tr>
<td align="center"><code>%i</code></td>
<td align="center">inode 编号</td>
</tr>
<tr>
<td align="center"><code>%m</code></td>
<td align="center">挂载点</td>
</tr>
<tr>
<td align="center"><code>%n</code></td>
<td align="center">文件名</td>
</tr>
<tr>
<td align="center"><code>%N</code></td>
<td align="center">用引号括起来的文件名，并且会显示软连接文件引用的文件路径</td>
</tr>
<tr>
<td align="center"><code>%o</code></td>
<td align="center">最佳 I&#x2F;O 传输大小提示</td>
</tr>
<tr>
<td align="center"><code>%s</code></td>
<td align="center">文件总大小，单位为字节</td>
</tr>
<tr>
<td align="center"><code>%t</code></td>
<td align="center">十六进制的主要设备类型，用于字符 &#x2F; 块设备特殊文件</td>
</tr>
<tr>
<td align="center"><code>%T</code></td>
<td align="center">十六进制的次要设备类型，用于字符 &#x2F; 块设备特殊文件</td>
</tr>
<tr>
<td align="center"><code>%u</code></td>
<td align="center">文件所有者 ID</td>
</tr>
<tr>
<td align="center"><code>%U</code></td>
<td align="center">文件所有者名字</td>
</tr>
<tr>
<td align="center"><code>%w</code></td>
<td align="center">文件生成的日期 ，人类可识别的时间字符串 – 获取不到信息不显示</td>
</tr>
<tr>
<td align="center"><code>%W</code></td>
<td align="center">文件生成的日期 ，自纪元以来的秒数 （参考 % X ）– 获取不到信息不显示</td>
</tr>
<tr>
<td align="center"><code>%x</code></td>
<td align="center">最后访问文件的时间，人类可识别的时间字符串</td>
</tr>
<tr>
<td align="center"><code>%X</code></td>
<td align="center">最后访问文件的时间，自纪元以来的秒数（从 1970.1.1 开始到最后一次文件访问的总秒数）</td>
</tr>
<tr>
<td align="center"><code>%y</code></td>
<td align="center">最后修改文件内容的时间，人类可识别的时间字符串</td>
</tr>
<tr>
<td align="center"><code>%Y</code></td>
<td align="center">最后修改文件内容的时间，自纪元以来的秒数（参考 % X ）</td>
</tr>
<tr>
<td align="center"><code>%z</code></td>
<td align="center">最后修改文件状态的时间，人类可识别的时间字符串</td>
</tr>
<tr>
<td align="center"><code>%Z</code></td>
<td align="center">最后修改文件状态的时间，自纪元以来的秒数（参考 % X ）</td>
</tr>
</tbody></table>
</li>
</ul>
<h3 id="stat-lstat函数"><a href="#stat-lstat函数" class="headerlink" title="stat&#x2F;lstat函数"></a>stat&#x2F;lstat函数</h3><p><code>stat/lstat</code>函数的功能和<code>stat</code>命令的功能是一样的，只不过应用场景不同</p>
<ul>
<li><code>lstat()</code>：得到的是软链接文件本身的属性信息</li>
<li><code>stat()</code>：得到的是软链接文件关联的文件的属性信息</li>
</ul>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">stat</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname, <span class="keyword">struct</span> stat *buf)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">lstat</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname, <span class="keyword">struct</span> stat *buf)</span>;</span><br></pre></td></tr></table></figure></div>

<ul>
<li>参数<ul>
<li><code>pathname</code>：文件名，要获取这个文件的属性信息</li>
<li><code>buf</code>：传出参数，文件的信息被写入到了这块内存中</li>
</ul>
</li>
<li>返回值：函数调用成功返回0，调用失败返回-1</li>
</ul>
<h4 id="获取文件大小"><a href="#获取文件大小" class="headerlink" title="获取文件大小"></a>获取文件大小</h4><div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 1. 定义结构体, 存储文件信息</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">stat</span> <span class="title">myst</span>;</span></span><br><span class="line">    <span class="comment">// 2. 获取文件属性 english.txt</span></span><br><span class="line">    <span class="type">int</span> ret = stat(<span class="string">&quot;./english.txt&quot;</span>, &amp;myst);</span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;stat&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;文件大小: %d\n&quot;</span>, (<span class="type">int</span>)myst.st_size);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h4 id="获取文件类型"><a href="#获取文件类型" class="headerlink" title="获取文件类型"></a>获取文件类型</h4><blockquote>
<p>  文件的类型信息存储在<code>struct stat</code>结构体中的<code>st_mode</code>成员中，它是一个<code>mode_t</code>类型（16位的整数）</p>
</blockquote>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">S_ISREG(m)  is it a regular file?  </span><br><span class="line">	- 普通文件</span><br><span class="line">S_ISDIR(m)  directory?</span><br><span class="line">	- 目录</span><br><span class="line">S_ISCHR(m)  character device?</span><br><span class="line">	- 字符设备</span><br><span class="line">S_ISBLK(m)  block device?</span><br><span class="line">	- 块设备</span><br><span class="line">S_ISFIFO(m) FIFO (named pipe)?</span><br><span class="line">	- 管道</span><br><span class="line">S_ISLNK(m)  symbolic link?  (Not in POSIX<span class="number">.1</span><span class="number">-1996.</span>)</span><br><span class="line">	- 软连接</span><br><span class="line">S_ISSOCK(m) socket?  (Not in POSIX<span class="number">.1</span><span class="number">-1996.</span>)</span><br><span class="line">    - 本地套接字文件</span><br></pre></td></tr></table></figure></div>

<h4 id="获取文件权限"><a href="#获取文件权限" class="headerlink" title="获取文件权限"></a>获取文件权限</h4><blockquote>
<p>  用户对文件的操作权限也存储在<code>struct stat</code>结构体<code>st_mode</code>成员中</p>
  <div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">○ <span class="number">0</span><span class="number">-2</span> bit -- 其他人权限</span><br><span class="line">    - S_IROTH    <span class="number">00004</span>  读权限   <span class="number">100</span></span><br><span class="line">    - S_IWOTH    <span class="number">00002</span>  写权限   <span class="number">010</span></span><br><span class="line">    - S_IXOTH    <span class="number">00001</span>  执行权限  <span class="number">001</span></span><br><span class="line">    - S_IRWXO    <span class="number">00007</span>  掩码, 过滤 st_mode中除其他人权限以外的信息</span><br><span class="line">○ <span class="number">3</span><span class="number">-5</span> bit -- 所属组权限</span><br><span class="line">    - S_IRGRP    <span class="number">00040</span>  读权限</span><br><span class="line">    - S_IWGRP    <span class="number">00020</span>  写权限</span><br><span class="line">    - S_IXGRP    <span class="number">00010</span>  执行权限</span><br><span class="line">    - S_IRWXG    <span class="number">00070</span>  掩码, 过滤 st_mode中除所属组权限以外的信息</span><br><span class="line">○ <span class="number">6</span><span class="number">-8</span> bit -- 文件所有者权限</span><br><span class="line">    - S_IRUSR    <span class="number">00400</span>    读权限</span><br><span class="line">    - S_IWUSR    <span class="number">00200</span>    写权限</span><br><span class="line">    - S_IXUSR    <span class="number">00100</span>    执行权限</span><br><span class="line">    - S_IRWXU    <span class="number">00700</span>    掩码, 过滤 st_mode中除文件所有者权限以外的信息</span><br><span class="line">○ <span class="number">12</span><span class="number">-15</span> bit -- 文件类型</span><br><span class="line">    - S_IFSOCK   <span class="number">0140000</span> 套接字</span><br><span class="line">    - S_IFLNK    <span class="number">0120000</span> 符号链接（软链接）</span><br><span class="line">    - S_IFREG    <span class="number">0100000</span> 普通文件</span><br><span class="line">    - S_IFBLK    <span class="number">0060000</span> 块设备</span><br><span class="line">    - S_IFDIR    <span class="number">0040000</span> 目录</span><br><span class="line">    - S_IFCHR    <span class="number">0020000</span> 字符设备</span><br><span class="line">    - S_IFIFO    <span class="number">0010000</span> 管道</span><br><span class="line">    - S_IFMT     <span class="number">0170000</span> 掩码,过滤 st_mode中除文件类型以外的信息</span><br></pre></td></tr></table></figure></div>
</blockquote>
<h2 id="文件描述符复制和重定向"><a href="#文件描述符复制和重定向" class="headerlink" title="文件描述符复制和重定向"></a>文件描述符复制和重定向</h2><blockquote>
<p>  在Linux中只要调用<code>open</code>函数就可以给操作的文件分配一个文件描述符，除了使用这种方式Linux系统还<br>  提供了一些其他的API用于文件描述符的分配，相关函数有三个：<code>dup</code> <code>dup2</code> <code>fcntl</code></p>
</blockquote>
<h3 id="dup"><a href="#dup" class="headerlink" title="dup"></a>dup</h3><blockquote>
<p>  <code>dup</code>函数的作用是复制文件描述符，这样就有多个文件描述符可以指向同一个文件</p>
  <div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">dup</span><span class="params">(<span class="type">int</span> oldfd)</span>;</span><br></pre></td></tr></table></figure></div>
<ul>
<li>参数：<code>oldfd</code>是要被复制的文件描述符</li>
<li>返回值：函数调用成功返回被复制出来的文件描述符，调用失败返回-1</li>
</ul>
</blockquote>
<h3 id="dup2"><a href="#dup2" class="headerlink" title="dup2"></a>dup2</h3><blockquote>
<p>  <code>dup2</code>是对<code>dup</code>的一个加强版，基于<code>dup2</code>既可以进行文件描述符的复制，也可以进行文件描述符的重定向。<br>  文件描述符重定向就是改变已经分配的文件描述符关联的磁盘文件</p>
  <div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">dup2</span><span class="params">(<span class="type">int</span> oldfd, <span class="type">int</span> newfd)</span>;</span><br></pre></td></tr></table></figure></div>
<ul>
<li>参数：<code>oldfd</code>和<code>newfd</code>都是文件描述符</li>
<li>返回值：函数调用成功返回新的文件描述符，调用失败返回-1</li>
</ul>
</blockquote>
<p>两个使用场景：</p>
<ul>
<li><p>场景一</p>
<p>假设参数<code>oldfd</code>对应磁盘文件<code>a.txx</code>，<code>newfd</code>对应磁盘文件<code>b.txt</code>。在这种情况下调用<code>dup2</code>函数，是给<br><code>newfd</code>做了重定向，<code>newfd</code>和文件<code>b.txt</code>断开关联，相当于关闭了这个文件，同时<code>newfd</code>指向了磁盘上的<br><code>a.txt</code>文件，最终<code>oldfd newfd</code>都指向了磁盘文件<code>a.txt</code></p>
</li>
<li><p>场景二<br>假设参数<code>oldfd</code>对应磁盘文件<code>a.txt</code>，<code>newfd</code>不对应任何的磁盘文件（<code>newfd</code>必须是一个大于等于0的整数）<br>此时调用<code>dup2</code>函数，这种情况下会进行文件描述符的复制，<code>newfd</code>指向了磁盘上的<code>a.txt</code>文件，最终<code>oldfd</code><br><code>newfd</code>都指向了磁盘文件<code>a.txt</code></p>
</li>
<li><p>场景三<br>假设参数<code>oldfd newfd</code>两个文件描述符对应的是同一个磁盘文件<code>a.txt</code>，在这种情况下调用<code>dup2</code>函数，相当<br>于啥也没发生，不会有任何改变</p>
</li>
</ul>
<h3 id="fcntl"><a href="#fcntl" class="headerlink" title="fcntl"></a>fcntl</h3><blockquote>
<p>  <code>fcntl</code>是一个变参函数，并且是多功能函数，这里只介绍如何通过这个函数实现<code>文件描述符的复制</code>和<code>获取、设置已</code><br>  <code>打开的文件属性</code></p>
  <div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">fcntl</span><span class="params">(<span class="type">int</span> fd, <span class="type">int</span> cmd, ... <span class="comment">/* arg */</span> )</span>;</span><br></pre></td></tr></table></figure></div>
<ul>
<li>参数<ul>
<li><code>fd</code>：要操作的文件描述符</li>
</ul>
</li>
<li><code>cmd</code>：通过该参数控制函数要实现什么功能</li>
<li>返回值：函数调用失败返回-1，调用成功返回正确的值<ul>
<li>参数<code>cmd = F_DUPFD</code>：返回新的被分配的文件描述符</li>
<li>参数<code>cmd = F_GETFL</code>：返回文件的flag属性</li>
</ul>
</li>
</ul>
<p>  <code>fcntl</code>函数的<code>cmd</code>可使用的参数列表：</p>
<table>
<thead>
<tr>
<th align="center">参数cmd的取值</th>
<th align="center">功能描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>F_DUPFD</code></td>
<td align="center">复制一个已经存在的文件描述符</td>
</tr>
<tr>
<td align="center"><code>F_GETFL</code></td>
<td align="center">获取文件的状态标志</td>
</tr>
<tr>
<td align="center"><code>F_SETFL</code></td>
<td align="center">设置文件的状态标志</td>
</tr>
</tbody></table>
<p>  文件的状态标志指的是在使用<code>open</code>函数打开文件的时候指定的<code>flag</code>属性</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">open</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname, <span class="type">int</span> flags)</span>;</span><br></pre></td></tr></table></figure></div>
<table>
<thead>
<tr>
<th align="center">文件状态标志</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>O_RDONLY</code></td>
<td align="center">只读打开</td>
</tr>
<tr>
<td align="center"><code>O_WRONLY</code></td>
<td align="center">只写打开</td>
</tr>
<tr>
<td align="center"><code>O_RDWR</code></td>
<td align="center">读写打开</td>
</tr>
<tr>
<td align="center"><code>O_APPEND</code></td>
<td align="center">追加写</td>
</tr>
<tr>
<td align="center"><code>O_NONBLOCK</code></td>
<td align="center">非阻塞模式</td>
</tr>
<tr>
<td align="center"><code>O_SYNC</code></td>
<td align="center">等待写完成（数据和属性）</td>
</tr>
<tr>
<td align="center"><code>O_ASYNC</code></td>
<td align="center">异步IO</td>
</tr>
<tr>
<td align="center"><code>O_RSTNC</code></td>
<td align="center">同步读写</td>
</tr>
</tbody></table>
</blockquote>
<ul>
<li><p>复制文件描述符</p>
<p>使用<code>fcntl</code>函数进行文件描述符复制，第二个参数<code>cmd</code>需要指定为<code>F_DUPFD</code>（这是个变参函数）</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> newfd = fcntl(fd, F_DUPFD);</span><br></pre></td></tr></table></figure></div>


</li>
<li><p>设置文件状态标志</p>
<p>通过<code>open</code>函数打开文件之后，文件的<code>flag</code>属性就已经被确定下来了，如果想要在打开状态下修改这些属性<br>可以使用<code>fcntl</code>函数实现，但是不是所有的<code>flag</code>属性都能被动态修改，只能修改如下状态标志：<br><code>O_APPEND</code> <code>O_NONBLOCK</code> <code>O_SYNC</code> <code>O_ASYNC</code> <code>O_BSYNC</code></p>
<p>得到已打开的文件的状态标志，需要将cmd设置为<code>F_GETFL</code></p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> flag = fcntl(fd, F_GETFL);</span><br></pre></td></tr></table></figure></div>

<p>设置已打开的文件的状态标志，需要将cmd设置为<code>F_SETFL</code>，新的flag需要通过第三个参数传递给<code>fcntl</code>函数</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 得到文件的flag属性</span></span><br><span class="line"><span class="type">int</span> flag = fcntl(fd, F_GETFL);</span><br><span class="line"><span class="comment">// 添加新的flag 标志</span></span><br><span class="line">flag = flag | O_APPEND;</span><br><span class="line"><span class="comment">// 将更新后的falg设置给文件</span></span><br><span class="line">fcntl(fd, F_SETFL, flag);</span><br></pre></td></tr></table></figure></div></li>
</ul>
<h2 id="目录遍历"><a href="#目录遍历" class="headerlink" title="目录遍历"></a>目录遍历</h2><blockquote>
<p>  Linux的目录是一个树状结构，遍历一棵树最简单的方式就是递归<br>  Linux给我们提供了相关的目录遍历的函数，分别是<code>opendir()</code> <code>readdir()</code> <code>closedir()</code></p>
</blockquote>
<h3 id="目录三剑客"><a href="#目录三剑客" class="headerlink" title="目录三剑客"></a>目录三剑客</h3><h4 id="opendir"><a href="#opendir" class="headerlink" title="opendir"></a>opendir</h4><blockquote>
<p>  在目录操作之前必须通过<code>opendir</code>函数打开这个目录</p>
  <div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;dirent.h&gt;</span></span></span><br><span class="line">DIR *<span class="title function_">opendir</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *name)</span>;</span><br></pre></td></tr></table></figure></div>
<ul>
<li>参数：<code>name</code>要打开的目录的名字</li>
<li>返回值：<code>DIR*</code>结构体类型指针，打开成功返回目录的实例，打开失败返回NULL</li>
</ul>
</blockquote>
<h4 id="readdir"><a href="#readdir" class="headerlink" title="readdir"></a>readdir</h4><blockquote>
<p>  目录打开后，可以通过<code>readdir</code>函数遍历目录中的文件信息</p>
  <div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;dirent.h&gt;</span></span></span><br><span class="line"><span class="keyword">struct</span> dirent *<span class="title function_">readdir</span><span class="params">(DIR *dirp)</span>;</span><br></pre></td></tr></table></figure></div>
<ul>
<li>参数：<code>dirp -&gt; opendir</code>函数的返回值</li>
<li>返回值：函数调用成功返回读到的文件信息，目录结构被读完或者函数调用失败返回NULL</li>
</ul>
<p>函数返回值<code>struct dirent</code>结构体原型：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dirent</span> &#123;</span></span><br><span class="line">    <span class="type">ino_t</span>          d_ino;       <span class="comment">/* 文件对应的inode编号, 定位文件存储在磁盘的那个数据块上 */</span></span><br><span class="line">    <span class="type">off_t</span>          d_off;       <span class="comment">/* 文件在当前目录中的偏移量 */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span> d_reclen;    <span class="comment">/* 文件名字的实际长度 */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span>  d_type;      <span class="comment">/* 文件的类型, linux中有7中文件类型 */</span></span><br><span class="line">    <span class="type">char</span>           d_name[<span class="number">256</span>]; <span class="comment">/* 文件的名字 */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>
<p>关于结构体中的文件类型<code>d_type</code>，可使用的宏值如下：</p>
<ul>
<li><code>DT_BLK</code>：块设备文件</li>
<li><code>DT_CHR</code>：字符设备文件</li>
<li><code>DT_DIR</code>：目录文件</li>
<li><code>DT_FIFO</code>：管道文件</li>
<li><code>DT_LNK</code>：软链接文件</li>
<li><code>DT_REG</code>：普通文件</li>
<li><code>DT_SOCK</code>：本地套接字文件</li>
<li><code>DT_UNKNOWN</code>：无法识别的文件类型</li>
</ul>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 打开目录</span></span><br><span class="line">DIR* dir = opendir(<span class="string">&quot;/home/test&quot;</span>);</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dirent</span>* <span class="title">ptr</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line"><span class="comment">// 遍历目录</span></span><br><span class="line"><span class="keyword">while</span>( (ptr=readdir(dir)) != <span class="literal">NULL</span>) &#123;</span><br><span class="line">    .......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
</blockquote>
<h4 id="closedir"><a href="#closedir" class="headerlink" title="closedir"></a>closedir</h4><blockquote>
<p>  目录操作完毕之后，需要通过<code>closedir</code>关闭通过<code>opendir</code>得到的实例，释放资源</p>
  <div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 关闭目录, 参数是 opendir() 的返回值</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">closedir</span><span class="params">(DIR *dirp)</span>;</span><br></pre></td></tr></table></figure></div>

<ul>
<li>参数：<code>dirp -&gt; opendir</code>函数的返回值</li>
<li>返回值：目录关闭成功返回0，失败返回-1</li>
</ul>
</blockquote>
<h3 id="遍历目录"><a href="#遍历目录" class="headerlink" title="遍历目录"></a>遍历目录</h3><ul>
<li><p>遍历单层目录</p>
<p>如果只遍历单层目录是不需要递归的</p>
</li>
<li><p>遍历多层目录</p>
<p>Linux的目录是树状结构，遍历每层目录的方式都是一样的，也就是说最简单的遍历方式是递归<br>程序的重点是确定递归结束的条件：遍历的文件如果不是目录类型就结束递归</p>
</li>
</ul>
<h3 id="scandir函数"><a href="#scandir函数" class="headerlink" title="scandir函数"></a>scandir函数</h3><p>除了使用上面介绍的目录三剑客遍历目录，也可以使用<code>scandir</code>函数进行目录的遍历（只遍历指定目录，不进<br>入到子目录中进行递归遍历），它的参数并不简单，涉及到三级指针和回调函数的使用</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 头文件</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;dirent.h&gt;</span> </span></span><br><span class="line"><span class="type">int</span> <span class="title function_">scandir</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *dirp, <span class="keyword">struct</span> dirent ***namelist,</span></span><br><span class="line"><span class="params">              <span class="type">int</span> (*filter)(<span class="type">const</span> <span class="keyword">struct</span> dirent *),</span></span><br><span class="line"><span class="params">              <span class="type">int</span> (*compar)(<span class="type">const</span> <span class="keyword">struct</span> dirent **, <span class="type">const</span> <span class="keyword">struct</span> dirent **))</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">alphasort</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> dirent **a, <span class="type">const</span> <span class="keyword">struct</span> dirent **b)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">versionsort</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> dirent **a, <span class="type">const</span> <span class="keyword">struct</span> dirent **b)</span>;</span><br></pre></td></tr></table></figure></div>

<ul>
<li><p>参数</p>
<ul>
<li><p><code>dirp</code>：需要遍历的目录的名字</p>
</li>
<li><p><code>namelist</code>：三级指针，传出参数，需要在指向的地址中存储遍历目录得到的所有文件的信息</p>
<p><code>在函数内部会给出这个指针指向的地址分配内存，要注意在程序中释放内存</code></p>
</li>
<li><p><code>filter</code>：函数指针，指针指向的函数就是回调函数，需要在自定义函数中指定</p>
<ul>
<li>如果不对目录中的文件进行过滤，该函数的指针指定为NULL即可</li>
<li>如果自己指定过滤函数，满足条件要返回1，否则返回0</li>
</ul>
</li>
<li><p><code>compar</code>：函数指针，对过滤得到的文件进行排序，可以使用提供的两种排序方式</p>
<ul>
<li><code>alphasort</code>：根据文件名进行排序</li>
<li><code>versionsort</code>：根据版本进行排序</li>
</ul>
</li>
</ul>
</li>
<li><p>返回值：函数执行成功返回找到的匹配成功的文件的个数，如果失败返回-1</p>
</li>
</ul>
<h4 id="文件过滤"><a href="#文件过滤" class="headerlink" title="文件过滤"></a>文件过滤</h4><p><code>scandir()</code>可以让使用者们自定义文件的过滤方式，然后将过滤函数的地址传递给<code>scandir</code>的第三个参数</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 函数的参数就是遍历的目录中的子文件对应的结构体</span></span><br><span class="line"><span class="type">int</span> (*filter)(<span class="type">const</span> <span class="keyword">struct</span> dirent *);</span><br></pre></td></tr></table></figure></div>

<blockquote>
<p>  基于这个函数指针定义的函数就可以称之为回调函数，这个函数不是由程序员调用，而是通过<code>scandir</code>调用，因此<br>  这个函数的实参也是由<code>scandir</code>函数提供的，作为回调函数的编写人员，只需要明白这个参数的含义是什么</p>
<blockquote>
<p>  判断目录中某一个文件是否为Mp3格式</p>
</blockquote>
  <div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">isMp3</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> dirent *ptr)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(ptr-&gt;d_type == DT_REG) &#123;</span><br><span class="line">        <span class="type">char</span>* p = <span class="built_in">strstr</span>(ptr-&gt;d_name, <span class="string">&quot;.mp3&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span>(p != <span class="literal">NULL</span> &amp;&amp; *(p+<span class="number">4</span>) == <span class="string">&#x27;\0&#x27;</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
</blockquote>
<h4 id="遍历目录-1"><a href="#遍历目录-1" class="headerlink" title="遍历目录"></a>遍历目录</h4><blockquote>
<p>  了解了<code>scandir()</code>函数的使用之后，下面这个程序是搜索指定目录下<code>mp3</code>格式文件个数和文件名</p>
</blockquote>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;dirent.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 文件过滤函数</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">isMp3</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> dirent *ptr)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(ptr-&gt;d_type == DT_REG) &#123;</span><br><span class="line">        <span class="type">char</span>* p = <span class="built_in">strstr</span>(ptr-&gt;d_name, <span class="string">&quot;.mp3&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span>(p != <span class="literal">NULL</span> &amp;&amp; *(p+<span class="number">4</span>) == <span class="string">&#x27;\0&#x27;</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(argc &lt; <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;./a.out path\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dirent</span> **<span class="title">namelist</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="type">int</span> num = scandir(argv[<span class="number">1</span>], &amp;namelist, isMp3, alphasort);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;num; ++i) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;file %d: %s\n&quot;</span>, i, namelist[i]-&gt;d_name);</span><br><span class="line">        <span class="built_in">free</span>(namelist[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">free</span>(namelist);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<blockquote>
<p>  <code>scandir()</code>的第二个参数，传递的是一个二级指针的地址</p>
</blockquote>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dirent</span> **<span class="title">namelist</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line"><span class="type">int</span> num = scandir(argv[<span class="number">1</span>], &amp;namelist, isMp3, alphasort);</span><br></pre></td></tr></table></figure></div>

<p>这个<code>struct dirent **namelist</code>指向的是一个指针数组<code>struct dirent *namelist[]</code></p>
<ul>
<li><p>数组元素的个数就是遍历的目录中的个数文件</p>
</li>
<li><p>数组的每个元素都是指针类型：<code>struct dirent *</code>，指针指向的地址是有<code>scandir()</code>函数分配</p>
<p>使用完毕之后释放内存</p>
</li>
</ul>
<h2 id="进程控制"><a href="#进程控制" class="headerlink" title="进程控制"></a>进程控制</h2><h3 id="进程概述"><a href="#进程概述" class="headerlink" title="进程概述"></a>进程概述</h3><p>从严格意义上讲，程序和进程是两个不同的概念，他们的状态，占用的系统资源都是不同的</p>
<ul>
<li>程序：就是磁盘上的可执行文件，并且只占用磁盘上的空间，是一个静态的概念</li>
<li>进程：被执行之后的程序叫做进程，不占用磁盘空间，需要消耗系统的<code>内存 CPU 资源</code>，每个运行的<br>进程的都对应一个属于自己的虚拟地址空间，这是一个动态的概念</li>
</ul>
<h4 id="并行和并发"><a href="#并行和并发" class="headerlink" title="并行和并发"></a>并行和并发</h4><ul>
<li><p>CPU时间片</p>
<p>CPU在某个时间点只能处理一个任务，但是操作系统都支持多任务的，CPU会给每个进程分配一个时间段，进程<br>得到这个时间片之后才可以运行，使各个程序从表面上看是同时进行的。如果在时间片结束时进程还在运行，CPU<br>的使用权将被回收，该进程将会被中断挂起等待下一个时间片。如果进程在时间片结束前阻塞或结束，则CPU当即<br>进行切换，这样就可以避免CPU资源的浪费</p>
<p>因此，计算机中启动的多个程序，从宏观上看是同时运行的，从微观上看由于CPU一次只能处理一个进程，所以<br>它们是轮流执行的，只不过切换速度太快，我们感觉不到罢了，因此CPU的核数越多计算机的处理效率越高</p>
</li>
<li><p>并行和并发</p>
<p>这两个概念都可以笼统的解释为：多个进程同时进行，但是它们两个的同时并不是同一个概念</p>
<blockquote>
<p>  并发</p>
</blockquote>
<ul>
<li>并发的同时运行是一个假象，CPU在某一个时间点只能为某一个个体来服务，因此不可能同时处理多任务，只<br>是通过计算机的CPU快速的时间片切换实现的</li>
<li>并发是针对某一个硬件资源而言的，在某个时间段之内处理的任务的总量，量越大效率越高</li>
</ul>
<blockquote>
<p>  并行</p>
</blockquote>
<ul>
<li>并行的多进程同时运行是真实存在的，可以在同一时刻同时运行多个进程</li>
<li>并行需要依赖多个硬件资源，单个是无法实现的</li>
</ul>
</li>
</ul>
<h4 id="PCB"><a href="#PCB" class="headerlink" title="PCB"></a>PCB</h4><blockquote>
<p>  <code>PCB</code>进程控制块，Linux内核的进程控制块本质上是一个叫做<code>stack_struct</code>的结构体，这个结构体中记录了进程运行相关的一些信息</p>
</blockquote>
<ul>
<li><p>进程id：每一个进程都有一个唯一的进程ID，类型为<code>pid_t</code>，本质是一个整形数</p>
</li>
<li><p>进程的状态：进程有不同的状态，状态是一直在变化的，有就绪、运行、挂起、停止等状态</p>
</li>
<li><p>进程对应的虚拟地址空间的信息</p>
</li>
<li><p>描述控制终端的信息，进程在哪个终端启动默认就和哪个终端绑定</p>
</li>
<li><p>当前工作目录：默认情况下，启动进程的目录就是当前的工作目录</p>
</li>
<li><p><code>umask</code>掩码：在创建新文件时，通过这个掩码屏蔽某些用于文件的操作权限</p>
</li>
<li><p>文件描述符表：每个被分配的文件描述符都对应一个已经打开的磁盘文件</p>
</li>
<li><p>和信号相关的信息：在Linux中调用函数、键盘快捷键、执行shell命令等操作都会产生信号</p>
<p>阻塞信号集：记录当前进程中阻塞哪些已产生的信号，使其不能被处理</p>
</li>
<li><p>未决信号集：记录在当前进程中产生的哪些信号还没有被处理掉</p>
</li>
<li><p>用户ID和组ID：当前进程属于哪个用户，属于哪个用户组</p>
</li>
<li><p>会话（Session）和进程组：多个进程的集合叫做进程组，多个进程组的集合叫会话</p>
</li>
<li><p>进程可以使用的资源上限：可以使用shell命令<code>ulimit -a</code>查看详细信息</p>
</li>
</ul>
<h4 id="进程状态"><a href="#进程状态" class="headerlink" title="进程状态"></a>进程状态</h4><p>进程一共有五种状态分别为：<code>创建态</code>、<code>就绪态</code>、<code>运行态</code>、<code>阻塞态（挂起态）</code>、<code>退出态（终止态）</code><br>其中<code>创建态</code>和<code>退出态</code>持续的时间是非常短的，我们主要是需要将<code>就绪态 运行态 挂起态</code>三者之间的<br>状态切换搞明白</p>
<ul>
<li><p>就绪态：准备就绪，只差CPU资源</p>
<ul>
<li>进程被创建出来，有运行的资格但是还没有运行，需要抢CPU时间片</li>
<li>得到CPU时间片，进程开始运行，从就绪状态转换为运行态</li>
<li>进程的CPU时间片用完了，再次失去CPU，从运行态转换为就绪态</li>
</ul>
</li>
<li><p>运行态：获取到CPU资源的进程，进程只有在这种状态下才能运行</p>
<ul>
<li>运行态不会一直持续，进程的CPU时间片用完之后，再次失去CPU，从运行态装换为就绪态</li>
<li>只要进程还没退出，就会在就绪态和运行态之间不停的切换</li>
</ul>
</li>
<li><p>阻塞态：进程被强制放弃CPU，并且没有抢夺CPU时间片的资格</p>
<ul>
<li>在程序中调用了某些函数（sleep），进程又运行态转换为阻塞态（挂起来）</li>
<li>当某些条件被满足（sleep结束），进程的阻塞状态也就被解除了，进程从阻塞态转换为就绪态</li>
</ul>
</li>
<li><p>退出态：进程被销毁，占用的系统资源被释放了</p>
<ul>
<li>任何状态的进程都可以直接转换为退出态</li>
</ul>
</li>
</ul>
<h4 id="进程命令"><a href="#进程命令" class="headerlink" title="进程命令"></a>进程命令</h4><p>在研究如何创建进程之前，先来看一下如何在终端中通过命令完成进程相关的操作</p>
<ul>
<li><p>查看进程</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ps aux</span><br><span class="line"><span class="comment"># -a 查看所有终端的信息</span></span><br><span class="line"><span class="comment"># -u 查看用户相关的信息</span></span><br><span class="line"><span class="comment"># -x 显示和终端无关的进程信息</span></span><br></pre></td></tr></table></figure></div>
</li>
<li><p>杀死进程</p>
<p><code>kill</code>命令可以发送信号到对应的进程，进程接收到某些信号之后默认的处理动作就是退出进程<br>如果要给进程发送信号，可以先查看一下Linux给我们提供了哪些标准信号</p>
<blockquote>
<p>  查看Linux中的标准信号</p>
</blockquote>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">kill</span> -l</span><br></pre></td></tr></table></figure></div>

<blockquote>
<p>  9号信号（SIGKILL）的行为是无条件杀死进程，想要杀死哪个进程就可以把这个信号发送给这个进程</p>
</blockquote>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">kill</span> -9 &lt;pid&gt;</span><br><span class="line"><span class="built_in">kill</span> -SIGKILL &lt;pid&gt;</span><br></pre></td></tr></table></figure></div></li>
</ul>
<h3 id="进程创建"><a href="#进程创建" class="headerlink" title="进程创建"></a>进程创建</h3><h4 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h4><blockquote>
<p>  Linux中进程ID为<code>pid_t</code>类型，其本质是一个正整数，通过上边的<code>ps aux</code>命令已经得到了验证。PID为1<br>  的进程是Linux系统中创建的第一个进程</p>
</blockquote>
<ul>
<li><p>获取当前进程的进程ID（PID）</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">pid_t</span> <span class="title function_">getpid</span><span class="params">(<span class="type">void</span>)</span>;</span><br></pre></td></tr></table></figure></div>
</li>
<li><p>获取当前进程的父进程ID（PPID）</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">pid_t</span> <span class="title function_">getppid</span><span class="params">(<span class="type">void</span>)</span>;</span><br></pre></td></tr></table></figure></div>
</li>
<li><p>创建一个新的进程</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">pid_t</span> <span class="title function_">fork</span><span class="params">(<span class="type">void</span>)</span>;</span><br></pre></td></tr></table></figure></div></li>
</ul>
<h4 id="fork"><a href="#fork" class="headerlink" title="fork( )"></a>fork( )</h4><div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">pid_t</span> <span class="title function_">fork</span><span class="params">(<span class="type">void</span>)</span>;</span><br></pre></td></tr></table></figure></div>

<p>启动磁盘上的应用程序，得到一个进程，如果在这个启动的进程中调用<code>fork()</code>函数，就会得到一个新的进程<br>我们习惯将其称之为子进程。前面说过每个进程都对应一个属于自己的虚拟空间，子进程的地址空间是基于父<br>进程的地址空间拷贝出来的，虽然是拷贝但是两个地址空间中存储的信息不可能是完全相同的</p>
<ul>
<li><p>相同点</p>
<p>拷贝完成之后，两个地址空间中的用户区数据是相同的。用户区数据主要数据包括：</p>
<ul>
<li>代码区：默认情况下父子进程地址空间中的源代码始终相同</li>
<li>全局数据区：父进程中的全局变量和变量值全部被拷贝一份放到了子进程地址空间中</li>
<li>堆区：父进程中的堆变量和变量值全部被拷贝一份放到了子进程地址空间中</li>
<li>动态库加载区（内存映射区）：父进程中数据信息被拷贝一份放到了子进程地址空间中</li>
<li>栈区：父进程中的栈区变量和变量值全部被拷贝一份放到了子进程地址空间中</li>
<li>环境变量：默认情况下，父子进程地址空间中的环境变量始终相同</li>
<li>文件描述符表：父进程中被分配的文件描述符都会拷贝到子进程中，在子进程中可以使用它们打开对应的文件</li>
</ul>
</li>
<li><p>区别</p>
<ul>
<li><p>父子进程各自的虚拟地址空间是相互独立的，不会互相干扰和影响</p>
</li>
<li><p>父子进程地址空间中代码区代码虽然相同，但是父子进程执行的代码逻辑可能是不同的</p>
</li>
<li><p>由于父子进程可能执行不同的代码逻辑，因此地址空间拷贝完后之后，<code>全局数据 栈区 堆区 动态库加载区</code><br>数据会各自发生变化，由于地址空间是相互独立的，因此不会互相覆盖数据</p>
</li>
<li><p>由于每个进程都有自己的进程ID，因此内核区域存储的父子进程ID是不同的</p>
</li>
<li><p>进程启动之后进入<code>就绪态</code>，运行需要争抢CPU时间片而且可能执行不同的业务逻辑，所以父子进程的状态<br>可能是不同的</p>
</li>
<li><p><code>fork()</code>调用成功后，会返回两个值，父子进程的返回值是不同的</p>
<ul>
<li><p>该函数调用成功后，从一个虚拟地址空间变成了两个虚拟地址空间，每个地址空间中都会将<code>fork()</code><br>的返回值记录下来，这就是为什么会得到两个返回值的原因</p>
</li>
<li><p>父进程的虚拟地址空间中将返回值标记为一个大于0的数（记录的是子进程的进程ID）</p>
</li>
<li><p>子进程的虚拟地址空间中将该返回值标记0</p>
</li>
<li><p>在程序中需要通过<code>fork()</code>的返回值来判断当前进程是子进程还是父进程</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">pid_t</span> pid = fork();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;当前进程fork()的返回值: %d\n&quot;</span>, pid);</span><br><span class="line">    <span class="keyword">if</span>(pid &gt; <span class="number">0</span>)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;我是父进程, pid = %d\n&quot;</span>, getpid());</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(pid == <span class="number">0</span>)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;我是子进程, pid = %d, 我爹是: %d\n&quot;</span>, getpid(), getppid());</span><br><span class="line">    <span class="keyword">else</span> <span class="comment">// pid == -1</span></span><br><span class="line">        <span class="literal">NULL</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="父子进程"><a href="#父子进程" class="headerlink" title="父子进程"></a>父子进程</h3><h3 id="进程执行位置"><a href="#进程执行位置" class="headerlink" title="进程执行位置"></a>进程执行位置</h3><p>在父进程中成功创建子进程，子进程就拥有父进程代码区的所有代码，那么子进程中的代码是在什么位置开始运行呢？<br>父进程肯定从<code>main()</code>开始执行，子进程是在父进程中调用<code>fork()</code>之后被创建，子进程就从<code>fork()</code>之后开始向下执行代码</p>
<blockquote>
<p>  程序对 <code>fork()</code>的返回值做了判断，就可以控制父子进程的行为，如果没有做任何判断这个代码块父子进程都可以执行<br>  在编写多进程程序时，一定要将代码想象成多份进行分析，因为直观上看代码就一份，但实际上数据都是多份，并且多<br>  份数据中变量名都相同，但是他们的值却不一定相同</p>
</blockquote>
<h3 id="循环创建子进程"><a href="#循环创建子进程" class="headerlink" title="循环创建子进程"></a>循环创建子进程</h3><blockquote>
<p>  在一个父进程中循环创建三个子进程，打印每个进程的ID</p>
</blockquote>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">pid_t</span> pid;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">3</span>; ++i) &#123;</span><br><span class="line">        pid = fork();</span><br><span class="line">        <span class="keyword">if</span>(pid == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;当前进程pid: %d\n&quot;</span>, getpid());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="进程数数"><a href="#进程数数" class="headerlink" title="进程数数"></a>进程数数</h3><p>当父进程创建一个子进程，那么父子进程之间可以通过全局变量互动，实现交替数数的功能吗</p>
<blockquote>
<p>  不可行的，要想实现进程间通信需要使用：<code>管道 共享内存 本地套接字 内存映射区 消息队列</code></p>
</blockquote>
<h3 id="execl和execlp函数"><a href="#execl和execlp函数" class="headerlink" title="execl和execlp函数"></a>execl和execlp函数</h3><blockquote>
<p>  需要通过现在运行的进程启动磁盘上的另一个可执行程序，也就是通过一个进程启动另一个进程<br>  使用<code>exec族函数</code></p>
  <div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="type">char</span> **environ;</span><br><span class="line"><span class="type">int</span> <span class="title function_">execl</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *path, <span class="type">const</span> <span class="type">char</span> *arg, ...</span></span><br><span class="line"><span class="params">         <span class="comment">/* (char  *) NULL */</span>)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">execlp</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *file, <span class="type">const</span> <span class="type">char</span> *arg, ...</span></span><br><span class="line"><span class="params">           <span class="comment">/* (char  *) NULL */</span>)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">execle</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *path, <span class="type">const</span> <span class="type">char</span> *arg, ...</span></span><br><span class="line"><span class="params">           <span class="comment">/*, (char *) NULL, char * const envp[] */</span>)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">execv</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *path, <span class="type">char</span> *<span class="type">const</span> argv[])</span>;</span><br><span class="line"> <span class="type">int</span> <span class="title function_">execvp</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *file, <span class="type">char</span> *<span class="type">const</span> argv[])</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">execvpe</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *file, <span class="type">char</span> *<span class="type">const</span> argv[],</span></span><br><span class="line"><span class="params">           <span class="type">char</span> *<span class="type">const</span> envp[])</span>;</span><br></pre></td></tr></table></figure></div>
<p>  这些函数执行成功后不会返回，调用进程的实体，包括<code>代码段 数据段 堆栈</code>等都已经被新的内容取代，只<br>留下进程ID等一些表面上的信息仍保持原样，只有调用失败了才会返回一个-1，从原程序的调用点接着往下执行</p>
<blockquote>
<p>  <code>exec族</code>函数并没有创建新进程的能力，只是让启动的新进程到自己的虚拟地址空间去，并挖空了自己的地址<br>  空间用户区，把新启动的进程数据填充进去</p>
</blockquote>
<p>  <code>exec族</code>函数中最常用的两个<code>execl() execlp()</code>，这两个函数是对其他四个函数做了进一步的封装</p>
</blockquote>
<h4 id="execl"><a href="#execl" class="headerlink" title="execl( )"></a>execl( )</h4><p>该函数可用于执行任意一个可执行程序，函数需要通过指定的文件路径才能找到这个可执行程序</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">execl</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *path, <span class="type">const</span> <span class="type">char</span> *arg, ...)</span>;</span><br></pre></td></tr></table></figure></div>

<ul>
<li>参数<ul>
<li><code>path</code>：启动的可执行程序的路径，推荐使用绝对路径</li>
<li><code>arg</code>：<code>ps aux</code>查看进程的时候，启动的进程的名字，可以随意指定，一般和要启动的可执行程序相同</li>
<li><code>...</code>：要执行的命令需要的参数，可以写多个，最后以NULL结尾，表示参数完了</li>
</ul>
</li>
<li>返回值：如果这个函数执行成功，没有返回值，如果执行失败返回-1</li>
</ul>
<h4 id="execlp"><a href="#execlp" class="headerlink" title="execlp( )"></a>execlp( )</h4><p>该函数常用于执行已经设置了环境变量的可执行程序，函数中的<code>p</code>就是<code>path</code>，也是说这个函数会自动搜索系统<br>的环境变量<code>PATH</code>，因此使用这个函数执行可执行程序不需要指定路径，只需要指定出名字即可</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">execlp</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *file, <span class="type">const</span> <span class="type">char</span> *arg, ...)</span>;</span><br></pre></td></tr></table></figure></div>

<ul>
<li>参数<ul>
<li><code>file</code>：可执行程序的名字<ul>
<li>在环境变量PATH中，可执行程序可以不加路径</li>
<li>没有在环境变量中，可执行程序需要指定绝对路径</li>
</ul>
</li>
<li><code>arg</code>：<code>ps aux</code>查看进程的时候，启动的进程的名字，可以随意指定，一般和要启动的可执行程序名相同</li>
<li><code>...</code>：要执行的命令的参数，可以写多个，最后以NULL结尾，表示参数指定完了</li>
</ul>
</li>
<li>返回值：如果函数执行成功，没有返回值，如果执行失败，返回-1</li>
</ul>
<h4 id="函数的使用"><a href="#函数的使用" class="headerlink" title="函数的使用"></a>函数的使用</h4><p>关于<code>exec族</code>函数，我们一般不会在进程中直接调用，如果直接调用，这个进程的代码区代码被替换就不能<br>按照原来的流程工作了。我们一般在调用这些函数的时候都会创建一个子进程，在子进程中调用<code>exec族</code>函数<br>子进程的用户区数据被替换掉开始执行新的程序中的代码逻辑，但是父进程不受任何影响仍然可以继续正常工作</p>
<h3 id="进程控制-1"><a href="#进程控制-1" class="headerlink" title="进程控制"></a>进程控制</h3><blockquote>
<p>  进程控制主要是指<code>进程的退出 进程的回收</code>和进程的特殊状态<code>孤儿进程</code>和<code>僵尸进程</code></p>
</blockquote>
<h4 id="结束进程"><a href="#结束进程" class="headerlink" title="结束进程"></a>结束进程</h4><p>如果想要直接退出某个进程可以在程序的任何位置调用<code>exit()或_exit()</code>函数。<br>函数的参数相当于退出码，如果参数值为0程序退出之后的状态码就是0，如果是100退出的状态码就是100</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 标准C库函数</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">exit</span><span class="params">(<span class="type">int</span> status)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Linux的系统函数</span></span><br><span class="line"><span class="comment">// 可以这么理解, 在linux中 exit() 函数 封装了 _exit()</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> _exit(<span class="type">int</span> status);</span><br></pre></td></tr></table></figure></div>

<p>在<code>main()</code>中直接使用<code>return</code>也可以退出进程，加入是在一个普通函数中调用<code>return</code>只能返回到调用者的位置<br>不能退出进程</p>
<h4 id="孤儿进程"><a href="#孤儿进程" class="headerlink" title="孤儿进程"></a>孤儿进程</h4><blockquote>
<p>  在一个启动的进程中创建子进程，如果父进程退出，这时子进程就是孤儿进程</p>
</blockquote>
<blockquote>
<p>  操作系统是十分关爱运行的每一个进程的，当检测到某一个进程变成孤儿进程，这时系统会有一个固定的进程来<br>  领养这个孤儿进程。如果没有桌面终端，这个领养孤儿进程的进程就是<code>init</code>进程（PID&#x3D;1），如果有桌面终端<br>  这个领养孤儿进程的进程就是桌面终端</p>
</blockquote>
<p>子进程退出的时候，进程中的用户区可以自己释放，但是进程内核区的pcb资源自己无法释放，必须要由父进程来释放子进程的pcb资源，孤儿进程被领养后，这件事父进程就可以代劳，避免了资源的浪费</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 创建子进程</span></span><br><span class="line">    <span class="type">pid_t</span> pid = fork();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 父进程</span></span><br><span class="line">    <span class="keyword">if</span>(pid &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;我是父进程, pid=%d\n&quot;</span>, getpid());</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(pid == <span class="number">0</span>) &#123;</span><br><span class="line">        sleep(<span class="number">1</span>);	<span class="comment">// 强迫子进程睡眠1s, 这个期间, 父进程退出, 当前进程变成了孤儿进程</span></span><br><span class="line">        <span class="comment">// 子进程</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;我是子进程, pid=%d, 父进程ID: %d\n&quot;</span>, getpid(), getppid());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h4 id="僵尸进程"><a href="#僵尸进程" class="headerlink" title="僵尸进程"></a>僵尸进程</h4><blockquote>
<p>  在一个启动的进程中创建子进程，这时就有了父子两个进程，父进程正常运行，子进程先与父进程结，子进程<br>  无法释放自己的PCB资源，需要父进程来做这件事，但是父进程不管，这时候子进程就变成了僵尸进程</p>
</blockquote>
<p>不能将僵尸进程看成是一个正常的进程，这个进程已经死亡，用户资源已经被释放了只是还占用着一些内核资源<br>（PCB）。僵尸进程的出现是由于这个已经死亡的进程的父进程不作为造成的</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">pid_t</span> pid;</span><br><span class="line">    <span class="comment">// 创建子进程</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">5</span>; ++i) &#123;</span><br><span class="line">        pid = fork();</span><br><span class="line">        <span class="keyword">if</span>(pid == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 父进程</span></span><br><span class="line">    <span class="keyword">if</span>(pid &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 需要保证父进程一直在运行</span></span><br><span class="line">        <span class="comment">// 一直运行不退出, 并且也做回收, 就会出现僵尸进程</span></span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;我是父进程, pid=%d\n&quot;</span>, getpid());</span><br><span class="line">            sleep(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(pid == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 子进程, 执行这句代码之后, 子进程退出了</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;我是子进程, pid=%d, 父进程ID: %d\n&quot;</span>, getpid(), getppid());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<blockquote>
<p>  上面我们就得到了僵尸进程，消灭僵尸进程的方式是杀死僵尸进程的父进程，这样僵尸进程的资源就被系统回收了<br>  通过<code>kill -9 僵尸进程ID</code>的方式是不能消灭僵尸进程的</p>
</blockquote>
<h3 id="进程回收"><a href="#进程回收" class="headerlink" title="进程回收"></a>进程回收</h3><blockquote>
<p>  为了避免僵尸进程的产生，一般我们会在父进程中进行子进程的资源回收，回收方式有两种：<br>  阻塞方式<code>wait()</code> 非阻塞方式<code>waitpid()</code></p>
</blockquote>
<h4 id="wait"><a href="#wait" class="headerlink" title="wait"></a>wait</h4><p>这是个阻塞函数，如果没有子进程退出，函数会一直阻塞等待，当检测到子进程退出了，该函数阻塞解除回收子进程资源<br>这个函数被调用一次，只能回收一个子进程的资源，如果多个子进程需要资源回收，函数需要被多次调用</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// man 2 wait</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="type">pid_t</span> <span class="title function_">wait</span><span class="params">(<span class="type">int</span> *status)</span>;</span><br></pre></td></tr></table></figure></div>

<ul>
<li><p>参数：传出参数，通过传递出的信息判断回收的进程是怎么退出的，如果不需要该信息可以指定为NULL<br>取出整形变量中的数据需要使用一些宏函数</p>
<ul>
<li><p><code>WIFEXITED(status)</code>：返回1，进程是正常退出的</p>
<p><code>WEXITSTATUS(status)</code>得到进程退出时候的状态码，相当于return后面的数值，或者exit函数的参数</p>
</li>
<li><p><code>WIFSIGNALED(status)</code>：返回1，进程是被信号杀死了</p>
<p><code>WTERMSIG(status)</code>：获得进程是被哪个信号杀死的，会得到信号的编号</p>
</li>
</ul>
</li>
<li><p>返回值</p>
<ul>
<li>成功：返回被回收的子进程的进程ID</li>
<li>失败：-1<ul>
<li>没有子进程资源可以回收了，函数的阻塞会自动解除，返回-1</li>
<li>回收子进程资源的时候出现了异常</li>
</ul>
</li>
</ul>
</li>
</ul>
<blockquote>
<p>  演示通过<code>wait()</code>回收多个子进程资源</p>
</blockquote>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">pid_t</span> pid;</span><br><span class="line">    <span class="comment">// 创建子进程</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">5</span>; ++i) &#123;</span><br><span class="line">        pid = fork();</span><br><span class="line">        <span class="keyword">if</span>(pid == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 父进程</span></span><br><span class="line">    <span class="keyword">if</span>(pid &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 需要保证父进程一直在运行</span></span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">// 回收子进程的资源</span></span><br><span class="line">            <span class="comment">// 子进程由多个, 需要循环回收子进程资源</span></span><br><span class="line">            <span class="type">pid_t</span> ret = wait(<span class="literal">NULL</span>);</span><br><span class="line">            <span class="keyword">if</span>(ret &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;成功回收了子进程资源, 子进程PID: %d\n&quot;</span>, ret);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;回收失败, 或者是已经没有子进程了...\n&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;我是父进程, pid=%d\n&quot;</span>, getpid());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(pid == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 子进程, 执行这句代码之后, 子进程退出了</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;我是子进程, pid=%d, 父进程ID: %d\n&quot;</span>, getpid(), getppid());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h4 id="waitpid"><a href="#waitpid" class="headerlink" title="waitpid"></a>waitpid</h4><blockquote>
<p>  <code>waitpid()</code>可以控制回收子进程资源的方式是阻塞还是非阻塞，另外还可以通过该函数进行精准打击，精确指定回收<br>  某个或者某一类或者是全部子进程资源</p>
</blockquote>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// man 2 waitpid</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="comment">// 这个函数可以设置阻塞, 也可以设置为非阻塞</span></span><br><span class="line"><span class="comment">// 这个函数可以指定回收哪些子进程的资源</span></span><br><span class="line"><span class="type">pid_t</span> <span class="title function_">waitpid</span><span class="params">(<span class="type">pid_t</span> pid, <span class="type">int</span> *status, <span class="type">int</span> options)</span>;</span><br></pre></td></tr></table></figure></div>

<p>参数:</p>
<ul>
<li><p><code>pid</code></p>
<ul>
<li><code>-1</code>：回收所有的子进程资源，和 wait () 是一样的，无差别回收，并不是一次性就可以回收多个，也是需要循环回收的</li>
<li><code>大于0</code>：指定回收某一个进程的资源 ，pid 是要回收的子进程的进程 ID</li>
<li><code>0</code>：回收当前进程组的所有子进程 ID</li>
<li><code>小于 -1</code>：pid 的绝对值代表进程组 ID，表示要回收这个进程组的所有子进程资源</li>
</ul>
</li>
<li><p><code>status</code>： NULL, 和 wait 的参数是一样的</p>
</li>
<li><p><code>options</code>：控制函数是阻塞还是非阻塞</p>
<ul>
<li><code>0</code>： 函数是行为是阻塞的 &#x3D;&#x3D;&gt; 和 wait 一样</li>
<li><code>WNOHANG</code>： 函数是行为是非阻塞的</li>
</ul>
</li>
<li><p>返回值</p>
<ul>
<li><p>如果函数是非阻塞的，并且子进程还在运行，返回 0</p>
</li>
<li><p>成功：得到子进程的进程 ID</p>
</li>
<li><p>失败：-1</p>
<ul>
<li>没有子进程资源可以回收了，函数如果是阻塞的，阻塞会解除，直接返回 - 1</li>
<li>回收子进程资源的时候出现了异常</li>
</ul>
</li>
</ul>
</li>
</ul>
<blockquote>
<p>  演示使用<code>waitpid()</code>阻塞回收多个子进程资源</p>
</blockquote>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 和wait() 行为一样, 阻塞</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">pid_t</span> pid;</span><br><span class="line">    <span class="comment">// 创建子进程</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">5</span>; ++i) &#123;</span><br><span class="line">        pid = fork();</span><br><span class="line">        <span class="keyword">if</span>(pid == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 父进程</span></span><br><span class="line">    <span class="keyword">if</span>(pid &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 需要保证父进程一直在运行</span></span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">// 回收子进程的资源</span></span><br><span class="line">            <span class="comment">// 子进程由多个, 需要循环回收子进程资源</span></span><br><span class="line">            <span class="type">int</span> status;</span><br><span class="line">            <span class="type">pid_t</span> ret = waitpid(<span class="number">-1</span>, &amp;status, <span class="number">0</span>);  <span class="comment">// == wait(NULL);</span></span><br><span class="line">            <span class="keyword">if</span>(ret &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;成功回收了子进程资源, 子进程PID: %d\n&quot;</span>, ret);</span><br><span class="line">                                <span class="comment">// 判断进程是不是正常退出</span></span><br><span class="line">                <span class="keyword">if</span>(WIFEXITED(status))</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;子进程退出时候的状态码: %d\n&quot;</span>, WEXITSTATUS(status));</span><br><span class="line">                <span class="keyword">if</span>(WIFSIGNALED(status))</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;子进程是被这个信号杀死的: %d\n&quot;</span>, WTERMSIG(status));</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;回收失败, 或者是已经没有子进程了...\n&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;我是父进程, pid=%d\n&quot;</span>, getpid());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(pid == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 子进程, 执行这句代码之后, 子进程退出了</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;===我是子进程, pid=%d, 父进程ID: %d\n&quot;</span>, getpid(), getppid());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<blockquote>
<p>  演示通过<code>waitpid()</code>非阻塞回收多个子进程资源</p>
</blockquote>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 非阻塞处理</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">pid_t</span> pid;</span><br><span class="line">    <span class="comment">// 创建子进程</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">5</span>; ++i) &#123;</span><br><span class="line">        pid = fork();</span><br><span class="line">        <span class="keyword">if</span>(pid == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 父进程</span></span><br><span class="line">    <span class="keyword">if</span>(pid &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 需要保证父进程一直在运行</span></span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">// 回收子进程的资源</span></span><br><span class="line">            <span class="comment">// 子进程由多个, 需要循环回收子进程资源</span></span><br><span class="line">            <span class="comment">// 子进程退出了就回收, </span></span><br><span class="line">            <span class="comment">// 没退出就不回收, 返回0</span></span><br><span class="line">            <span class="type">int</span> status;</span><br><span class="line">            <span class="type">pid_t</span> ret = waitpid(<span class="number">-1</span>, &amp;status, WNOHANG);  <span class="comment">// 非阻塞</span></span><br><span class="line">            <span class="keyword">if</span>(ret &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;成功回收了子进程资源, 子进程PID: %d\n&quot;</span>, ret);</span><br><span class="line">                <span class="comment">// 判断进程是不是正常退出</span></span><br><span class="line">                <span class="keyword">if</span>(WIFEXITED(status))</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;子进程退出时候的状态码: %d\n&quot;</span>, WEXITSTATUS(status));</span><br><span class="line">                <span class="keyword">if</span>(WIFSIGNALED(status))</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;子进程是被这个信号杀死的: %d\n&quot;</span>, WTERMSIG(status));</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span>(ret == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;子进程还没有退出, 不做任何处理...\n&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;回收失败, 或者是已经没有子进程了...\n&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;我是父进程, pid=%d\n&quot;</span>, getpid());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(pid == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 子进程, 执行这句代码之后, 子进程退出了</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;===我是子进程, pid=%d, 父进程ID: %d\n&quot;</span>, getpid(), getppid());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>



<h2 id="管道"><a href="#管道" class="headerlink" title="管道"></a>管道</h2><h3 id="管道-1"><a href="#管道-1" class="headerlink" title="管道"></a>管道</h3><blockquote>
<p>  管道是进程间通信（IPC）的一种方式，管道本质其实就是内核中的一块内存（内核缓冲区）<br>  这块缓冲区中的数据存储在一个环形队列中，因为管道在内核里面，因此我们不能直接对其进行任何操作</p>
</blockquote>
<p>管道是通过队列来维护的：</p>
<ul>
<li>管道对应的内核缓冲区大小是固定的，默认为4K（队列能最大能存储4K数据）</li>
<li>管道分为两部分：读端和写端（队列的两端），数据从写端进入管道，从读端流出管道</li>
<li>管道中的数据只能读一次，做一次读操作之后数据也就没有了（读数据相当于出队列）</li>
<li>管道是单工的：数据只能单向流动，数据从写端流向读端</li>
<li>对管道的操作（读，写）默认是阻塞的<ul>
<li>读管道：管道中没有数据，读操作被阻塞，当管道中有数据之后阻塞才能解除</li>
<li>写管道：管道被写满了，写数据的操作被阻塞，当管道变为不满的状态，写阻塞解除</li>
</ul>
</li>
</ul>
<p>管道在内核中，不能直接对其进行操作，我们通过文件IO来操作管道，内核中管道两端分别对应两个文件描述符，通过<br>写端的文件描述符把数据写入到管道中，通过读端的文件描述符将数据从管道中读出来</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 读管道</span></span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">read</span><span class="params">(<span class="type">int</span> fd, <span class="type">void</span> *buf, <span class="type">size_t</span> count)</span>;</span><br><span class="line"><span class="comment">// 写管道的函数</span></span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">write</span><span class="params">(<span class="type">int</span> fd, <span class="type">const</span> <span class="type">void</span> *buf, <span class="type">size_t</span> count)</span>;</span><br></pre></td></tr></table></figure></div>

<blockquote>
<p>  管道是独立于任何进程的，并且充当了两个进程用于数据通信的载体，只要两个进程能够得到同一个管道的入口<br>  和出口（读端和写端的文件描述符），那么它们之间就可以通过管道进行数据的交互</p>
</blockquote>
<h3 id="匿名管道"><a href="#匿名管道" class="headerlink" title="匿名管道"></a>匿名管道</h3><h4 id="创建匿名管道"><a href="#创建匿名管道" class="headerlink" title="创建匿名管道"></a>创建匿名管道</h4><blockquote>
<p>  匿名管道是管道的一种，匿名说明这个管道没有名字，但本质是不变的，就是位于内核中的一块内存，匿名管道<br>  拥有上面介绍的管道的所有特性，但是<code>匿名管道只能实现有血缘关系的进程间通信</code></p>
</blockquote>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="comment">// 创建一个匿名的管道, 得到两个可用的文件描述符</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pipe</span><span class="params">(<span class="type">int</span> pipefd[<span class="number">2</span>])</span>;</span><br></pre></td></tr></table></figure></div>

<ul>
<li>参数：传出参数，需要传递一个整形数组的地址，数组大小为2，也就是说最终会传出两个参数<ul>
<li><code>pipefd[0]</code>：对应管道读端的文件描述符，通过他可以将数据从管道中读出</li>
<li><code>pipefd[1]</code>：对应管道写端的文件描述符，通过它可以将数据写入到管道中</li>
</ul>
</li>
<li>返回值：成功返回0，失败返回-1</li>
</ul>
<h4 id="进程间通信"><a href="#进程间通信" class="headerlink" title="进程间通信"></a>进程间通信</h4><blockquote>
<p>  现考虑使用匿名管道实现下面这个功能</p>
  <div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">需求描述:</span><br><span class="line">   在父进程中创建一个子进程, 父子进程分别执行不同的操作:</span><br><span class="line">     - 子进程: 执行一个shell命令 <span class="string">&quot;ps aux&quot;</span>, 将命令的结果传递给父进程</span><br><span class="line">     - 父进程: 将子进程命令的结果输出到终端</span><br></pre></td></tr></table></figure></div>
</blockquote>
<p>需求分析：</p>
<ul>
<li><p>子进程中执行shell命令相当于启动一个程序，需要使用<code>execl()/execlp()</code></p>
<p><code>execlp(&quot;ps&quot;, &quot;ps&quot;, &quot;aux&quot;, NULL)</code></p>
</li>
<li><p>子进程中执行完shell命令直接就在终端输出结果，使用匿名管道将这些信息传递给父进程</p>
<ul>
<li><p>子进程将数据写入到管道中</p>
</li>
<li><p>将默认输出到终端的数据写入到管道就需要进行输出的重定向，需要使用<code>dup2()</code></p>
<p><code>dup2(fd[1], STDOUT_FILENO)</code></p>
</li>
</ul>
</li>
<li><p>父进程需要读管道，将从管道中读出的数据打印到终端</p>
</li>
<li><p>父进程最后需要释放子进程资源，防止出现僵尸进程</p>
</li>
</ul>
<p>在使用管道进行进程间通信的注意事项：<code>必须保证数据在管道中管道单向流动</code></p>
<ol>
<li>父进程中创建了匿名管道，得到两个分配的文件描述符</li>
<li>父进程创建子进程，父进程的文件描述符被拷贝，在子进程的文件描述符表中也得到了两个被分配的可以使用<br>的文件描述符，那么管道中数据的流动就不是单向的了</li>
<li>为了避免两个进程都读管道（可能其中某个进程由于读不到数据而阻塞），我们可以关闭进程中用不到的那一端<br>的文件描述符，这样数据就只能单向的从一端流向另外一端了（关闭父进程的写端，子进程的读端）</li>
</ol>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 管道的数据是单向流动的:</span></span><br><span class="line"><span class="comment">// 操作管道的是两个进程, 进程A读管道, 需要关闭管道的写端, 进程B写管道, 需要关闭管道的读端</span></span><br><span class="line"><span class="comment">// 如果不做上述的操作, 会对程序的结果造成一些影响, 对管道的操作无法结束</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 1. 创建匿名管道, 得到两个文件描述符</span></span><br><span class="line">    <span class="type">int</span> fd[<span class="number">2</span>];</span><br><span class="line">    <span class="type">int</span> ret = pipe(fd);</span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;pipe&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 2. 创建子进程 -&gt; 能够操作管道的文件描述符被复制到子进程中</span></span><br><span class="line">    <span class="type">pid_t</span> pid = fork();</span><br><span class="line">    <span class="keyword">if</span>(pid == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 关闭读端</span></span><br><span class="line">        close(fd[<span class="number">0</span>]);</span><br><span class="line">        <span class="comment">// 3. 在子进程中执行 execlp(&quot;ps&quot;, &quot;ps&quot;, &quot;aux&quot;, NULL);</span></span><br><span class="line">        <span class="comment">// 在子进程中完成输出的重定向, 原来输出到终端现在要写管道</span></span><br><span class="line">        <span class="comment">// 进程打印数据默认输出到终端, 终端对应的文件描述符: stdout_fileno</span></span><br><span class="line">        <span class="comment">// 标准输出 重定向到 管道的写端</span></span><br><span class="line">        dup2(fd[<span class="number">1</span>], STDOUT_FILENO);</span><br><span class="line">        execlp(<span class="string">&quot;ps&quot;</span>, <span class="string">&quot;ps&quot;</span>, <span class="string">&quot;aux&quot;</span>, <span class="literal">NULL</span>);</span><br><span class="line">        perror(<span class="string">&quot;execlp&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4. 父进程读管道</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(pid &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 关闭管道的写端</span></span><br><span class="line">        close(fd[<span class="number">1</span>]);</span><br><span class="line">        <span class="comment">// 5. 父进程打印读到的数据信息</span></span><br><span class="line">        <span class="type">char</span> buf[<span class="number">4096</span>];</span><br><span class="line">        <span class="comment">// 读管道</span></span><br><span class="line">        <span class="comment">// 如果管道中没有数据, read会阻塞</span></span><br><span class="line">        <span class="comment">// 有数据之后, read解除阻塞, 直接读数据</span></span><br><span class="line">        <span class="comment">// 需要循环读数据, 管道是有容量的, 写满之后就不写了</span></span><br><span class="line">        <span class="comment">// 数据被读走之后, 继续写管道, 那么就需要再继续读数据</span></span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="built_in">memset</span>(buf, <span class="number">0</span>, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">            <span class="type">int</span> len = read(fd[<span class="number">0</span>], buf, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">            <span class="keyword">if</span>(len == <span class="number">0</span>)</span><br><span class="line">                <span class="comment">// 管道的写端关闭了, 如果管道中没有数据, 管道读端不会阻塞</span></span><br><span class="line">                <span class="comment">// 没数据直接返回0, 如果有数据, 将数据读出, 数据读完之后返回0</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%s, len = %d\n&quot;</span>, buf, len);</span><br><span class="line">        &#125;</span><br><span class="line">        close(fd[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 回收子进程资源</span></span><br><span class="line">        wait(<span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>



<h3 id="有名管道"><a href="#有名管道" class="headerlink" title="有名管道"></a>有名管道</h3><h4 id="创建有名管道"><a href="#创建有名管道" class="headerlink" title="创建有名管道"></a>创建有名管道</h4><blockquote>
<p>  有名管道拥有管道的所有特性，之所以称之为有名是因为有名管道在磁盘上有实体文件，文件类型为p，有名管道<br>  文件大小永远为0，因为有名管道也是将数据存储到内存的缓冲区中，打开这个磁盘上的管道文件就可以得到操作<br>  有名管道的文件描述符，通过文件描述符读写管道存储在内核中的数据</p>
<p>  有名管道也可以称为<code>fifo</code>，使用有名管道既可以进行有血缘关系的进程间通信，也可以进行没有血缘关系的进程<br>  间通信。创建有名管道的方式有两个：命令，函数</p>
</blockquote>
<ul>
<li><p>通过命令</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mkfifo</span> 有名管道的名字</span><br></pre></td></tr></table></figure></div>
</li>
<li><p>通过函数</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">mkfifo</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname, <span class="type">mode_t</span> mode)</span>;</span><br></pre></td></tr></table></figure></div>

<ul>
<li>参数<ul>
<li><code>pathname</code>：要创建的有名管道的名字</li>
<li><code>mode</code>：文件的操作权限，和<code>open()</code>的第三个参数一个作用，最终权限：<code>mode &amp; ~umask</code></li>
</ul>
</li>
<li>返回值：创建成功返回0，失败返回-1</li>
</ul>
</li>
</ul>
<h4 id="进程间通信-1"><a href="#进程间通信-1" class="headerlink" title="进程间通信"></a>进程间通信</h4><blockquote>
<p>  不管是有血缘关系还是没有血缘关系，使用有名管道实现进程间通信的方式是相同的，就是在两个进程中分别以读、写<br>  的方式打开磁盘上的管道文件，得到用于读管道、写管道的文件描述符，就可以调用对应的<code>read() write()</code>进行读写</p>
<blockquote>
<p>  <code>有名管道操作需要通过 open () 操作得到读写管道的文件描述符，如果只是读端打开了或者只是写端打开了，进程会阻塞在这里不会向下执行，直到在另一个进程中将管道的对端打开，当前进程的阻塞也就解除了。所以当发现进程阻塞在了 open () 函数上不要感到惊讶</code></p>
</blockquote>
</blockquote>
<ul>
<li><p>写管道的进程</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	1. 创建有名管道文件 </span></span><br><span class="line"><span class="comment">		mkfifo()</span></span><br><span class="line"><span class="comment">	2. 打开有名管道文件, 打开方式是 o_wronly</span></span><br><span class="line"><span class="comment">		int wfd = open(&quot;xx&quot;, O_WRONLY);</span></span><br><span class="line"><span class="comment">	3. 调用write函数写文件 ==&gt; 数据被写入管道中</span></span><br><span class="line"><span class="comment">		write(wfd, data, strlen(data));</span></span><br><span class="line"><span class="comment">	4. 写完之后关闭文件描述符</span></span><br><span class="line"><span class="comment">		close(wfd);</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure></div>

<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 1. 创建有名管道文件</span></span><br><span class="line">    <span class="type">int</span> ret = mkfifo(<span class="string">&quot;./testfifo&quot;</span>, <span class="number">0664</span>);</span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;mkfifo&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;管道文件创建成功...\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 打开管道文件</span></span><br><span class="line">    <span class="comment">// 因为要写管道, 所有打开方式, 应该指定为 O_WRONLY</span></span><br><span class="line">    <span class="comment">// 如果先打开写端, 读端还没有打开, open函数会阻塞, 当读端也打开之后, open解除阻塞</span></span><br><span class="line">    <span class="type">int</span> wfd = open(<span class="string">&quot;./testfifo&quot;</span>, O_WRONLY);</span><br><span class="line">    <span class="keyword">if</span>(wfd == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;open&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;以只写的方式打开文件成功...\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 循环写管道</span></span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(i&lt;<span class="number">100</span>) &#123;</span><br><span class="line">        <span class="type">char</span> buf[<span class="number">1024</span>];</span><br><span class="line">        <span class="built_in">sprintf</span>(buf, <span class="string">&quot;hello, fifo, 我在写管道...%d\n&quot;</span>, i);</span><br><span class="line">        write(wfd, buf, <span class="built_in">strlen</span>(buf));</span><br><span class="line">        i++;</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    close(wfd);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
</li>
<li><p>读管道的进程</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	1. 这两个进程需要操作相同的管道文件</span></span><br><span class="line"><span class="comment">	2. 打开有名管道文件, 打开方式是 o_rdonly</span></span><br><span class="line"><span class="comment">		int rfd = open(&quot;xx&quot;, O_RDONLY);</span></span><br><span class="line"><span class="comment">	3. 调用read函数读文件 ==&gt; 读管道中的数据</span></span><br><span class="line"><span class="comment">		char buf[4096];</span></span><br><span class="line"><span class="comment">		read(rfd, buf, sizeof(buf));</span></span><br><span class="line"><span class="comment">	4. 读完之后关闭文件描述符</span></span><br><span class="line"><span class="comment">		close(rfd);</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure></div>

<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 1. 打开管道文件</span></span><br><span class="line">    <span class="comment">// 因为要read管道, so打开方式, 应该指定为 O_RDONLY</span></span><br><span class="line">    <span class="comment">// 如果只打开了读端, 写端还没有打开, open阻塞, 当写端被打开, 阻塞就解除了</span></span><br><span class="line">    <span class="type">int</span> rfd = open(<span class="string">&quot;./testfifo&quot;</span>, O_RDONLY);</span><br><span class="line">    <span class="keyword">if</span>(rfd == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;open&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;以只读的方式打开文件成功...\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 循环读管道</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="type">char</span> buf[<span class="number">1024</span>];</span><br><span class="line">        <span class="built_in">memset</span>(buf, <span class="number">0</span>, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">        <span class="comment">// 读是阻塞的, 如果管道中没有数据, read自动阻塞</span></span><br><span class="line">        <span class="comment">// 有数据解除阻塞, 继续读数据</span></span><br><span class="line">        <span class="type">int</span> len = read(rfd, buf, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;读出的数据: %s\n&quot;</span>, buf);</span><br><span class="line">        <span class="keyword">if</span>(len == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 写端关闭了, read解除阻塞返回0</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;管道的写端已经关闭, 拜拜...\n&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    close(rfd);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></li>
</ul>
<h3 id="管道的读写行为"><a href="#管道的读写行为" class="headerlink" title="管道的读写行为"></a>管道的读写行为</h3><blockquote>
<p>  不管管道是匿名还是有名，在读写的时候，它们表现出的行为是一致的</p>
</blockquote>
<ul>
<li><p>读管道：需要根据写端的状态进行分析</p>
<ul>
<li><p>写端没有关闭（操作管道写端的文件描述符没有被关闭）</p>
<p>如果管道中没有数据 &#x3D;&#x3D;&gt; 读阻塞，如果管道中被写入了数据，阻塞解除</p>
<p>如果管道中有数据 &#x3D;&#x3D;&gt; 不阻塞，管道中的数据被读完了，继续读管道还会阻塞</p>
</li>
<li><p>写端已经关闭（没有可用的文件描述符可以写管道了）</p>
<p>管道中没有数据 &#x3D;&#x3D;&gt; 读端解除阻塞，read函数返回0</p>
<p>管道中有数据 &#x3D;&#x3D;&gt; read现将数据读出，数据读完之后返回0，不会阻塞</p>
</li>
</ul>
</li>
<li><p>写管道：需要根据读端的状态进行分析</p>
<ul>
<li><p>读端没有关闭</p>
<p>如果管道有存储的空间，一直写数据</p>
<p>如果管道写满了，写操作阻塞，当读端数据读走了，解除阻塞继续写</p>
</li>
<li><p>读端关闭了，管道破裂（异常），进程直接退出</p>
</li>
</ul>
</li>
</ul>
<blockquote>
<p>  管道的两端默认是阻塞的，管道的读写两端的非阻塞操作是相同的，下面将匿名的读端设置为了非阻塞</p>
</blockquote>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通过fcntl 修改就可以, 一般情况下不建议修改</span></span><br><span class="line"><span class="comment">// 管道操作对应两个文件描述符, 分别是管道的读端 和 写端</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 1. 获取读端的文件描述符的flag属性</span></span><br><span class="line"><span class="type">int</span> flag = fcntl(fd[<span class="number">0</span>], F_GETFL);</span><br><span class="line"><span class="comment">// 2. 添加非阻塞属性到 flag中</span></span><br><span class="line">flag |= O_NONBLOCK;</span><br><span class="line"><span class="comment">// 3. 将新的flag属性设置给读端的文件描述符</span></span><br><span class="line">fcntl(fd[<span class="number">0</span>], F_SETFL, flag);</span><br><span class="line"><span class="comment">// 4. 非阻塞读管道</span></span><br><span class="line"><span class="type">char</span> buf[<span class="number">4096</span>];</span><br><span class="line">read(fd[<span class="number">0</span>], buf, <span class="keyword">sizeof</span>(buf));</span><br></pre></td></tr></table></figure></div>



<h2 id="内存映射"><a href="#内存映射" class="headerlink" title="内存映射"></a>内存映射</h2><h3 id="创建内存映射区"><a href="#创建内存映射区" class="headerlink" title="创建内存映射区"></a>创建内存映射区</h3><blockquote>
<p>  如果想要实现进程间通信，可以通过函数创建一块内存映射区，和管道不同的是管道对应的内存空间在内核，而<br>  内存映射区对应的内存空间在进程的用户区（用于加载动态库的那个区域），也就是说<code>进程间通信使用的内存映</code><br>  <code>射区不是一块，而是在每个进程内部都有一块</code></p>
<p>  由于每个进程的地址空间是独立的，各个进程之间也不能直接访问对方的内存映射区，需要通信的进程需要将各自<br>  的内存映射区和同一个磁盘文件进行映射，这样进程之间就可以通过磁盘文件这个唯一的桥梁完成数据的交互了</p>
</blockquote>
<p>使用内存映射区既可以用于有血缘关系进程的进程间通信也可以用于没有血缘关系进程的进程间通信</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> *<span class="title function_">mmap</span><span class="params">(<span class="type">void</span> *addr, <span class="type">size_t</span> length, <span class="type">int</span> prot, <span class="type">int</span> flags, <span class="type">int</span> fd, <span class="type">off_t</span> offset)</span>;</span><br></pre></td></tr></table></figure></div>

<ul>
<li>参数<ul>
<li><code>addr</code>：从动态库加载区的什么位置开始创建内存映射区，一般指定为NULL，委托内核分配</li>
<li><code>length</code>：创建的内存映射区的大小（字节），实际上这个大小是按照4K的整数倍区分配的</li>
<li><code>prot</code>：对内存映射区的操作权限<ul>
<li><code>PROT_READ</code>：读内存映射区</li>
<li><code>PORT_WRITE</code>：写内存映射区</li>
<li>如果要对映射区有读写权限：<code>PORT_RAED | PORT_WRITE</code></li>
</ul>
</li>
<li><code>flags</code><ul>
<li><code>MAP_SHARED</code>：多个进程可以共享数据，进行映射区数据同步</li>
<li><code>MAP_PRIVATE</code>：映射区数据是私有的，不能同步给其它进程</li>
</ul>
</li>
<li><code>fd</code>：文件描述符，对应一个打开的磁盘空间，内存映射区通过这个文件描述符和磁盘文件建立关联</li>
<li><code>offset</code>：磁盘文件的偏移量，文件从偏移到的位置开始进行数据映射，使用这个参数需要注意两个问题<ul>
<li>偏移量必须是4K的整数倍，写0代表不偏移</li>
<li>这个参数必须是大于0的</li>
</ul>
</li>
</ul>
</li>
<li>返回值<ul>
<li>成功：返回一个内存映射区的起始地址</li>
<li>失败：<code>MAP_FAILED</code>（(void *)-1）</li>
</ul>
</li>
</ul>
<blockquote>
<p>  <code>mmap()</code>参数较多，在使用该函数创建用于进程间通信的内存映射区的时候，各参数的指定都有一些注意事项</p>
  <div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1. 第一个参数 addr 指定为 NULL 即可</span><br><span class="line">2. 第二个参数 length 必须要 &gt; 0</span><br><span class="line">3. 第三个参数 prot，进程间通信需要对内存映射区有读写权限，因此需要指定为：PROT_READ | PROT_WRITE</span><br><span class="line">4. 第四个参数 flags，如果要进行进程间通信, 需要指定 MAP_SHARED</span><br><span class="line">5. 第五个参数 fd，打开的文件必须大于0，进程间通信需要文件操作权限和映射区操作权限相同</span><br><span class="line">     - 内存映射区创建成功之后, 关闭这个文件描述符不会影响进程间通信</span><br><span class="line">6. 第六个参数 offset，不偏移指定为0，如果偏移必须是4k的整数倍</span><br></pre></td></tr></table></figure></div>
</blockquote>
<p>内存映射区使用之后也需要释放：</p>
<blockquote>
  <div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">munmap</span><span class="params">(<span class="type">void</span> *addr, <span class="type">size_t</span> length)</span>;</span><br></pre></td></tr></table></figure></div>

<ul>
<li>参数<ul>
<li><code>addr</code>：<code>mmap()</code>的返回值，创建的内存映射区的起始地址</li>
<li><code>length</code>：和<code>mmap()</code>第二个参数相同即可</li>
</ul>
</li>
<li>返回值：函数调用成功返回0，失败返回-1</li>
</ul>
</blockquote>
<h3 id="进程间通信-2"><a href="#进程间通信-2" class="headerlink" title="进程间通信"></a>进程间通信</h3><p>操作内存映射区和操作管道是不一样的，得到内存映射区之后是直接对内存地址进行操作，管道是通过文件描述符读写队列中的数据，管道的读写是阻塞的，内存映射区的读写是非阻塞的。内存映射区创建成功之后，得到了映射区内存的起始地址，使用相关的内存操作函数读写数据就可以了</p>
<h4 id="有血缘关系"><a href="#有血缘关系" class="headerlink" title="有血缘关系"></a>有血缘关系</h4><blockquote>
<p>  由于创建子进程会发生虚拟地址空间的复制，那么在父进程中创建的内存映射区也会被复制到子进程中，这样在子进程里边就可以直接使用这块内存映射区了，所以对于有血缘关系的进程，进行进程间通信是非常简单的</p>
</blockquote>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    1. 先创建内存映射区, 得到一个起始地址, 假设使用ptr指针保存这个地址</span></span><br><span class="line"><span class="comment">    2. 通过fork() 创建子进程 -&gt; 子进程中也就有一个内存映射区, 子进程中也有一个ptr指针指向这个地址</span></span><br><span class="line"><span class="comment">    3. 父进程往自己的内存映射区写数据, 数据同步到了磁盘文件中, 磁盘文件数据又同步到子进程的映射区中</span></span><br><span class="line"><span class="comment">       子进程从自己的映射区往外读数据, 这个数据就是父进程写的</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure></div>

<h4 id="无血缘关系"><a href="#无血缘关系" class="headerlink" title="无血缘关系"></a>无血缘关系</h4><blockquote>
<p>  对于没有血缘关系的进程间通信，需要在每个进程中分别创建内存映射区，但是这些进程的内存映射区必须要关联相同的磁盘文件，这样才能实现进程间的数据同步</p>
</blockquote>
<p>进程A的测试代码</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">mmap_out</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> fd = open(<span class="string">&quot;./memmap&quot;</span>, O_RDWR);</span><br><span class="line">    <span class="type">void</span> *addr = mmap(<span class="literal">NULL</span>, FOURK, PROT_WRITE, MAP_SHARED, fd, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (MAP_FAILED == addr)</span><br><span class="line">        handle_error(<span class="string">&quot;mmap&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; ++i) &#123;</span><br><span class="line">        <span class="type">char</span> s[<span class="number">128</span>];</span><br><span class="line">        <span class="built_in">sprintf</span>(s, <span class="string">&quot;%d: i am parent process\n&quot;</span>, i);</span><br><span class="line">        <span class="built_in">memcpy</span>(addr, s, <span class="built_in">strlen</span>(s) + <span class="number">1</span>);</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    munmap(addr, FOURK);</span><br><span class="line">    close(fd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>进程B的测试代码</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">mmap_in</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> fd = open(<span class="string">&quot;./memmap&quot;</span>, O_RDONLY);</span><br><span class="line">    <span class="type">void</span> *addr = mmap(<span class="literal">NULL</span>, FOURK, PROT_READ, MAP_SHARED, fd, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (MAP_FAILED == addr)</span><br><span class="line">        handle_error(<span class="string">&quot;mmap&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>, (<span class="type">char</span> *) addr);</span><br><span class="line"></span><br><span class="line">    munmap(addr, FOURK);</span><br><span class="line">    close(fd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>



<h3 id="拷贝文件"><a href="#拷贝文件" class="headerlink" title="拷贝文件"></a>拷贝文件</h3><p>使用内存映射区除了可以实现进程间通信，也可以进行文件的拷贝，使用这种方式拷贝文件可以减少程序猿的工作量，我们只需要负责创建内存映射区和打开磁盘文件，关于文件中的数据读写就无需关心了</p>
<blockquote>
<p>  使用内存映射拷贝文件思路</p>
<ul>
<li>打开被拷贝文件，得到文件描述符 fd1，并计算出这个文件的大小 size</li>
<li>创建内存映射区 A 并且和被拷贝文件关联，也就是和 fd1 关联起来，得到映射区地址 ptrA</li>
<li>创建新文件，得到文件描述符 fd2，用于存储被拷贝的数据，并且将这个文件大小拓展为 size</li>
<li>创建内存映射区 B 并且和新创建的文件关联，也就是和 fd2 关联起来，得到映射区地址 ptrB</li>
<li>进程地址空间之间的数据拷贝，memcpy（ptrB， ptrA，size），数据自动同步到新建文件中</li>
<li>关闭内存映射区</li>
</ul>
</blockquote>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 1. 打开一个操盘文件english.txt得到文件描述符</span></span><br><span class="line">    <span class="type">int</span> fd = open(<span class="string">&quot;./english.txt&quot;</span>, O_RDWR);</span><br><span class="line">    <span class="comment">// 计算文件大小</span></span><br><span class="line">    <span class="type">int</span> size = lseek(fd, <span class="number">0</span>, SEEK_END);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 创建内存映射区和english.txt进行关联, 得到映射区起始地址</span></span><br><span class="line">    <span class="type">void</span>* ptrA = mmap(<span class="literal">NULL</span>, size, PROT_READ|PROT_WRITE, MAP_SHARED, fd, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(ptrA == MAP_FAILED) &#123;</span><br><span class="line">        perror(<span class="string">&quot;mmap&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 创建一个新文件, 存储拷贝的数据</span></span><br><span class="line">    <span class="type">int</span> fd1 = open(<span class="string">&quot;./copy.txt&quot;</span>, O_RDWR|O_CREAT, <span class="number">0664</span>);</span><br><span class="line">    <span class="comment">// 拓展这个新文件</span></span><br><span class="line">    ftruncate(fd1, size);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4. 创建一个映射区和新文件进行关联, 得到映射区的起始地址second</span></span><br><span class="line">    <span class="type">void</span>* ptrB = mmap(<span class="literal">NULL</span>, size, PROT_READ|PROT_WRITE, MAP_SHARED, fd1, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(ptrB == MAP_FAILED) &#123;</span><br><span class="line">        perror(<span class="string">&quot;mmap----&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 5. 使用memcpy拷贝映射区数据</span></span><br><span class="line">    <span class="comment">// 这两个指针指向两块内存, 都是内存映射区</span></span><br><span class="line">    <span class="comment">// 指针指向有效的内存, 拷贝的是内存中的数据</span></span><br><span class="line">    <span class="built_in">memcpy</span>(ptrB, ptrA, size);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 6. 释放内存映射区</span></span><br><span class="line">    munmap(ptrA, size);</span><br><span class="line">    munmap(ptrB, size);</span><br><span class="line">    close(fd);</span><br><span class="line">    close(fd1);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>





<h2 id="共享内存"><a href="#共享内存" class="headerlink" title="共享内存"></a>共享内存</h2><h3 id="创建、打开共享内存"><a href="#创建、打开共享内存" class="headerlink" title="创建、打开共享内存"></a>创建、打开共享内存</h3><h4 id="shmget"><a href="#shmget" class="headerlink" title="shmget"></a>shmget</h4><p>在使用共享内存之前必须要先做一些准备工作，如果共享内存不存在就需要先创建出来，如果已经存在了就需要先打开<br>这块共享内存</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/shm.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">shmget</span><span class="params">(<span class="type">key_t</span> key, <span class="type">size_t</span> size, <span class="type">int</span> shmflg)</span>;</span><br></pre></td></tr></table></figure></div>

<ul>
<li>参数<ul>
<li><code>key</code>: 类型 key_t 是个整形数，通过这个key可以创建或者打开一块共享内存，该参数的值一定要大于0</li>
<li><code>size</code>: 创建共享内存的时候，指定共享内存的大小，如果是打开一块存在的共享内存，size 是没有意义的</li>
<li><code>shmflg</code>：创建共享内存的时候指定的属性<ul>
<li><code>IPC_CREAT</code>: 创建新的共享内存，如果创建共享内存，需要指定对共享内存的操作权限，比如：IPC_CREAT | 0664</li>
<li><code>IPC_EXCL</code>: 检测共享内存是否已经存在了，必须和 IPC_CREAT 一起使用</li>
</ul>
</li>
</ul>
</li>
<li>返回值：共享内存创建或者打开成功返回标识共享内存的唯一的 ID，失败返回 - 1</li>
</ul>
<p>函数使用举例：</p>
<blockquote>
<p>  创建一块大小为4K的共享内存</p>
</blockquote>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">shmget(<span class="number">100</span>, <span class="number">4096</span>, IPC_CREAT | <span class="number">0664</span>);</span><br></pre></td></tr></table></figure></div>

<blockquote>
<p>  创建一块大小为4K的共享内存，并且检测其是否存在</p>
</blockquote>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 	如果共享内存已经存在, 共享内存创建失败, 返回-1, 可以perror() 打印错误信息</span></span><br><span class="line">shmget(<span class="number">100</span>, <span class="number">4096</span>, IPC_CREAT | <span class="number">0664</span> | IPC_EXCL);</span><br></pre></td></tr></table></figure></div>

<blockquote>
<p>  打开一块已经存在的共享内存</p>
</blockquote>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 函数参数虽然指定了大小和IPC_CREAT, 但是都不起作用, 因为共享内存已经存在, 只能打开, 参数4096也没有意义</span></span><br><span class="line">shmget(<span class="number">100</span>, <span class="number">4096</span>, IPC_CREAT | <span class="number">0664</span>);</span><br><span class="line">shmget(<span class="number">100</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br></pre></td></tr></table></figure></div>

<blockquote>
<p>  打开一块共享内存，如果不存在就创建</p>
</blockquote>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">shmget(<span class="number">100</span>, <span class="number">4096</span>, IPC_CREAT | <span class="number">0664</span>);</span><br></pre></td></tr></table></figure></div>

<h4 id="ftok"><a href="#ftok" class="headerlink" title="ftok"></a>ftok</h4><p>shmget ( ) 函数的第一个参数是一个大于 0 的正整数，如果不想自己指定可以通过 ftok ( ) 函数直接生成这个 key 值</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ftok函数原型</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"><span class="comment">// 将两个参数作为种子, 生成一个 key_t 类型的数值</span></span><br><span class="line"><span class="type">key_t</span> <span class="title function_">ftok</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname, <span class="type">int</span> proj_id)</span>;</span><br></pre></td></tr></table></figure></div>

<ul>
<li>参数<ul>
<li><code>pathname</code>：当前操作系统中一个存在的路径</li>
<li><code>proj_id</code>：这个参数只用到了 int 中的一个字节，传参的时候要将其作为 char 进行操作，取值范围: 1-255</li>
</ul>
</li>
<li>返回值：函数调用成功返回一个可用于创建、打开共享内存的key值，调用失败返回-1</li>
</ul>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 根据路径生成一个key_t</span></span><br><span class="line"><span class="type">key_t</span> key = ftok(<span class="string">&quot;/home/robin&quot;</span>, <span class="string">&#x27;a&#x27;</span>);</span><br><span class="line"><span class="comment">// 创建或打开共享内存</span></span><br><span class="line">shmget(key, <span class="number">4096</span>, IPC_CREATE | <span class="number">0664</span>);</span><br></pre></td></tr></table></figure></div>



<h3 id="关联和解除关联"><a href="#关联和解除关联" class="headerlink" title="关联和解除关联"></a>关联和解除关联</h3><h4 id="shmat"><a href="#shmat" class="headerlink" title="shmat"></a>shmat</h4><blockquote>
<p>  创建 &#x2F; 打开共享内存之后还必须和共享内存进行关联，这样才能得到共享内存的起始地址，通过得到的内存地址<br>  进行数据的读写操作</p>
</blockquote>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> *<span class="title function_">shmat</span><span class="params">(<span class="type">int</span> shmid, <span class="type">const</span> <span class="type">void</span> *shmaddr, <span class="type">int</span> shmflg)</span>;</span><br></pre></td></tr></table></figure></div>

<ul>
<li>参数<ul>
<li><code>shmid</code>: 要操作的共享内存的 ID, 是 <code>shmget()</code> 函数的返回值</li>
<li><code>shmaddr</code>: 共享内存的起始地址，用户不知道，需要让内核指定，写 NULL</li>
<li><code>shmflg</code>: 和共享内存关联的对共享内存的操作权限<ul>
<li><code>SHM_RDONLY</code>: 读权限，只能读共享内存中的数据</li>
<li><code>0</code>: 读写权限，可以读写共享内存数据</li>
</ul>
</li>
</ul>
</li>
<li>返回值：关联成功，返回值共享内存的起始地址，关联失败返回 (void *) -1</li>
</ul>
<h4 id="shmdt"><a href="#shmdt" class="headerlink" title="shmdt"></a>shmdt</h4><blockquote>
<p>  当进程不需要再操作共享内存，可以让进程和共享内存解除关联，另外如果没有执行该操作，进程退出之后，结束的<br>  进程和共享内存的关联也就自动解除了</p>
</blockquote>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">shmdt</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *shmaddr)</span>;</span><br></pre></td></tr></table></figure></div>

<ul>
<li>参数：<code>shmdt()</code>函数的返回值，共享内存的起始地址</li>
<li>返回值：关联解除成功返回0，失败返回-1</li>
</ul>
<h3 id="删除共享内存"><a href="#删除共享内存" class="headerlink" title="删除共享内存"></a>删除共享内存</h3><h4 id="shmctl"><a href="#shmctl" class="headerlink" title="shmctl"></a>shmctl</h4><blockquote>
<p>  <code>shmctl()</code> 函数是一个多功能函数，可以设置、获取共享内存的状态也可以将共享内存标记为删除状态<br>  当共享内存被标记为删除状态之后，并不会马上被删除，直到所有的进程全部和共享内存解除关联，共享内存才会被删除<br>  因为通过 <code>shmctl()</code> 函数只是能够标记删除共享内存，所以在程序中多次调用该操作是没有关系的</p>
</blockquote>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 共享内存控制函数</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">shmctl</span><span class="params">(<span class="type">int</span> shmid, <span class="type">int</span> cmd, <span class="keyword">struct</span> shmid_ds *buf)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 参数 struct shmid_ds 结构体原型          </span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">shmid_ds</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">ipc_perm</span> <span class="title">shm_perm</span>;</span>    <span class="comment">/* Ownership and permissions */</span></span><br><span class="line">	<span class="type">size_t</span>          shm_segsz;   <span class="comment">/* Size of segment (bytes) */</span></span><br><span class="line">	<span class="type">time_t</span>          shm_atime;   <span class="comment">/* Last attach time */</span></span><br><span class="line">	<span class="type">time_t</span>          shm_dtime;   <span class="comment">/* Last detach time */</span></span><br><span class="line">	<span class="type">time_t</span>          shm_ctime;   <span class="comment">/* Last change time */</span></span><br><span class="line">	<span class="type">pid_t</span>           shm_cpid;    <span class="comment">/* PID of creator */</span></span><br><span class="line">	<span class="type">pid_t</span>           shm_lpid;    <span class="comment">/* PID of last shmat(2)/shmdt(2) */</span></span><br><span class="line">    <span class="comment">// 引用计数, 多少个进程和共享内存进行了关联</span></span><br><span class="line">	<span class="type">shmatt_t</span>        shm_nattch;  <span class="comment">/* 记录了有多少个进程和当前共享内存进行了管联 */</span></span><br><span class="line">	...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>

<ul>
<li>参数<ul>
<li><code>shmid</code>：要操作的共享内存的 ID, 是 <code>shmget()</code> 函数的返回值</li>
<li><code>cmd</code>：要做的操作<ul>
<li><code>IPC_STAT</code>：得到当前共享内存的状态</li>
<li><code>IPC_SET</code>：设置共享内存的状态</li>
<li><code>IPC_DMID</code>：标记共享内存要被删除了</li>
</ul>
</li>
<li><code>buf</code><ul>
<li><code>cmd == IPC_STAT</code>：作为传出参数，会得到共享内存的相关属性信息</li>
<li><code>cmd == IPC_SET</code>：作为传入参，将用户的自定义属性设置到共享内存中</li>
<li><code>cmd == IPC_RMID</code>：<code>buf</code>就没意义了，这时候<code>buf</code>指定为NULL即可</li>
</ul>
</li>
</ul>
</li>
<li>返回值：函数调用成功返回值大于等于 0，调用失败返回 - 1</li>
</ul>
<h4 id="相关shell命令"><a href="#相关shell命令" class="headerlink" title="相关shell命令"></a>相关shell命令</h4><blockquote>
<p>  查看系统中共享内存的详细信息</p>
</blockquote>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ipcs -m</span><br></pre></td></tr></table></figure></div>

<blockquote>
<p>  使用ipcrm命令可以标记删除某块共享内存</p>
</blockquote>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># key == shmget</span></span><br><span class="line">ipcrm -M shmkey</span><br><span class="line"></span><br><span class="line"><span class="comment"># id == shmget</span></span><br><span class="line">ipcrm -m shmid</span><br></pre></td></tr></table></figure></div>

<h4 id="共享内存状态"><a href="#共享内存状态" class="headerlink" title="共享内存状态"></a>共享内存状态</h4><div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 参数 struct shmid_ds 结构体原型          </span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">shmid_ds</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">ipc_perm</span> <span class="title">shm_perm</span>;</span>    <span class="comment">/* Ownership and permissions */</span></span><br><span class="line">	<span class="type">size_t</span>          shm_segsz;   <span class="comment">/* Size of segment (bytes) */</span></span><br><span class="line">	<span class="type">time_t</span>          shm_atime;   <span class="comment">/* Last attach time */</span></span><br><span class="line">	<span class="type">time_t</span>          shm_dtime;   <span class="comment">/* Last detach time */</span></span><br><span class="line">	<span class="type">time_t</span>          shm_ctime;   <span class="comment">/* Last change time */</span></span><br><span class="line">	<span class="type">pid_t</span>           shm_cpid;    <span class="comment">/* PID of creator */</span></span><br><span class="line">	<span class="type">pid_t</span>           shm_lpid;    <span class="comment">/* PID of last shmat(2)/shmdt(2) */</span></span><br><span class="line">    <span class="comment">// 引用计数, 多少个进程和共享内存进行了关联</span></span><br><span class="line">	<span class="type">shmatt_t</span>        shm_nattch;  <span class="comment">/* 记录了有多少个进程和当前共享内存进行了管联 */</span></span><br><span class="line">	...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>

<p>通过 shmctl() 我们可以得知，共享内存的信息是存储到一个叫做 struct shmid_ds 的结构体中，其中有一个非常重要的成员<br>叫做 shm_nattch，在这个成员变量里边记录着当前共享内存关联的进程的个数，一般将其称之为引用计数。当共享内存被<br>标记为删除状态，并且这个引用计数变为 0 之后共享内存才会被真正的被删除掉</p>
<p>当共享内存被标记为删除状态之后，共享内存的状态也会发生变化，共享内存内部维护的 key 从一个正整数变为 0，其属性<br>从公共的变为私有的。这里的私有是指只有已经关联成功的进程才允许继续访问共享内存，不再允许新的进程和这块共享内<br>存进行关联了</p>
<h3 id="进程间通信-3"><a href="#进程间通信-3" class="headerlink" title="进程间通信"></a>进程间通信</h3><blockquote>
<p>  使用共享内存实现进程间通信</p>
</blockquote>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> 调用linux的系统API创建一块共享内存</span><br><span class="line">    - 这块内存不属于任何进程, 默认进程不能对其进行操作</span><br><span class="line">    </span><br><span class="line"><span class="number">2.</span> 准备好进程A, 和进程B, 这两个进程需要和创建的共享内存进行关联</span><br><span class="line">    - 关联操作: 调用linux的 api</span><br><span class="line">    - 关联成功之后, 得到了这块共享内存的起始地址</span><br><span class="line">        </span><br><span class="line"><span class="number">3.</span> 在进程A或者进程B中对共享内存进行读写操作</span><br><span class="line">    - 读内存: <span class="built_in">printf</span>() 等;</span><br><span class="line">	- 写内存: <span class="built_in">memcpy</span>() 等;</span><br><span class="line"></span><br><span class="line"><span class="number">4.</span> 通信完成, 可以让进程A和B和共享内存解除关联</span><br><span class="line">    - 解除成功, 进程A和B不能再操作共享内存了</span><br><span class="line">    - 共享内存不受进程生命周期的影响的</span><br><span class="line">    </span><br><span class="line"><span class="number">5.</span> 共享内存不在使用之后, 将其删除</span><br><span class="line">    - 调用linux的api函数, 删除之后这块内存被内核回收了</span><br></pre></td></tr></table></figure></div>

<p>写共享内存的进程代码：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">shm_out</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// create shared memory, 4K</span></span><br><span class="line">    <span class="type">key_t</span> key = ftok(<span class="string">&quot;/home/fetch150zy&quot;</span>, <span class="string">&#x27;m&#x27;</span>);</span><br><span class="line">    <span class="type">int</span> mode = <span class="number">0664</span>;</span><br><span class="line">    <span class="type">int</span> shmid = shmget(key, <span class="number">4096</span>, IPC_CREAT | mode);</span><br><span class="line">    <span class="keyword">if</span> (<span class="number">-1</span> == shmid)</span><br><span class="line">        handle_error(<span class="string">&quot;shmget&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// associated process and shared memory</span></span><br><span class="line">    <span class="type">void</span> *addr = shmat(shmid, <span class="literal">NULL</span> ,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> ((<span class="type">void</span> *)<span class="number">-1</span> == addr)</span><br><span class="line">        handle_error(<span class="string">&quot;shmat&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// write to shared memory</span></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *s = <span class="string">&quot;this is shared-memory\n&quot;</span>;</span><br><span class="line">    <span class="built_in">memcpy</span>(addr, s, <span class="built_in">strlen</span>(s) + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// blocking</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;press any key to continue...&quot;</span>);</span><br><span class="line">    getchar();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// disassociate</span></span><br><span class="line">    shmdt(addr);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// delete the shared memory</span></span><br><span class="line">    shmctl(shmid, IPC_RMID, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;shared-memory has been deleted&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>读共享内存的进程代码：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">shm_in</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// open the shared-memory</span></span><br><span class="line">    <span class="type">key_t</span> key = ftok(<span class="string">&quot;/home/fetch150zy&quot;</span>, <span class="string">&#x27;m&#x27;</span>);</span><br><span class="line">    <span class="type">int</span> shmid = shmget(key, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (<span class="number">-1</span> == shmid)</span><br><span class="line">        handle_error(<span class="string">&quot;shmget&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// associated process and shared memory</span></span><br><span class="line">    <span class="type">void</span> *addr = shmat(shmid, <span class="literal">NULL</span> ,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> ((<span class="type">void</span> *)<span class="number">-1</span> == addr)</span><br><span class="line">        handle_error(<span class="string">&quot;shmat&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// read from shared-memory</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>, (<span class="type">char</span> *)addr);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// blocking</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;press any key to continue...&quot;</span>);</span><br><span class="line">    getchar();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// disassociate</span></span><br><span class="line">    shmdt(addr);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// delete the shared-memory</span></span><br><span class="line">    shmctl(shmid, IPC_RMID, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;shared-memory has been deleted&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>



<h3 id="shm和mmap的区别"><a href="#shm和mmap的区别" class="headerlink" title="shm和mmap的区别"></a>shm和mmap的区别</h3><p><code>共享内存 内存映射区</code>都可以实现进程间通信</p>
<ul>
<li>实现进程间通信的方式<ul>
<li><code>shm</code>：多个进程只需要一块共享内存就够了，共享内存不属于进程，需要和进程关联才能使用</li>
<li>内存映射区：位于每个进程的虚拟地址空间中，并且需要关联同一个磁盘文件才能实现进程间数据通信</li>
</ul>
</li>
<li>效率<ul>
<li><code>shm</code>：直接对内存操作，效率高</li>
<li>内存映射区：需要内存和文件之间的数据同步，效率低</li>
</ul>
</li>
<li>生命周期<ul>
<li>内存映射区：进程退出，内存映射区也就没有了</li>
<li><code>shm</code>：进程退出对共享内存没有影响，调用相关函数 &#x2F; 命令 &#x2F; 关机才能删除共享内存</li>
</ul>
</li>
<li>数据的完整性：突发状态下数据能不能被保存下来<ul>
<li>内存映射区：可以完整的保存数据，内存映射区数据会同步到磁盘文件</li>
<li><code>shm</code>：数据存储在物理内存中，断电之后系统关闭，内存数据也就丢失了</li>
</ul>
</li>
</ul>
<h2 id="守护进程"><a href="#守护进程" class="headerlink" title="守护进程"></a>守护进程</h2><p>守护进程（Daemon Process），也就是通常说的 Daemon 进程（精灵进程），是 Linux 中的后台服务进程。它是一个生<br>存期较长的进程，通常独立于控制终端并且周期性地执行某种任务或等待处理某些发生的事件。一般采用以 d 结尾的名字</p>
<h3 id="进程组"><a href="#进程组" class="headerlink" title="进程组"></a>进程组</h3><blockquote>
<p>  多个进程的集合就是进程组，这个组中必须有一个组长，组长就是进程组中的第一个进程，组长以外的都是普通的<br>  成员，每个进程组都有一个唯一的组 ID，进程组的 ID 和组长的 PID 是一样的</p>
<p>  进程组中的成员是可以转移的，如果当前进程组中的成员被转移到了其他的组，或者进制中的所有进程都退出了，<br>  那么这个进程组也就不存在了。如果进程组中组长死了，但是当前进程组中有其他进程，这个进程组还是继续存在</p>
</blockquote>
<p>得到当前进程所在的进程组的组ID</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">pid_t</span> <span class="title function_">getpgrp</span><span class="params">(<span class="type">void</span>)</span>;</span><br></pre></td></tr></table></figure></div>

<p>获取指定的进程所在的进程组的组ID，参数pid就是指定的进程</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">pid_t</span> <span class="title function_">getpgid</span><span class="params">(<span class="type">pid_t</span> pid)</span>;</span><br></pre></td></tr></table></figure></div>

<p>将某个进程移动到其他进程组中或者创建新的进程组</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">setpgid</span><span class="params">(<span class="type">pid_t</span> pid, <span class="type">pid_t</span> pgid)</span>;</span><br></pre></td></tr></table></figure></div>

<ul>
<li>参数<ul>
<li><code>pid</code>：某个进程的进程ID</li>
<li><code>pgid</code>：某个进程组的组ID<ul>
<li>如果 pgid 对应的进程组存在，pid 对应的进程会移动到这个组中，pid !&#x3D; pgid</li>
<li>如果 pgid 对应的进程组不存在，会创建一个新的进程组，因此要求 pid &#x3D;&#x3D; pgid, 当前进程就是组长了</li>
</ul>
</li>
</ul>
</li>
<li>返回值：函数调用成功返回 0，失败返回 - 1</li>
</ul>
<h3 id="会话"><a href="#会话" class="headerlink" title="会话"></a>会话</h3><p>会话 (session) 是由一个或多个进程组组成的，一个会话可以对应一个控制终端，也可以没有。一个普通的进程可以调<br>用 setsid() 函数使自己成为新 session 的领头进程（会长），并且这个 session 领头进程还会被放入到一个新的进程组</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取某个进程所属的会话ID</span></span><br><span class="line"><span class="type">pid_t</span> <span class="title function_">getsid</span><span class="params">(<span class="type">pid_t</span> pid)</span>;</span><br><span class="line"><span class="comment">// 将某个进程变成会话 =&gt;&gt; 得到一个守护进程</span></span><br><span class="line"><span class="comment">// 使用哪个进程调用这个函数, 这个进程就会变成一个会话</span></span><br><span class="line"><span class="type">pid_t</span> <span class="title function_">setsid</span><span class="params">(<span class="type">void</span>)</span>;</span><br></pre></td></tr></table></figure></div>

<blockquote>
<p>  注意事项：</p>
<ul>
<li>调用这个函数的进程不能是组长进程，通过<code>先 fork () 创建子进程，终止父进程，让子进程调用这个函数</code><br>保证这个函数调用成功</li>
<li>如果调用这个函数的进程不是进程组长，会话创建成功<ul>
<li>这个进程会变成当前会话中的第一个进程，同时也会变成新的进程组的组长</li>
<li>该函数调用成功之后，当前进程就脱离了控制终端，因此不会阻塞终端</li>
</ul>
</li>
</ul>
</blockquote>
<h3 id="创建守护进程"><a href="#创建守护进程" class="headerlink" title="创建守护进程"></a>创建守护进程</h3><p>如果要创建一个守护进程，标准步骤如下：</p>
<ol>
<li><p>创建子进程，让父进程退出</p>
<ul>
<li>因为父进程有可能是组长进程，不符合条件，也没有什么利用价值，退出即可</li>
<li>子进程没有任何职务，目的是让子进程最终变成一个会话，最终就会得到守护进程</li>
</ul>
</li>
<li><p>通过子进程创建新的会话，调用函数 <code>setsid()</code>，脱离控制终端，变成守护进程</p>
</li>
<li><p>改变当前进程的工作目录（可选项）</p>
<ul>
<li><p>某些文件系统可以被卸载，比如: U 盘，移动硬盘，进程如果在这些目录中运行，运行期间这些设备被卸载了，<br>运行的进程也就不能正常工作了</p>
</li>
<li><p>修改当前进程的工作目录需要调用函数 <code>chdir()</code></p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">chdir</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *path)</span>;</span><br></pre></td></tr></table></figure></div></li>
</ul>
</li>
<li><p>重新设置文件的掩码（可选项）</p>
<ul>
<li><p>掩码: umask, 在创建新文件的时候需要和这个掩码进行运算，去掉文件的某些权限</p>
</li>
<li><p>设置掩码需要使用函数 <code>umask()</code></p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">mode_t</span> <span class="title function_">umask</span><span class="params">(<span class="type">mode_t</span> mask)</span>;</span><br></pre></td></tr></table></figure></div></li>
</ul>
</li>
<li><p>关闭 &#x2F; 重定向文件描述符</p>
<ul>
<li><p>启动一个进程，文件描述符表中默认有三个被打开了，对应的都是当前的终端文件</p>
</li>
<li><p>因为进程通过调用 setsid () 已经脱离了当前终端，因此关联的文件描述符也就没用了，可以关闭</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">close(STDIN_FILENO);</span><br><span class="line">close(STDOUT_FILENO);</span><br><span class="line">close(STDERR_FILENO);</span><br></pre></td></tr></table></figure></div>
</li>
<li><p>重定向文件描述符 (和关闭二选一): 改变文件描述符关联的默认文件，让他们指向一个特殊的文件 &#x2F;dev&#x2F;null，<br>只要把数据扔到这个特殊的设备文件中，数据被被销毁了</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> fd = open(<span class="string">&quot;/dev/null&quot;</span>, O_RDWR);</span><br><span class="line"><span class="comment">// 重定向之后, 这三个文件描述符就和当前终端没有任何关系了</span></span><br><span class="line">dup2(fd, STDIN_FILENO);</span><br><span class="line">dup2(fd, STDOUT_FILENO);</span><br><span class="line">dup2(fd, STDERR_FILENO);</span><br></pre></td></tr></table></figure></div></li>
</ul>
</li>
</ol>
<h3 id="守护进程的应用"><a href="#守护进程的应用" class="headerlink" title="守护进程的应用"></a>守护进程的应用</h3><blockquote>
<p>  写一个守护进程，每隔 2s 获取一次系统时间，并将得到的时间写入到磁盘文件中</p>
</blockquote>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 信号的处理动作</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">writeFile</span><span class="params">(<span class="type">int</span> num)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 得到系统时间</span></span><br><span class="line">    <span class="type">time_t</span> seconds = time(<span class="literal">NULL</span>);</span><br><span class="line">    <span class="comment">// 时间转换, 总秒数 -&gt; 可以识别的时间字符串</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tm</span>* <span class="title">loc</span> =</span> localtime(&amp;seconds);</span><br><span class="line">    <span class="comment">// sprintf();</span></span><br><span class="line">    <span class="type">char</span>* curtime = asctime(loc); <span class="comment">// 自带换行</span></span><br><span class="line">    <span class="comment">// 打开一个文件, 如果文件不存在, 就创建, 文件需要有追加属性</span></span><br><span class="line">    <span class="comment">// ./对应的是哪个目录? /home/robin</span></span><br><span class="line">    <span class="comment">// 0664 &amp; ~022</span></span><br><span class="line">    <span class="type">int</span> fd = open(<span class="string">&quot;./time+++++++.log&quot;</span>, O_WRONLY|O_CREAT|O_APPEND, <span class="number">0664</span>);</span><br><span class="line">    write(fd, curtime, <span class="built_in">strlen</span>(curtime));</span><br><span class="line">    close(fd);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 1. 创建子进程, 杀死父进程</span></span><br><span class="line">    <span class="type">pid_t</span> pid = fork();</span><br><span class="line">    <span class="keyword">if</span>(pid &gt; <span class="number">0</span>)</span><br><span class="line">        <span class="comment">// 父进程</span></span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>); <span class="comment">// kill(getpid(), 9); raise(9); abort();</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 子进程, 将其变成会话, 脱离当前终端</span></span><br><span class="line">    setsid();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 修改进程的工作目录, 修改到一个不能被修改和删除的目录中 /home/robin</span></span><br><span class="line">    chdir(<span class="string">&quot;/home/robin&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4. 设置掩码, 在进程中创建文件的时候这个掩码就起作用了</span></span><br><span class="line">    umask(<span class="number">022</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 5. 重定向和终端关联的文件描述符 -&gt; /dev/null</span></span><br><span class="line">    <span class="type">int</span> fd = open(<span class="string">&quot;/dev/null&quot;</span>, O_RDWR);</span><br><span class="line">    dup2(fd, STDIN_FILENO);</span><br><span class="line">    dup2(fd, STDOUT_FILENO);</span><br><span class="line">    dup2(fd, STDERR_FILENO);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 5. 委托内核捕捉并处理将来发生的信号-SIGALRM(14)</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> <span class="title">act</span>;</span></span><br><span class="line">    act.sa_flags = <span class="number">0</span>;</span><br><span class="line">    act.sa_handler = writeFile;</span><br><span class="line">    sigemptyset(&amp;act.sa_mask);</span><br><span class="line">    sigaction(SIGALRM, &amp;act, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 6. 设置定时器</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">itimerval</span> <span class="title">val</span>;</span></span><br><span class="line">    val.it_value.tv_sec = <span class="number">2</span>;</span><br><span class="line">    val.it_value.tv_usec = <span class="number">0</span>;</span><br><span class="line">    val.it_interval.tv_sec = <span class="number">2</span>;</span><br><span class="line">    val.it_interval.tv_usec = <span class="number">0</span>;</span><br><span class="line">    setitimer(ITIMER_REAL, &amp;val, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">        sleep(<span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>





<h2 id="信号"><a href="#信号" class="headerlink" title="信号"></a>信号</h2><blockquote>
<p>  Linux中的信号是一种消息处理机制，本质上是一个整数，信号在系统中的优先级非常高</p>
</blockquote>
<p>在Linux中的很多常规操作都会有相关的信号产生</p>
<ul>
<li>键盘</li>
<li><code>shell</code>命令</li>
<li>函数调用</li>
<li>对硬件的非法访问</li>
</ul>
<h3 id="信号-1"><a href="#信号-1" class="headerlink" title="信号"></a>信号</h3><h4 id="信号编号"><a href="#信号编号" class="headerlink" title="信号编号"></a>信号编号</h4><div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">kill</span> -l</span></span><br></pre></td></tr></table></figure></div>

<table>
<thead>
<tr>
<th align="center">编号</th>
<th align="center">信号</th>
<th align="center">事件</th>
<th align="center">默认动作</th>
</tr>
</thead>
<tbody><tr>
<td align="center">1</td>
<td align="center">SIGHUP</td>
<td align="center">用户退出 shell 时，由该 shell 启动的所有进程将收到这个信号</td>
<td align="center">终止进程</td>
</tr>
<tr>
<td align="center">2</td>
<td align="center">SIGINT</td>
<td align="center">&lt;Ctrl+C&gt;，用户终端向正在运行中的由该终端启动的程序发出此信号</td>
<td align="center">终止进程</td>
</tr>
<tr>
<td align="center">3</td>
<td align="center">SIGQUIT</td>
<td align="center">&lt;ctrl+\&gt;，用户终端向正在运行中的由该终端启动的程序发出些信号</td>
<td align="center">终止进程</td>
</tr>
<tr>
<td align="center">4</td>
<td align="center">SIGILL</td>
<td align="center">CPU 检测到某进程执行了非法指令</td>
<td align="center">终止进程并产生 core 文件</td>
</tr>
<tr>
<td align="center">5</td>
<td align="center">SIGTRAP</td>
<td align="center">该信号由断点指令或其他 trap 指令产生</td>
<td align="center">终止进程并产生 core 文件</td>
</tr>
<tr>
<td align="center">6</td>
<td align="center">SIGABRT</td>
<td align="center">调用 abort 函数时产生该信号</td>
<td align="center">终止进程并产生 core 文件</td>
</tr>
<tr>
<td align="center">7</td>
<td align="center">SIGBUS</td>
<td align="center">非法访问内存地址，包括内存对齐出错</td>
<td align="center">终止进程并产生 core 文件</td>
</tr>
<tr>
<td align="center">8</td>
<td align="center">SIGFPE</td>
<td align="center">在发生致命的运算错误时发出。不仅包括浮点运算错误，还包括溢出及除数为 0 等所有的算法错误</td>
<td align="center">终止进程并产生 core 文件</td>
</tr>
<tr>
<td align="center">9</td>
<td align="center">SIGKILL</td>
<td align="center">无条件终止进程</td>
<td align="center">终止进程，可以杀死任何进程</td>
</tr>
<tr>
<td align="center">10</td>
<td align="center">SIGUSE1</td>
<td align="center">用户定义的信号。即程序员可以在程序中定义并使用该信号</td>
<td align="center">终止进程</td>
</tr>
<tr>
<td align="center">11</td>
<td align="center">SIGSEGV</td>
<td align="center">指示进程进行了无效内存访问 (段错误)</td>
<td align="center">终止进程并产生 core 文件</td>
</tr>
<tr>
<td align="center">12</td>
<td align="center">SIGUSR2</td>
<td align="center">另外一个用户自定义信号，程序员可以在程序中定义并使用该信号</td>
<td align="center">终止进程</td>
</tr>
<tr>
<td align="center">13</td>
<td align="center">SIGPIPE</td>
<td align="center">Broken pipe 向一个没有读端的管道写数据</td>
<td align="center">终止进程</td>
</tr>
<tr>
<td align="center">14</td>
<td align="center">SIGALRM</td>
<td align="center">定时器超时，超时的时间 由系统调用 alarm 设置</td>
<td align="center">终止进程</td>
</tr>
<tr>
<td align="center">15</td>
<td align="center">SIGTERM</td>
<td align="center">可以被阻塞和终止，通常用来要示程序正常退出</td>
<td align="center">终止进程</td>
</tr>
<tr>
<td align="center">16</td>
<td align="center">SIGSTKFLT</td>
<td align="center">Linux 早期版本出现的信号，现仍保留向后兼容</td>
<td align="center">终止进程</td>
</tr>
<tr>
<td align="center">17</td>
<td align="center">SIGCHLD</td>
<td align="center">子进程结束时，父进程会收到这个信号</td>
<td align="center">忽略这个信号</td>
</tr>
<tr>
<td align="center">18</td>
<td align="center">SIGCONT</td>
<td align="center">如果进程已停止，则使其继续运行</td>
<td align="center">继续 &#x2F; 忽略</td>
</tr>
<tr>
<td align="center">19</td>
<td align="center">SIGSTOP</td>
<td align="center">停止进程的执行。信号不能被忽略，处理和阻塞</td>
<td align="center">为终止进程</td>
</tr>
<tr>
<td align="center">20</td>
<td align="center">SIGTSTP</td>
<td align="center">&lt;ctrl+z&gt;，停止终端交互进程的运行</td>
<td align="center">暂停进程</td>
</tr>
<tr>
<td align="center">21</td>
<td align="center">SIGTTIN</td>
<td align="center">后台进程读终端控制台</td>
<td align="center">暂停进程</td>
</tr>
<tr>
<td align="center">22</td>
<td align="center">SIGTTOU</td>
<td align="center">该信号类似于 SIGTTIN，在后台进程要向终端输出数据时发生</td>
<td align="center">暂停进程</td>
</tr>
<tr>
<td align="center">23</td>
<td align="center">SIGURG</td>
<td align="center">套接字上有紧急数据时，向当前正在运行的进程发出些信号，报告有紧急数据到达。如网络带外数据到达</td>
<td align="center">忽略该信号</td>
</tr>
<tr>
<td align="center">24</td>
<td align="center">SIGXCPU</td>
<td align="center">进程执行时间超过了分配给该进程的 CPU 时间 ，系统产生该信号并发送给该进程</td>
<td align="center">终止进程</td>
</tr>
<tr>
<td align="center">25</td>
<td align="center">SIGXFSZ</td>
<td align="center">超过文件的最大长度设置</td>
<td align="center">终止进程</td>
</tr>
<tr>
<td align="center">26</td>
<td align="center">SIGVTALRM</td>
<td align="center">虚拟时钟超时时产生该信号。类似于 SIGALRM，但是该信号只计算该进程占用 CPU 的使用时间</td>
<td align="center">终止进程</td>
</tr>
<tr>
<td align="center">27</td>
<td align="center">SGIPROF</td>
<td align="center">类似于 SIGVTALRM，它不公包括该进程占用 CPU 时间还包括执行系统调用时间</td>
<td align="center">终止进程</td>
</tr>
<tr>
<td align="center">28</td>
<td align="center">SIGWINCH</td>
<td align="center">窗口变化大小时发出</td>
<td align="center">忽略该信号</td>
</tr>
<tr>
<td align="center">29</td>
<td align="center">SIGIO</td>
<td align="center">此信号向进程指示发出了一个异步 IO 事件</td>
<td align="center">忽略该信号</td>
</tr>
<tr>
<td align="center">30</td>
<td align="center">SIGPWR</td>
<td align="center">关机</td>
<td align="center">终止进程</td>
</tr>
<tr>
<td align="center">31</td>
<td align="center">SIGSYS</td>
<td align="center">无效的系统调用</td>
<td align="center">终止进程并产生 core 文件</td>
</tr>
<tr>
<td align="center">34~64</td>
<td align="center">SIGRTMIN ～ SIGRTMAX</td>
<td align="center">LINUX 的实时信号，它们没有固定的含义（可以由用户自定义）</td>
<td align="center">终止进程</td>
</tr>
</tbody></table>
<h4 id="查看信号信息"><a href="#查看信号信息" class="headerlink" title="查看信号信息"></a>查看信号信息</h4><div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">man 7 signal</span></span><br></pre></td></tr></table></figure></div>

<blockquote>
<p>  五种对产生信号的默认处理动作</p>
</blockquote>
<ol>
<li><code>Term</code> ：信号将进程终止</li>
<li><code>Ign</code>：信号产生之后默认被忽略了</li>
<li><code>Core</code>：信号将进程终止，并且生成一个core文件（一般用于gdb调试）</li>
<li><code>Stop</code>：信号将会暂停进程的运行</li>
<li><code>Cont</code>：信号会让暂停的进程继续运行</li>
</ol>
<blockquote>
<p>  <strong>9号信号和19号信号不能被捕捉、阻塞、忽略</strong></p>
<ul>
<li>9号信号：无条件杀死进程</li>
<li>19号信号：无条件暂停进程</li>
</ul>
</blockquote>
<h4 id="信号的状态"><a href="#信号的状态" class="headerlink" title="信号的状态"></a>信号的状态</h4><p>Linux的信号有三种状态，分别为：产生、未决、递达</p>
<ul>
<li><code>产生</code>：键盘输入、函数调用、执行shell命令、对硬件进行非法访问都会产生信号</li>
<li><code>未决</code>：信号产生了，但是这个信号还没有被处理掉，这个期间信号的状态称之为未决状态</li>
<li><code>递达</code>：信号被处理了（被某个进程处理掉）</li>
</ul>
<h3 id="信号相关函数"><a href="#信号相关函数" class="headerlink" title="信号相关函数"></a>信号相关函数</h3><blockquote>
<p>  产生信号的常用函数</p>
</blockquote>
<h4 id="kill-raise-abort"><a href="#kill-raise-abort" class="headerlink" title="kill raise abort"></a>kill raise abort</h4><p><strong>发送相关的信号给对应的进程</strong></p>
<ul>
<li><p><code>kill</code>发送指定的信号到指定的进程</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 给某一个进程发送一个信号</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">kill</span><span class="params">(<span class="type">pid_t</span> pid, <span class="type">int</span> sig)</span>;</span><br></pre></td></tr></table></figure></div>

<ul>
<li>参数：<code>pid</code>进程ID，<code>sig</code>要发送的信号</li>
</ul>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">kill(getpid(), <span class="number">9</span>);	<span class="comment">// kill self</span></span><br><span class="line">kill(getppid(), <span class="number">10</span>);<span class="comment">// kill parent</span></span><br></pre></td></tr></table></figure></div>
</li>
<li><p><code>raise</code>给当前进程发送指定的信号</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 给自己发送某一个信号</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">raise</span><span class="params">(<span class="type">int</span> sig)</span>;</span><br></pre></td></tr></table></figure></div>
</li>
<li><p><code>abort</code>给当前进程发送一个固定信号（SIGABRT）</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这是一个中断函数, 调用这个函数, 发送一个固定信号 (SIGABRT), 杀死当前进程</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">abort</span><span class="params">(<span class="type">void</span>)</span>;</span><br></pre></td></tr></table></figure></div></li>
</ul>
<h4 id="定时器"><a href="#定时器" class="headerlink" title="定时器"></a>定时器</h4><ul>
<li><p><code>alarm</code>：alarm ( ) 函数只能进行单次定时，定时完成发射出一个信号</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">int</span> <span class="title function_">alarm</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> seconds)</span>;</span><br></pre></td></tr></table></figure></div>

<ul>
<li>参数：倒计时seconds，倒计时完成发送SIGALRM，当前进程会收到这个信号</li>
<li>返回值：大于0表示倒计时还剩多少秒，0表示倒计时完成</li>
</ul>
<blockquote>
<p>  <code>real = user + sys + 消耗的时间(频率的从用户区到内核区进程切换)</code></p>
</blockquote>
</li>
<li><p><code>setitimer</code>：setitimer ( ) 函数可以进行周期性定时，每触发一次定时器就会发射出一个信号</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这个函数可以实现周期性定时, 每个一段固定的时间, 发出一个特定的定时器信号</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">itimerval</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">it_interval</span>;</span> <span class="comment">/* 时间间隔 */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">it_value</span>;</span>    <span class="comment">/* 第一次触发定时器的时长 */</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 这个结构体表示的是一个时间段: tv_sec + tv_usec</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> &#123;</span></span><br><span class="line">	<span class="type">time_t</span>      tv_sec;         <span class="comment">/* 秒 */</span></span><br><span class="line">	<span class="type">suseconds_t</span> tv_usec;        <span class="comment">/* 微妙 */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">setitimer</span><span class="params">(<span class="type">int</span> which, <span class="type">const</span> <span class="keyword">struct</span> itimerval *new_value, </span></span><br><span class="line"><span class="params">              <span class="keyword">struct</span> itimerval *old_value)</span>;</span><br></pre></td></tr></table></figure></div>
</li>
<li><p>参数：</p>
<ul>
<li><code>which</code>：定时器使用什么样的计时法则<ul>
<li><code>ITIMER_REAL</code>：自然计时法，发送<code>SIGALRM</code></li>
<li><code>ITIMER_VIRTUAL</code>：只计算用户区运行的时间，发送<code>SIGVTALRM</code></li>
<li><code>ITIMER_PROF</code>：只计算内核运行时间，发送<code>SIGPROF</code></li>
</ul>
</li>
<li><code>new_value</code>：给定时器设置的定时信息，传入参数</li>
<li><code>old_value</code>：上一次给定时器设置的定时信息，传出参数，如果不需要可以指定为NULL</li>
</ul>
</li>
</ul>
<h3 id="信号集"><a href="#信号集" class="headerlink" title="信号集"></a>信号集</h3><h4 id="阻塞、未决信号集"><a href="#阻塞、未决信号集" class="headerlink" title="阻塞、未决信号集"></a>阻塞、未决信号集</h4><p><strong>在PCB中有两个非常重要的信号集，一个称为阻塞信号集，另一个称为未决信号集</strong></p>
<ul>
<li><p>信号的<code>未决</code>是一种状态，指的是从信号的产生到信号被处理前的一段时间</p>
</li>
<li><p>信号的<code>阻塞</code>是一个开关动作，指的是阻止信号被处理，但不是阻止信号产生</p>
<blockquote>
<p>  信号的阻塞就是让系统暂时保留信号留待以后发送</p>
</blockquote>
</li>
</ul>
<p>阻塞信号集和未决信号集在内核中的结构是相同的，它们都是一个整形数组 (被封装过的), 一共 128 字节 （int [32] &#x3D;&#x3D; 1024 bit），1024 个标志位，其中前 31 个标志位，每一个都对应一个 Linux 中的标准信号，通过标志位的值来标记当前信号在信号集中的状态</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 上图对信号集在内核中存储的状态的描述</span><br><span class="line"># 前<span class="number">31</span>个信号: <span class="number">1</span><span class="number">-31</span> , 对应 <span class="number">1024</span>个标志位的前<span class="number">31</span>个标志位</span><br><span class="line">			信号		标志位(从低地址位 到 高地址位)</span><br><span class="line">		 	  <span class="number">1</span>      -&gt;  	<span class="number">0</span></span><br><span class="line">			  <span class="number">2</span>             <span class="number">1</span></span><br><span class="line">			  <span class="number">3</span>             <span class="number">2</span></span><br><span class="line">			  <span class="number">4</span>             <span class="number">3</span></span><br><span class="line">			 <span class="number">31</span>            <span class="number">30</span>	</span><br></pre></td></tr></table></figure></div>

<ul>
<li>在阻塞信号集里，描述这个信号有没有被阻塞<ul>
<li>默认情况下没有信号是被阻塞的，因此信号对应的标志位的值是0</li>
<li>如果某个信号被设置为了阻塞状态，这个信号对应的标志位被设置为1</li>
</ul>
</li>
<li>在未决信号集里，描述信号是否处于未决状态<ul>
<li>如果这个信号被阻塞了，不能处理，这个信号对应的标志位被设置为1</li>
<li>如果这个信号的阻塞被解除了，未决信号集中的这个信号马上就被处理了，这个信号对应的标志位被为0</li>
<li>如果这个信号没有阻塞，信号产生之后直接被处理，因此不会在未决信号集中做任何记录</li>
</ul>
</li>
</ul>
<h4 id="信号集函数"><a href="#信号集函数" class="headerlink" title="信号集函数"></a>信号集函数</h4><div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">sigprocmask</span><span class="params">(<span class="type">int</span> how, <span class="type">const</span> <span class="type">sigset_t</span> *<span class="built_in">set</span>, <span class="type">sigset_t</span> *oldset)</span>;</span><br></pre></td></tr></table></figure></div>

<ul>
<li><p>参数</p>
<ul>
<li><p><code>how</code></p>
<ul>
<li><p><code>SIG_BLOCK</code>：将<code>set</code>集合中的数据追加到阻塞信号集中</p>
</li>
<li><p><code>SIG_UNBLOCK</code>：将<code>set</code>集合中的信号在阻塞信号集中解除阻塞</p>
</li>
<li><p><code>SIG_SETMASK</code>：将<code>set</code>集合中的数据覆盖内核的阻塞信号集数据</p>
</li>
</ul>
</li>
<li><p><code>set</code>：信号集</p>
</li>
<li><p><code>oldset</code>：将设置之前的阻塞信号集传出</p>
</li>
</ul>
</li>
<li><p>返回值：调用成功返回0，失败返回1</p>
</li>
</ul>
<blockquote>
<p>  初始化<code>sigset_t</code>类型的参数</p>
</blockquote>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将set集合中所有的标志位设置为0</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sigemptyset</span><span class="params">(<span class="type">sigset_t</span> *<span class="built_in">set</span>)</span>;</span><br><span class="line"><span class="comment">// 将set集合中所有的标志位设置为1</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sigfillset</span><span class="params">(<span class="type">sigset_t</span> *<span class="built_in">set</span>)</span>;</span><br><span class="line"><span class="comment">// 将set集合中某一个信号(signum)对应的标志位设置为1</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sigaddset</span><span class="params">(<span class="type">sigset_t</span> *<span class="built_in">set</span>, <span class="type">int</span> signum)</span>;</span><br><span class="line"><span class="comment">// 将set集合中某一个信号(signum)对应的标志位设置为0</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sigdelset</span><span class="params">(<span class="type">sigset_t</span> *<span class="built_in">set</span>, <span class="type">int</span> signum)</span>;</span><br><span class="line"><span class="comment">// 判断某个信号在集合中对应的标志位到底是0还是1, 如果是0返回0, 如果是1返回1</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sigismember</span><span class="params">(<span class="type">const</span> <span class="type">sigset_t</span> *<span class="built_in">set</span>, <span class="type">int</span> signum)</span>;</span><br></pre></td></tr></table></figure></div>

<blockquote>
<p>  设置某个信号阻塞，当该信号产生后，内核会将这个信号的未决状态记录到未决信号集中，当阻塞的信号被解除阻塞未决信号集中的信号随之被处理，内核再次修改未决信号集将该信号的状态修改为递达状态</p>
</blockquote>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 读一下这个集合就指定哪个信号是未决状态</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sigpending</span><span class="params">(<span class="type">sigset_t</span> *<span class="built_in">set</span>)</span>;</span><br></pre></td></tr></table></figure></div>

<p>演示：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdbool.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 初始化信号集</span></span><br><span class="line">    <span class="type">sigset_t</span> myset;</span><br><span class="line">    sigemptyset(&amp;myset);</span><br><span class="line">    <span class="comment">// 设置阻塞的信号</span></span><br><span class="line">    sigaddset(&amp;myset, SIGINT);  <span class="comment">// 2</span></span><br><span class="line">    sigaddset(&amp;myset, SIGQUIT); <span class="comment">// 3</span></span><br><span class="line">    sigaddset(&amp;myset, SIGKILL); <span class="comment">// 9 测试不能被阻塞</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将初始化的信号集中的数据设置给内核</span></span><br><span class="line">    <span class="type">sigset_t</span> old;</span><br><span class="line">    sigprocmask(SIG_BLOCK, &amp;myset, &amp;old);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 让进程一直运行, 在当前进程中产生对应的信号</span></span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="comment">// 读内核的未决信号集</span></span><br><span class="line">        <span class="type">sigset_t</span> curset;</span><br><span class="line">        sigpending(&amp;curset);</span><br><span class="line">        <span class="comment">// 遍历这个信号集</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;<span class="number">32</span>; ++i) &#123;</span><br><span class="line">            <span class="type">int</span> ret = sigismember(&amp;curset, i);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, ret);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">        i++;</span><br><span class="line">        <span class="keyword">if</span>(i==<span class="number">10</span>)</span><br><span class="line">            <span class="comment">// 解除阻塞, 重新设置阻塞信号集</span></span><br><span class="line">            <span class="comment">//sigprocmask(SIG_UNBLOCK, &amp;myset, NULL);</span></span><br><span class="line">            sigprocmask(SIG_SETMASK, &amp;old, <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>



<h3 id="信号捕捉"><a href="#信号捕捉" class="headerlink" title="信号捕捉"></a>信号捕捉</h3><blockquote>
<p>  Linux中的每个信号都会有对应的默认处理行为，如果想要忽略这个信号或者修改某个信号的默认行为就需要在程序中捕获该信号</p>
</blockquote>
<h4 id="signal"><a href="#signal" class="headerlink" title="signal"></a>signal</h4><p>使用<code>signal()</code>可以捕捉进程中产生的信号，并且修改捕捉到的函数的行为，这个信号的自定义处理动作是一个回调函数，内核通过<code>signal()</code>得到这个回调函数的地址，在信号产生之后该函数会被内核调用</p>
<div class="highlight-container" data-rel="D"><figure class="iseeu highlight d"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sighandler_t signal(<span class="keyword">int</span> signum, sighandler_t handler);   </span><br></pre></td></tr></table></figure></div>

<ul>
<li><p>参数</p>
<ul>
<li><p><code>signum</code>：需要捕捉的信号</p>
</li>
<li><p><code>handler</code>：信号捕捉之后的处理动作，是一个函数指针</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="title function_">void</span> <span class="params">(*<span class="type">sighandler_t</span>)</span><span class="params">(<span class="type">int</span>)</span>;</span><br></pre></td></tr></table></figure></div>

<blockquote>
<p>  该函数由我们编写，供内核调用</p>
</blockquote>
</li>
</ul>
</li>
</ul>
<h4 id="sigaction"><a href="#sigaction" class="headerlink" title="sigaction"></a>sigaction</h4> <div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">sigaction</span><span class="params">(<span class="type">int</span> signum, <span class="type">const</span> <span class="keyword">struct</span> sigaction *act, <span class="keyword">struct</span> sigaction *oldact)</span>;</span><br></pre></td></tr></table></figure></div>

<ul>
<li>参数<ul>
<li><code>signum</code>：要捕捉的信号</li>
<li><code>act</code>：捕捉到信号之后的处理动作</li>
<li><code>oldact</code>：上一次调用该函数进行信号捕捉设置的信号处理动作，一般指定为NULL</li>
</ul>
</li>
<li>返回值：调用成功返回0，失败返回1</li>
</ul>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> &#123;</span></span><br><span class="line">	<span class="type">void</span>     (*sa_handler)(<span class="type">int</span>);    <span class="comment">// 指向一个函数(回调函数)</span></span><br><span class="line">	<span class="type">void</span>     (*sa_sigaction)(<span class="type">int</span>, <span class="type">siginfo_t</span> *, <span class="type">void</span> *);</span><br><span class="line">	<span class="type">sigset_t</span>   sa_mask;             <span class="comment">// 初始化为空即可, 处理函数执行期间不屏蔽任何信号</span></span><br><span class="line">	<span class="type">int</span>        sa_flags;	        <span class="comment">// 0</span></span><br><span class="line">	<span class="type">void</span>     (*sa_restorer)(<span class="type">void</span>);  <span class="comment">//废弃</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>

<ul>
<li><code>sa_handler</code>：函数指针，指向的函数就是捕捉到的信号的处理动作</li>
<li><code>sa_sigaction</code>：函数指针，指向的函数就是捕捉到的信号的处理动作</li>
<li><code>sa_mask</code>：在信号处理函数执行期间，临时屏蔽某些信号，将要屏蔽的信号设置到集合中即可<ul>
<li>当前处理函数执行完毕，临时屏蔽自动解除</li>
<li>假设在这个集合中不屏蔽任何信号，默认也会屏蔽一个</li>
</ul>
</li>
<li><code>sa_flags</code>：使用哪个函数指针指向的函数处理捕捉到的信号<ul>
<li><code>0</code>：使用<code>sa_handler</code></li>
<li><code>SA_SIGINFO</code>：使用<code>sa_sigaction</code></li>
</ul>
</li>
<li><code>sa_restorer</code>：被废弃的成员</li>
</ul>
<h3 id="SIGCHLD信号"><a href="#SIGCHLD信号" class="headerlink" title="SIGCHLD信号"></a>SIGCHLD信号</h3><blockquote>
<p>  当子进程退出、暂停、从暂停恢复运行的时候，在子进程中会产生一个<code>SIGCHLD</code>信号，并将其发送给父进程，但是父进程收到这个信号默认就忽略了。我们可以在父进程成基于这个信号来回收子进程的资源</p>
</blockquote>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdbool.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">recycle</span><span class="params">(<span class="type">int</span> num)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;捕捉到的信号是: %d\n&quot;</span>, num);</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="type">pid_t</span> pid = waitpid(<span class="number">-1</span>, <span class="literal">NULL</span>, WNOHANG);</span><br><span class="line">        <span class="keyword">if</span>(pid &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;child died, pid = %d\n&quot;</span>, pid);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(pid == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 没有死亡的子进程, 直接退出当前循环</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(pid == <span class="number">-1</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;所有子进程都回收完毕了, 拜拜...\n&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 设置sigchld信号阻塞</span></span><br><span class="line">    <span class="type">sigset_t</span> myset;</span><br><span class="line">    sigemptyset(&amp;myset);</span><br><span class="line">    sigaddset(&amp;myset, SIGCHLD);</span><br><span class="line">    sigprocmask(SIG_BLOCK, &amp;myset, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 循环创建多个子进程 - 20</span></span><br><span class="line">    <span class="type">pid_t</span> pid;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">20</span>; ++i) &#123;</span><br><span class="line">        pid = fork();</span><br><span class="line">        <span class="keyword">if</span>(pid == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(pid == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;我是子进程, pid = %d\n&quot;</span>, getpid());</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(pid &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;我是父进程, pid = %d\n&quot;</span>, getpid());</span><br><span class="line">        <span class="comment">// 注册信号捕捉, 捕捉sigchld</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> <span class="title">act</span>;</span></span><br><span class="line">        act.sa_flags  =<span class="number">0</span>;</span><br><span class="line">        act.sa_handler = recycle;</span><br><span class="line">        sigemptyset(&amp;act.sa_mask);</span><br><span class="line">        </span><br><span class="line">        sigaction(SIGCHLD, &amp;act, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 解除sigcld信号的阻塞</span></span><br><span class="line">        sigprocmask(SIG_UNBLOCK, &amp;myset, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">            sleep(<span class="number">100</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>





<h2 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h2><h3 id="线程概述"><a href="#线程概述" class="headerlink" title="线程概述"></a>线程概述</h3><blockquote>
<p>  线程是轻量级的进程，在Linux下线程的本质仍然是进程</p>
<p>  <code>进程是资源分配的最小单位，线程是操作系统调度执行的最小单位</code></p>
</blockquote>
<ul>
<li><p>进程有自己独立的地址空间，多个线程共用一个地址空间</p>
<ul>
<li>线程更加节省系统资源，效率可能会更高</li>
<li>在一个地址空间中多个线程独享：每个线程都有属于自己的栈区、寄存器</li>
<li>在一个地址空间中多个线程共享：代码段、堆区、全局数据区、文件描述符表都是线程共享的</li>
</ul>
</li>
<li><p>线程是程序的最小执行单位，进程是操作系统中最小的资源分配单位</p>
<ul>
<li>每个进程对应一个虚拟地址空间，一个进程只能抢一个CPU时间片</li>
<li>一个地址空间中可以划分出多个线程，在有效的资源基础上，能够抢更多的CPU时间</li>
</ul>
</li>
<li><p>CPU的调度和切换：线程的上下文切换比进程要快的多</p>
<blockquote>
<p>  任务从保存到再次加载这个过程就是一次上下文切换</p>
</blockquote>
</li>
<li><p>线程更加廉价，启动速度快，退出也快，对系统的资源冲击小</p>
</li>
</ul>
<p>合理控制线程的个数：</p>
<ol>
<li>文件IO操作：线程个数 &#x3D; 2 * CPU核心数</li>
<li>复杂算法：线程个数 &#x3D; CPU核心数</li>
</ol>
<h3 id="创建线程"><a href="#创建线程" class="headerlink" title="创建线程"></a>创建线程</h3><h4 id="线程函数"><a href="#线程函数" class="headerlink" title="线程函数"></a>线程函数</h4><blockquote>
<p>  每个线程都有一个唯一的线程ID，ID类型为<code>pthread_t</code></p>
</blockquote>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">pthread_t</span> <span class="title function_">pthread_self</span><span class="params">(<span class="type">void</span>)</span>;	<span class="comment">// 获取当前线程的线程ID</span></span><br></pre></td></tr></table></figure></div>

<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_create</span><span class="params">(<span class="type">pthread_t</span> *thread, <span class="type">const</span> <span class="type">pthread_attr_t</span> *attr,</span></span><br><span class="line"><span class="params">                   <span class="type">void</span> *(*start_routine) (<span class="type">void</span> *), <span class="type">void</span> *arg)</span>; <span class="comment">// 创建线程</span></span><br></pre></td></tr></table></figure></div>

<ul>
<li>参数<ul>
<li><code>thread</code>：传出参数，线程创建成功会将线程ID写入到这个指针指向的内存</li>
<li><code>attr</code>：线程的属性，一般情况下使用默认属性，NULL</li>
<li><code>start_routine</code>：函数指针，创建的子进程的处理动作，也就是该函数在子线程中指向</li>
<li><code>arg</code>：作为实参传递到<code>start_routine</code>指针指向的函数内部</li>
</ul>
</li>
<li>返回值：线程创建成功返回0，创建失败返回对应的错误号</li>
</ul>
<h4 id="创建线程-1"><a href="#创建线程-1" class="headerlink" title="创建线程"></a>创建线程</h4><div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span>* <span class="title function_">working</span><span class="params">(<span class="type">void</span>* arg)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;我是子线程, 线程ID: %ld\n&quot;</span>, pthread_self());</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">9</span>; ++i)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;child == i: = %d\n&quot;</span>, i);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">pthread_t</span> tid;</span><br><span class="line">    pthread_create(&amp;tid, <span class="literal">NULL</span>, working, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;子线程创建成功, 线程ID: %ld\n&quot;</span>, tid);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;我是主线程, 线程ID: %ld\n&quot;</span>, pthread_self());</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">3</span>; ++i)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;i = %d\n&quot;</span>, i);</span><br><span class="line">    </span><br><span class="line">    sleep(<span class="number">1</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<blockquote>
<p>  虚拟地址空间的生命周期和主线程是一样的，与子线程无关</p>
</blockquote>
<h3 id="线程退出"><a href="#线程退出" class="headerlink" title="线程退出"></a>线程退出</h3><p>线程退出而虚拟地址空间不释放（针对主线程），使用线程退出函数</p>
<p><code>只要调用该函数线程马上退出，不会影响到其它线程的正常运行，不管在子线程或者主线程都可以使用</code></p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">pthread_exit</span><span class="params">(<span class="type">void</span> *retval)</span>;</span><br></pre></td></tr></table></figure></div>

<ul>
<li>参数：线程退出时携带的数据，当前子线程的主线程会得到该数据，不需要就指定为NULL</li>
</ul>
<h3 id="线程回收"><a href="#线程回收" class="headerlink" title="线程回收"></a>线程回收</h3><h4 id="线程函数-1"><a href="#线程函数-1" class="headerlink" title="线程函数"></a>线程函数</h4><p>线程和进程一样，子线程退出的时候其内核资源主要由主线程回收，线程库中提供的线程回收函数叫做<code>pthread_join()</code>，这个函数是一个阻塞函数，如果还有子线程在运行，调用该函数就会阻塞，子线程退出函数解除阻塞进行资源的回收，函数被调用一次，只能回收一个子线程，如果有多个子线程则需要循环进行回收</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">pthread_join</span><span class="params">(<span class="type">pthread_t</span> thread, <span class="type">void</span> **retval)</span>;</span><br></pre></td></tr></table></figure></div>

<ul>
<li>参数：<ul>
<li><code>pthread</code>：要被回收的子线程的进程ID</li>
<li><code>retval</code>：二级指针，指向一级指针的地址，是一个传出参数，这个地址中存储了<code>pthread_exit()</code>传递出的数据，如果不需要就指定为NULL</li>
</ul>
</li>
<li>返回值：线程回收成功返回0，回收失败返回错误号</li>
</ul>
<h4 id="回收子线程数据"><a href="#回收子线程数据" class="headerlink" title="回收子线程数据"></a>回收子线程数据</h4><blockquote>
<p>  在子线程退出的时候可以使用<code>pthread_exit()</code>的参数将数据传出，在回收这个子线程的时候通过<code>pthread_join()</code>的第二个参数来接收子线程传递的数据</p>
</blockquote>
<ul>
<li>使用子线程栈</li>
</ul>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Persion</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">int</span> id;</span><br><span class="line">    <span class="type">char</span> name[<span class="number">36</span>];</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span>* <span class="title function_">working</span><span class="params">(<span class="type">void</span>* arg)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;我是子线程, 线程ID: %ld\n&quot;</span>, pthread_self());</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">9</span>; ++i) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;child == i: = %d\n&quot;</span>, i);</span><br><span class="line">        <span class="keyword">if</span>(i == <span class="number">6</span>) &#123;</span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">Persion</span> <span class="title">p</span>;</span></span><br><span class="line">            p.age = <span class="number">12</span>;</span><br><span class="line">            <span class="built_in">strcpy</span>(p.name, <span class="string">&quot;tom&quot;</span>);</span><br><span class="line">            p.id = <span class="number">100</span>;</span><br><span class="line">            <span class="comment">// 传递给主线程的pthread_join()</span></span><br><span class="line">            pthread_exit(&amp;p);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">pthread_t</span> tid;</span><br><span class="line">    pthread_create(&amp;tid, <span class="literal">NULL</span>, working, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;子线程创建成功, 线程ID: %ld\n&quot;</span>, tid);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;我是主线程, 线程ID: %ld\n&quot;</span>, pthread_self());</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; ++i)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;i = %d\n&quot;</span>, i);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 阻塞等待子线程退出</span></span><br><span class="line">    <span class="type">void</span>* ptr = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">// 这个内存地址就是pthread_exit() 参数指向的内存</span></span><br><span class="line">    pthread_join(tid, &amp;ptr);</span><br><span class="line">    <span class="comment">// 打印信息</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Persion</span>* <span class="title">pp</span> =</span> (<span class="keyword">struct</span> Persion*)ptr;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;子线程返回数据: name: %s, age: %d, id: %d\n&quot;</span>, pp-&gt;name, pp-&gt;age, pp-&gt;id);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;子线程资源被成功回收...\n&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<blockquote>
<p>  如果多个线程共用一个虚拟地址空间，每个线程在栈区都有一块属于自己的内存，相当于栈区被这几个线程平分了，当线程退出，线程在栈区的内存也就被回收了，因此随着子线程的退出，写入到栈区的数据也就被释放了</p>
</blockquote>
<ul>
<li>使用全局变量</li>
</ul>
<blockquote>
<p>  位于同一虚拟地址空间的线程，虽然不能共享栈区数据，但是可以共享全局数据区和堆区数据，子进程在退出的时候可以将数据存储到全局变量中、静态变量或者堆内存中</p>
</blockquote>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Persion</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">int</span> id;</span><br><span class="line">    <span class="type">char</span> name[<span class="number">36</span>];</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Persion</span> <span class="title">p</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span>* <span class="title function_">working</span><span class="params">(<span class="type">void</span>* arg)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;我是子线程, 线程ID: %ld\n&quot;</span>, pthread_self());</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">9</span>; ++i) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;child == i: = %d\n&quot;</span>, i);</span><br><span class="line">        <span class="keyword">if</span>(i == <span class="number">6</span>) &#123;</span><br><span class="line">            p.age = <span class="number">12</span>;</span><br><span class="line">            <span class="built_in">strcpy</span>(p.name, <span class="string">&quot;tom&quot;</span>);</span><br><span class="line">            p.id = <span class="number">100</span>;</span><br><span class="line">            pthread_exit(&amp;p);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">pthread_t</span> tid;</span><br><span class="line">    pthread_create(&amp;tid, <span class="literal">NULL</span>, working, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;子线程创建成功, 线程ID: %ld\n&quot;</span>, tid);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;我是主线程, 线程ID: %ld\n&quot;</span>, pthread_self());</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">3</span>; ++i)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;i = %d\n&quot;</span>, i);</span><br><span class="line">    </span><br><span class="line">	<span class="type">void</span>* ptr = <span class="literal">NULL</span>;</span><br><span class="line">    pthread_join(tid, &amp;ptr);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Persion</span>* <span class="title">pp</span> =</span> (<span class="keyword">struct</span> Persion*)ptr;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;name: %s, age: %d, id: %d\n&quot;</span>, pp-&gt;name, pp-&gt;age, pp-&gt;id);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;子线程资源被成功回收...\n&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<ul>
<li>使用主线程栈</li>
</ul>
<blockquote>
<p>  位于同一个地址空间的多个线程可以相互访问对方栈空间上的数据，主线程一般最后退出，我们可以将子线程返回的数据保存到主线程的栈区内存中：</p>
</blockquote>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Persion</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">int</span> id;</span><br><span class="line">    <span class="type">char</span> name[<span class="number">36</span>];</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span>* <span class="title function_">working</span><span class="params">(<span class="type">void</span>* arg)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Persion</span>* <span class="title">p</span> =</span> (<span class="keyword">struct</span> Persion*)arg;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;我是子线程, 线程ID: %ld\n&quot;</span>, pthread_self());</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">9</span>; ++i) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;child == i: = %d\n&quot;</span>, i);</span><br><span class="line">        <span class="keyword">if</span>(i == <span class="number">6</span>) &#123;</span><br><span class="line">            p-&gt;age  =<span class="number">12</span>;</span><br><span class="line">            <span class="built_in">strcpy</span>(p-&gt;name, <span class="string">&quot;tom&quot;</span>);</span><br><span class="line">            p-&gt;id = <span class="number">100</span>;</span><br><span class="line">            pthread_exit(p);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">pthread_t</span> tid;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Persion</span> <span class="title">p</span>;</span></span><br><span class="line">    pthread_create(&amp;tid, <span class="literal">NULL</span>, working, &amp;p);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;子线程创建成功, 线程ID: %ld\n&quot;</span>, tid);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;我是主线程, 线程ID: %ld\n&quot;</span>, pthread_self());</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">3</span>; ++i)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;i = %d\n&quot;</span>, i);</span><br><span class="line"></span><br><span class="line">    <span class="type">void</span>* ptr = <span class="literal">NULL</span>;</span><br><span class="line">    pthread_join(tid, &amp;ptr);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;name: %s, age: %d, id: %d\n&quot;</span>, p.name, p.age, p.id);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;子线程资源被成功回收...\n&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>



<h3 id="线程分离"><a href="#线程分离" class="headerlink" title="线程分离"></a>线程分离</h3><blockquote>
<p>  某些情况下，主线程有属于自己的业务处理流程，如果让主线程负责子线程的资源回收，调用<code>pthread_join()</code>，子线程不退出主线程就一直被阻塞，主线程任务就不能执行了</p>
</blockquote>
<p>调用<code>pthread_detach()</code>线程分离函数之后，子线程和主线程分离，当子线程退出的时候，其占用的内核资源就被系统其它进程接管并回收了。线程分离之后在主线程中使用<code>pthread_join()</code>就回收不到子线程资源了</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">pthread_detach</span><span class="params">(<span class="type">pthread_t</span> thread)</span>;</span><br></pre></td></tr></table></figure></div>

<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span>* <span class="title function_">working</span><span class="params">(<span class="type">void</span>* arg)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;我是子线程, 线程ID: %ld\n&quot;</span>, pthread_self());</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">9</span>; ++i)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;child == i: = %d\n&quot;</span>, i);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">pthread_t</span> tid;</span><br><span class="line">    pthread_create(&amp;tid, <span class="literal">NULL</span>, working, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;子线程创建成功, 线程ID: %ld\n&quot;</span>, tid);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;我是主线程, 线程ID: %ld\n&quot;</span>, pthread_self());</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; ++i)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;i = %d\n&quot;</span>, i);</span><br><span class="line"></span><br><span class="line">    pthread_detach(tid);</span><br><span class="line">    pthread_exit(<span class="literal">NULL</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>



<h3 id="其它线程函数"><a href="#其它线程函数" class="headerlink" title="其它线程函数"></a>其它线程函数</h3><h4 id="线程取消"><a href="#线程取消" class="headerlink" title="线程取消"></a>线程取消</h4><blockquote>
<p>  线程取消就是在一个线程中杀死另一个线程</p>
<ul>
<li>在线程A中调用线程取消函数<code>pthread_cancel</code>，指定杀死线程B，这时候线程B还没死</li>
<li>在线程B中进行一次系统调用（从用户区切换到内核区），否则线程B可以一直运行</li>
</ul>
</blockquote>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">pthread_cancel</span><span class="params">(<span class="type">pthread_t</span> thread)</span>;</span><br></pre></td></tr></table></figure></div>

<ul>
<li>参数：要杀死的线程的线程ID</li>
<li>返回值：调用成功返回0，调用失败返回错误号</li>
</ul>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span>* <span class="title function_">working</span><span class="params">(<span class="type">void</span>* arg)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> j = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">9</span>; ++i)</span><br><span class="line">        j++;</span><br><span class="line">    <span class="comment">// 系统调用</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;我是子线程, 线程ID: %ld\n&quot;</span>, pthread_self());</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">9</span>; ++i)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot; child i: %d\n&quot;</span>, i);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">pthread_t</span> tid;</span><br><span class="line">    pthread_create(&amp;tid, <span class="literal">NULL</span>, working, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;子线程创建成功, 线程ID: %ld\n&quot;</span>, tid);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;我是主线程, 线程ID: %ld\n&quot;</span>, pthread_self());</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; ++i)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;i = %d\n&quot;</span>, i);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 子线程中做系统调用, 子线程就结束了</span></span><br><span class="line">    pthread_cancel(tid);</span><br><span class="line">    pthread_exit(<span class="literal">NULL</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<blockquote>
<ul>
<li>直接调用Linux系统函数</li>
<li>调用标准C库函数，为了实现某些功能，在Linux平台下标准C库函数会调用相关的系统函数</li>
</ul>
</blockquote>
<h4 id="线程ID比较"><a href="#线程ID比较" class="headerlink" title="线程ID比较"></a>线程ID比较</h4><blockquote>
<p>  由于跨平台的原因，使用线程比较函数来比较两个线程ID</p>
</blockquote>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">pthread_equal</span><span class="params">(<span class="type">pthread_t</span> t1, <span class="type">pthread_t</span> t2)</span>;</span><br></pre></td></tr></table></figure></div>

<ul>
<li>参数：要比较线程的线程ID</li>
<li>返回值：两个线程ID相等返回非0，不相等返回0</li>
</ul>
<h2 id="线程同步"><a href="#线程同步" class="headerlink" title="线程同步"></a>线程同步</h2><p>所谓同步并不是多个线程同时对内存进行访问，而是按照先后顺序依次进行</p>
<h3 id="线程同步概念"><a href="#线程同步概念" class="headerlink" title="线程同步概念"></a>线程同步概念</h3><h4 id="为什么要同步"><a href="#为什么要同步" class="headerlink" title="为什么要同步"></a>为什么要同步</h4><p>如果线程 A 执行这个过程期间就失去了 CPU 时间片，线程 A 被挂起了最新的数据没能更新到物理内存。线程 B 变成运行态之后从物理内存读数据，很显然它没有拿到最新数据，只能基于旧的数据往后数，然后失去 CPU 时间片挂起。线程 A 得到 CPU 时间片变成运行态，第一件事儿就是将上次没更新到内存的数据更新到内存，但是这样会导致线程 B 已经更新到内存的数据被覆盖，活儿白干了，最终导致有些数据会被重复数很多次。</p>
<h4 id="同步方式"><a href="#同步方式" class="headerlink" title="同步方式"></a>同步方式</h4><blockquote>
<p>  对于多线程访问共享数据出现数据混乱的问题，需要进行线程同步。常用的线程同步方式有四种：互斥锁、读写锁、条件变量、信号量</p>
</blockquote>
<p>共享资源也称为临界资源，结合上下文代码，得到临界区</p>
<ul>
<li><p>在临界区上边添加加锁函数，对临界区加锁</p>
<blockquote>
<p>  哪个线程调用，就会把这把锁锁上，其它线程就只能阻塞在锁上了</p>
</blockquote>
</li>
<li><p>在临界区的下边添加解锁函数，对临界区解锁</p>
<blockquote>
<p>  出临界区的线程会将锁定的那把锁打开，其他抢到锁的线程就可以进入到临界区</p>
</blockquote>
</li>
<li><p>通过锁机制能保证临界区代码最多只能同时有一个线程访问，这样并行访问就变成串行访问了</p>
</li>
</ul>
<h3 id="互斥锁"><a href="#互斥锁" class="headerlink" title="互斥锁"></a>互斥锁</h3><h4 id="互斥锁函数"><a href="#互斥锁函数" class="headerlink" title="互斥锁函数"></a>互斥锁函数</h4><blockquote>
<p>  好处解决共享资源混乱，坏处效率降低，并行变串行</p>
</blockquote>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">pthread_mutex_t</span>  mutex; <span class="comment">// 互斥锁类型</span></span><br></pre></td></tr></table></figure></div>

<p>一般情况下每一个共享数据对应一把互斥锁，锁的个数和线程的个数无关</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 初始化互斥锁</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_mutex_init</span><span class="params">(<span class="type">pthread_mutex_t</span> *<span class="keyword">restrict</span> mutex,</span></span><br><span class="line"><span class="params">           <span class="type">const</span> <span class="type">pthread_mutexattr_t</span> *<span class="keyword">restrict</span> attr)</span>;</span><br><span class="line"><span class="comment">// 释放互斥锁资源            </span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_mutex_destroy</span><span class="params">(<span class="type">pthread_mutex_t</span> *mutex)</span>;</span><br></pre></td></tr></table></figure></div>

<ul>
<li>参数：<code>mutex</code>：互斥锁变量的地址，<code>attr</code>：互斥锁的属性，一般默认NULL</li>
</ul>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">pthread_mutex_lock</span><span class="params">(<span class="type">pthread_mutex_t</span> *mutex)</span>; <span class="comment">// 加锁</span></span><br></pre></td></tr></table></figure></div>

<p>首先会判断<code>mutex</code>互斥锁中的状态是不是锁定状态</p>
<ul>
<li>没有被锁定，是打开的吗，这个线程可以加锁成功，这个锁会记录是哪个线程加锁成功</li>
<li>被锁定了，其他线程加锁失败，这些线程都会阻塞在这把锁上</li>
<li>当这把锁被解开之后，这些阻塞在锁上的线程就解除阻塞了，并且这些线程是通过竞争的方式对这把锁加锁，没抢到锁的进程继续阻塞</li>
</ul>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">pthread_mutex_trylock</span><span class="params">(<span class="type">pthread_mutex_t</span> *mutex)</span>; <span class="comment">// 尝试加锁</span></span><br></pre></td></tr></table></figure></div>

<ul>
<li>没有被锁定，线程加锁成功</li>
<li>被锁定了，调用该函数的线程不会被阻塞，加锁失败直接返回错误号</li>
</ul>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">pthread_mutex_unlock</span><span class="params">(<span class="type">pthread_mutex_t</span> *mutex)</span>; <span class="comment">// 对互斥锁解锁</span></span><br></pre></td></tr></table></figure></div>

<ul>
<li>哪个线程加的锁，哪个线程才能解锁</li>
</ul>
<h4 id="互斥锁使用"><a href="#互斥锁使用" class="headerlink" title="互斥锁使用"></a>互斥锁使用</h4><div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX 100</span></span><br><span class="line"><span class="type">int</span> number;</span><br><span class="line"><span class="type">pthread_mutex_t</span> mutex;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span>* <span class="title function_">funcA_num</span><span class="params">(<span class="type">void</span>* arg)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; MAX; ++i) &#123;</span><br><span class="line">        pthread_mutex_lock(&amp;mutex);</span><br><span class="line">        <span class="type">int</span> cur = number;</span><br><span class="line">        cur++;</span><br><span class="line">        usleep(<span class="number">10</span>);</span><br><span class="line">        number = cur;</span><br><span class="line">        pthread_mutex_unlock(&amp;mutex);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Thread A, id = %lu, number = %d\n&quot;</span>, pthread_self(), number);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span>* <span class="title function_">funcB_num</span><span class="params">(<span class="type">void</span>* arg)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; MAX; ++i) &#123;</span><br><span class="line">        pthread_mutex_lock(&amp;mutex);</span><br><span class="line">        <span class="type">int</span> cur = number;</span><br><span class="line">        cur++;</span><br><span class="line">        number = cur;</span><br><span class="line">        pthread_mutex_unlock(&amp;mutex);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Thread B, id = %lu, number = %d\n&quot;</span>, pthread_self(), number);</span><br><span class="line">        usleep(<span class="number">5</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span>* argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">pthread_t</span> p1, p2;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化互斥锁</span></span><br><span class="line">    pthread_mutex_init(&amp;mutex, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建两个子线程</span></span><br><span class="line">    pthread_create(&amp;p1, <span class="literal">NULL</span>, funcA_num, <span class="literal">NULL</span>);</span><br><span class="line">    pthread_create(&amp;p2, <span class="literal">NULL</span>, funcB_num, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 阻塞，资源回收</span></span><br><span class="line">    pthread_join(p1, <span class="literal">NULL</span>);</span><br><span class="line">    pthread_join(p2, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 销毁互斥锁</span></span><br><span class="line">    <span class="comment">// 线程销毁之后, 再去释放互斥锁</span></span><br><span class="line">    pthread_mutex_destroy(&amp;mutex);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>



<h3 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h3><blockquote>
<p>  如果线程死锁：所有的线程都被阻塞，并且线程的阻塞是无法解开的</p>
</blockquote>
<p><strong>造成死锁的场景有以下几种：</strong></p>
<ul>
<li><p>加锁之后忘记解锁</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">func</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">   	pthread_mutex_lock(&amp;mutex);</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 忘记解锁</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">func</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	...</span><br><span class="line">    pthread_mutex_lock(&amp;mutex);</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">if</span>(xxx)</span><br><span class="line">    	<span class="keyword">return</span> ; <span class="comment">// 函数提前终止了</span></span><br><span class="line">        </span><br><span class="line">    pthread_mutex_lock(&amp;mutex);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
</li>
<li><p>重复加锁，造成死锁</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">func</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    pthread_mutex_lock(&amp;mutex);</span><br><span class="line">    pthread_mutex_lock(&amp;mutex);</span><br><span class="line">   	....</span><br><span class="line">    pthread_mutex_unlock(&amp;mutex);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
</li>
<li><p>在程序中有多个共享资源，因此有很多把锁，随意加锁，导致互相被阻塞</p>
</li>
</ul>
<p><strong>在使用多线程时，如何避免死锁呢</strong></p>
<ul>
<li>避免多次加锁</li>
<li>对共享资源访问完毕之后，一定要解锁，或者在加锁时使用<code>trylock</code></li>
<li>如果程序中有多把锁，可以控制对锁的访问顺序（顺序访问共享资源，但在有些情况下做不到），也可以在对其他互斥锁做加锁操作之前，先释放当前线程拥有的互斥锁</li>
<li>项目程序中可以引入一些专门用于死锁检测的模块</li>
</ul>
<h3 id="读写锁"><a href="#读写锁" class="headerlink" title="读写锁"></a>读写锁</h3><h4 id="读写锁函数"><a href="#读写锁函数" class="headerlink" title="读写锁函数"></a>读写锁函数</h4><blockquote>
<p>  读写锁是互斥锁的升级版，在做读写操作的时候可以提高程序的执行效率，如果所有的线程都是做读操作，那么读是并行的，但是使用互斥锁，读操作是串行的</p>
</blockquote>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">pthread_rwlock_t</span> rwlock;</span><br></pre></td></tr></table></figure></div>

<p>该锁既可以锁定读操作，也可以锁定写操作</p>
<ul>
<li>锁的状态：锁定 &#x2F; 打开</li>
<li>锁定的是什么操作：读操作 &#x2F; 写操作，使用读写锁锁定了读操作，需要先解锁才能去锁定写操作，反之亦然</li>
<li>哪个线程将这把锁锁上了</li>
</ul>
<p><strong>读写锁的特点：</strong></p>
<ul>
<li>使用读写锁的读锁锁定了临界区，线程对临界区的访问是并行的，读锁是共享的</li>
<li>使用读写锁的写锁锁定了临界区，线程对临界区的访问是串行的，写锁是独占的</li>
<li>使用读写锁分别对两个临界区加了读锁和写锁，两个线程要同时访问这两个临界区，访问写锁临界区的线程继续执行，访问读锁临界区的线程阻塞，<code>写锁比读锁的优先级高</code></li>
</ul>
<p>对共享资源有读有写，并且对共享资源的读操作更多，读写锁会更有优势</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">pthread_rwlock_t</span> rwlock;</span><br><span class="line"><span class="comment">// 初始化读写锁</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_rwlock_init</span><span class="params">(<span class="type">pthread_rwlock_t</span> *<span class="keyword">restrict</span> rwlock,</span></span><br><span class="line"><span class="params">           <span class="type">const</span> <span class="type">pthread_rwlockattr_t</span> *<span class="keyword">restrict</span> attr)</span>;</span><br><span class="line"><span class="comment">// 释放读写锁占用的系统资源</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_rwlock_destroy</span><span class="params">(<span class="type">pthread_rwlock_t</span> *rwlock)</span>;</span><br></pre></td></tr></table></figure></div>

<ul>
<li>参数：<code>rwlock</code>：读写锁的地址（传出参数），<code>attr</code>：读写锁属性，一般使用默认属性（NULL）</li>
</ul>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在程序中对读写锁加读锁, 锁定的是读操作</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_rwlock_rdlock</span><span class="params">(<span class="type">pthread_rwlock_t</span> *rwlock)</span>;</span><br><span class="line"><span class="comment">// 这个函数可以有效的避免死锁</span></span><br><span class="line"><span class="comment">// 如果加读锁失败, 不会阻塞当前线程, 直接返回错误号</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_rwlock_tryrdlock</span><span class="params">(<span class="type">pthread_rwlock_t</span> *rwlock)</span>;</span><br></pre></td></tr></table></figure></div>

<ul>
<li>如果读写锁是打开的，加锁成功；如果读写锁锁定了读操作，调用该函数仍可以加锁成功，因为读锁是共享的；如果读写锁已经锁定了写操作，调用这个函数的线程会被阻塞</li>
<li>与第一个函数的区别在于：如果读写锁已经锁定了写操作，调用这个函数加锁失败，对应线程不会被阻塞，可以在程序中对函数返回值进行判断，添加加锁失败后的处理动作</li>
</ul>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在程序中对读写锁加写锁, 锁定的是写操作</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_rwlock_wrlock</span><span class="params">(<span class="type">pthread_rwlock_t</span> *rwlock)</span>;</span><br><span class="line"><span class="comment">// 这个函数可以有效的避免死锁</span></span><br><span class="line"><span class="comment">// 如果加写锁失败, 不会阻塞当前线程, 直接返回错误号</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_rwlock_trywrlock</span><span class="params">(<span class="type">pthread_rwlock_t</span> *rwlock)</span>;</span><br></pre></td></tr></table></figure></div>

<ul>
<li>如果读写锁是打开的，加锁成功；如果读写锁已经锁定了读操作或者写操作，调用该函数的线程会被阻塞</li>
<li>与第一个函数的区别在于：如果读写锁已经锁定了读操作或者锁定了写操作，调用这个函数加锁失败，但是线程不会阻塞，可以在程序中对函数返回值进行判断，添加加锁失败之后的处理动作</li>
</ul>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 解锁, 不管锁定了读还是写都可用解锁</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_rwlock_unlock</span><span class="params">(<span class="type">pthread_rwlock_t</span> *rwlock)</span>;</span><br></pre></td></tr></table></figure></div>

<h4 id="读写锁使用"><a href="#读写锁使用" class="headerlink" title="读写锁使用"></a>读写锁使用</h4><blockquote>
<p>  8个线程操作同一个全局变量，3个线程不定时写同一全局资源，5个线程不定时读同一全局资源</p>
</blockquote>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdbool.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> number = <span class="number">0</span>;</span><br><span class="line"><span class="type">pthread_rwlock_t</span> rwlock;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span>* <span class="title function_">writeNum</span><span class="params">(<span class="type">void</span>* arg)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">        pthread_rwlock_wrlock(&amp;rwlock);</span><br><span class="line">        <span class="type">int</span> cur = number;</span><br><span class="line">        cur ++;</span><br><span class="line">        number = cur;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;++写操作完毕, number : %d, tid = %ld\n&quot;</span>, number, pthread_self());</span><br><span class="line">        pthread_rwlock_unlock(&amp;rwlock);</span><br><span class="line">        <span class="comment">// 添加sleep目的是要看到多个线程交替工作</span></span><br><span class="line">        usleep(rand() % <span class="number">100</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span>* <span class="title function_">readNum</span><span class="params">(<span class="type">void</span>* arg)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">        pthread_rwlock_rdlock(&amp;rwlock);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;--全局变量number = %d, tid = %ld\n&quot;</span>, number, pthread_self());</span><br><span class="line">        pthread_rwlock_unlock(&amp;rwlock);</span><br><span class="line">        usleep(rand() % <span class="number">100</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    pthread_rwlock_init(&amp;rwlock, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3个写线程, 5个读的线程</span></span><br><span class="line">    <span class="type">pthread_t</span> wtid[<span class="number">3</span>];</span><br><span class="line">    <span class="type">pthread_t</span> rtid[<span class="number">5</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; ++i)</span><br><span class="line">        pthread_create(&amp;wtid[i], <span class="literal">NULL</span>, writeNum, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; ++i)</span><br><span class="line">        pthread_create(&amp;rtid[i], <span class="literal">NULL</span>, readNum, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放资源</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; ++i)</span><br><span class="line">        pthread_join(wtid[i], <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; ++i)</span><br><span class="line">        pthread_join(rtid[i], <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 销毁读写锁</span></span><br><span class="line">    pthread_rwlock_destroy(&amp;rwlock);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>



<h3 id="条件变量"><a href="#条件变量" class="headerlink" title="条件变量"></a>条件变量</h3><h4 id="条件变量函数"><a href="#条件变量函数" class="headerlink" title="条件变量函数"></a>条件变量函数</h4><blockquote>
<p>  严格意义上条件变量不是处理线程同步，而是进行线程的阻塞。如果在多线程程序中只使用条件变量无法实现线程的同步，必须要配合互斥锁来使用；条件变量和互斥锁都能阻塞线程，二者区别如下：</p>
</blockquote>
<ul>
<li>互斥锁是一个线程加锁，其它所有线程阻塞</li>
<li>条件变量是满足条件才阻塞，条件不满足多个线程是可以同时进入临界区的</li>
</ul>
<p><strong>一般情况下条件变量用于处理生产者和消费者模型，并且配合互斥锁使用</strong></p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">pthread_cond_t</span> cond;</span><br></pre></td></tr></table></figure></div>

<blockquote>
<p>  被条件变量阻塞的线程的线程信息会被记录到这个变量中，以便在解除阻塞的时候使用</p>
</blockquote>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">pthread_cond_t</span> cond;</span><br><span class="line"><span class="comment">// 初始化</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_cond_init</span><span class="params">(<span class="type">pthread_cond_t</span> *<span class="keyword">restrict</span> cond,</span></span><br><span class="line"><span class="params">      <span class="type">const</span> <span class="type">pthread_condattr_t</span> *<span class="keyword">restrict</span> attr)</span>;</span><br><span class="line"><span class="comment">// 销毁释放资源        </span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_cond_destroy</span><span class="params">(<span class="type">pthread_cond_t</span> *cond)</span>;</span><br></pre></td></tr></table></figure></div>

<ul>
<li>参数：<code>cond</code>：条件变量的地址，<code>attr</code>：条件变量的属性（默认NULL）</li>
</ul>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 线程阻塞函数, 哪个线程调用这个函数, 哪个线程就会被阻塞</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_cond_wait</span><span class="params">(<span class="type">pthread_cond_t</span> *<span class="keyword">restrict</span> cond, <span class="type">pthread_mutex_t</span> *<span class="keyword">restrict</span> mutex)</span>;</span><br></pre></td></tr></table></figure></div>

<p>该函数需要一个互斥锁参数，这个互斥锁主要用于线程同步，让线程顺利进入临界区，避免出现共享资源的数据混乱</p>
<ol>
<li>在阻塞线程时，如果线程已经对互斥锁mutex上锁，那么会将这把锁打开，避免死锁</li>
<li>当线程解除阻塞的时候，函数内部会帮助这个线程再次将这个mutex互斥锁锁上，继续向下访问临界区</li>
</ol>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 表示的时间是从1971.1.1到某个时间点的时间, 总长度使用秒/纳秒表示</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">timespec</span> &#123;</span></span><br><span class="line">	<span class="type">time_t</span> tv_sec;      <span class="comment">/* Seconds */</span></span><br><span class="line">	<span class="type">long</span>   tv_nsec;     <span class="comment">/* Nanoseconds [0 .. 999999999] */</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 将线程阻塞一定的时间长度, 时间到达之后, 线程就解除阻塞了</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_cond_timedwait</span><span class="params">(<span class="type">pthread_cond_t</span> *<span class="keyword">restrict</span> cond,</span></span><br><span class="line"><span class="params">           <span class="type">pthread_mutex_t</span> *<span class="keyword">restrict</span> mutex, <span class="type">const</span> <span class="keyword">struct</span> timespec *<span class="keyword">restrict</span> abstime)</span>;</span><br></pre></td></tr></table></figure></div>

<p>第三个参数表示线程阻塞的时长</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">time_t</span> mytim = time(<span class="literal">NULL</span>);	<span class="comment">// 1970.1.1 0:0:0 到当前的总秒数</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">timespec</span> <span class="title">tmsp</span>;</span></span><br><span class="line">tmsp.tv_nsec = <span class="number">0</span>;</span><br><span class="line">tmsp.tv_sec = time(<span class="literal">NULL</span>) + <span class="number">100</span>;	<span class="comment">// 线程阻塞100s</span></span><br></pre></td></tr></table></figure></div>

<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 唤醒阻塞在条件变量上的线程, 至少有一个被解除阻塞</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_cond_signal</span><span class="params">(<span class="type">pthread_cond_t</span> *cond)</span>;</span><br><span class="line"><span class="comment">// 唤醒阻塞在条件变量上的线程, 被阻塞的线程全部解除阻塞</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_cond_broadcast</span><span class="params">(<span class="type">pthread_cond_t</span> *cond)</span>;</span><br></pre></td></tr></table></figure></div>

<p>调用上面两个函数中的任意一个，都可以唤醒被<code>pthread_cond_wait</code>或者<code>pthread_cond_timewait</code>阻塞的线程；区别在于<code>pthread_cond_signal</code>是唤醒至少一个被阻塞的线程（总个数不定），<code>pthread_cond_broadcast</code>是唤醒所有被阻塞的线程</p>
<h4 id="生产者和消费者"><a href="#生产者和消费者" class="headerlink" title="生产者和消费者"></a>生产者和消费者</h4><blockquote>
<p>   生产者和消费者模型的组成：</p>
</blockquote>
<ol>
<li><p>生产者线程 -&gt; 若干个</p>
<ul>
<li><p>生产商品或者任务放入到任务队列中</p>
</li>
<li><p>任务队列满了就阻塞，不满的时候就工作</p>
</li>
<li><p>通过一个生产者的条件变量控制生产者线程阻塞和非阻塞</p>
</li>
</ul>
</li>
<li><p>消费者线程 -&gt; 若干个</p>
<ul>
<li>读任务队列，将任务或者数据取出</li>
<li>任务队列中有数据就消费，没有数据就阻塞</li>
<li>通过一个消费者的条件变量控制消费者线程阻塞和非阻塞</li>
</ul>
</li>
<li><p>队列 -&gt; 存储任务 &#x2F; 数据，对应一块内存，为了读写访问可以通过一个数据结构维护这块内存</p>
<ul>
<li>可以是数组、链表，也可以使用 stl 容器：queue &#x2F;stack&#x2F;list&#x2F;vector</li>
</ul>
</li>
</ol>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdbool.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">int</span> number;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">next</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义条件变量, 控制消费者线程</span></span><br><span class="line"><span class="type">pthread_cond_t</span> cond;</span><br><span class="line"><span class="comment">// 互斥锁变量</span></span><br><span class="line"><span class="type">pthread_mutex_t</span> mutex;</span><br><span class="line"><span class="comment">// 指向头结点的指针</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> * <span class="title">head</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 生产者的回调函数</span></span><br><span class="line"><span class="type">void</span>* <span class="title function_">producer</span><span class="params">(<span class="type">void</span>* arg)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">        pthread_mutex_lock(&amp;mutex);</span><br><span class="line">        <span class="comment">// 创建一个链表的新节点</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">pnew</span> =</span> (<span class="keyword">struct</span> Node*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> Node));</span><br><span class="line">        <span class="comment">// 节点初始化</span></span><br><span class="line">        pnew-&gt;number = rand() % <span class="number">1000</span>;</span><br><span class="line">        <span class="comment">// 节点的连接, 添加到链表的头部, 新节点就新的头结点</span></span><br><span class="line">        pnew-&gt;next = head;</span><br><span class="line">        <span class="comment">// head指针前移</span></span><br><span class="line">        head = pnew;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;+++producer, number = %d, tid = %ld\n&quot;</span>, pnew-&gt;number, pthread_self());</span><br><span class="line">        pthread_mutex_unlock(&amp;mutex);</span><br><span class="line">        <span class="comment">// 生产了任务, 通知消费者消费</span></span><br><span class="line">        pthread_cond_broadcast(&amp;cond);</span><br><span class="line">        <span class="comment">// 生产慢一点</span></span><br><span class="line">        sleep(rand() % <span class="number">3</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 消费者的回调函数</span></span><br><span class="line"><span class="type">void</span>* <span class="title function_">consumer</span><span class="params">(<span class="type">void</span>* arg)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">        pthread_mutex_lock(&amp;mutex);</span><br><span class="line">        <span class="comment">// 一直消费, 删除链表中的一个节点</span></span><br><span class="line">		<span class="comment">// if(head == NULL)   // 这样写有bug</span></span><br><span class="line">        <span class="keyword">while</span>(head == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="comment">// 任务队列, 也就是链表中已经没有节点可以消费了</span></span><br><span class="line">            <span class="comment">// 消费者线程需要阻塞</span></span><br><span class="line">            <span class="comment">// 线程加互斥锁成功, 但是线程阻塞在这行代码上, 锁还没解开</span></span><br><span class="line">            <span class="comment">// 其他线程在访问这把锁的时候也会阻塞, 生产者也会阻塞 ==&gt; 死锁</span></span><br><span class="line">            <span class="comment">// 这函数会自动将线程拥有的锁解开</span></span><br><span class="line">            pthread_cond_wait(&amp;cond, &amp;mutex);</span><br><span class="line">            <span class="comment">// 当消费者线程解除阻塞之后, 会自动将这把锁锁上</span></span><br><span class="line">            <span class="comment">// 这时候当前这个线程又重新拥有了这把互斥锁</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 取出链表的头结点, 将其删除</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">pnode</span> =</span> head;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;--consumer: number: %d, tid = %ld\n&quot;</span>, pnode-&gt;number, pthread_self());</span><br><span class="line">        head  = pnode-&gt;next;</span><br><span class="line">        <span class="built_in">free</span>(pnode);</span><br><span class="line">        pthread_mutex_unlock(&amp;mutex);        </span><br><span class="line"></span><br><span class="line">        sleep(rand() % <span class="number">3</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 初始化条件变量</span></span><br><span class="line">    pthread_cond_init(&amp;cond, <span class="literal">NULL</span>);</span><br><span class="line">    pthread_mutex_init(&amp;mutex, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建5个生产者, 5个消费者</span></span><br><span class="line">    <span class="type">pthread_t</span> ptid[<span class="number">5</span>];</span><br><span class="line">    <span class="type">pthread_t</span> ctid[<span class="number">5</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">5</span>; ++i)</span><br><span class="line">        pthread_create(&amp;ptid[i], <span class="literal">NULL</span>, producer, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">5</span>; ++i)</span><br><span class="line">        pthread_create(&amp;ctid[i], <span class="literal">NULL</span>, consumer, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放资源</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">5</span>; ++i)</span><br><span class="line">        <span class="comment">// 阻塞等待子线程退出</span></span><br><span class="line">        pthread_join(ptid[i], <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">5</span>; ++i)</span><br><span class="line">        pthread_join(ctid[i], <span class="literal">NULL</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 销毁条件变量</span></span><br><span class="line">    pthread_cond_destroy(&amp;cond);</span><br><span class="line">    pthread_mutex_destroy(&amp;mutex);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>





<h3 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h3><h4 id="信号量函数"><a href="#信号量函数" class="headerlink" title="信号量函数"></a>信号量函数</h4><blockquote>
<p>  信号量用在多线程多任务同步的，一个线程完成了某一个动作就通过信号量告诉别的线程，别的线程再进行某些动作</p>
</blockquote>
<blockquote>
<p>  信号量主要阻塞线程，不能完全保证线程安全，如果要保证线程安全，需要信号量和互斥锁一起使用</p>
</blockquote>
<blockquote>
<p>  信号量和条件变量一样用于处理生产者和消费者模型，用于阻塞生产者线程或者消费者线程的运行</p>
</blockquote>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;semaphore.h&gt;</span></span></span><br><span class="line"><span class="type">sem_t</span> sem; <span class="comment">// 信号类型</span></span><br></pre></td></tr></table></figure></div>

<p><code>Linux</code>提供的信号量操作函数原型：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 初始化信号量</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sem_init</span><span class="params">(<span class="type">sem_t</span> *sem, <span class="type">int</span> pshared, <span class="type">unsigned</span> <span class="type">int</span> value)</span>;</span><br><span class="line"><span class="comment">// 资源释放       </span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sem_destroy</span><span class="params">(<span class="type">sem_t</span> *sem)</span>;</span><br></pre></td></tr></table></figure></div>

<ul>
<li>参数<ul>
<li><code>sem</code>：信号量变量地址</li>
<li><code>pshared</code>：0，线程同步；非0，进程同步</li>
<li><code>value</code>：初始化当前信号量拥有的资源数（&gt;&#x3D; 0），如果资源数为0线程阻塞</li>
</ul>
</li>
</ul>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 参数 sem 就是 sem_init() 的第一个参数  </span></span><br><span class="line"><span class="comment">// 函数被调用sem中的资源就会被消耗1个, 资源数-1</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sem_wait</span><span class="params">(<span class="type">sem_t</span> *sem)</span>;</span><br></pre></td></tr></table></figure></div>

<blockquote>
<p>  当线程调用这个函数，并且 sem 中的资源数 &gt;0，线程不会阻塞，线程会占用 sem 中的一个资源，因此资源数 - 1，直到 sem 中的资源数减为 0 时，资源被耗尽，因此线程也就被阻塞了</p>
</blockquote>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 参数 sem 就是 sem_init() 的第一个参数  </span></span><br><span class="line"><span class="comment">// 函数被调用sem中的资源就会被消耗1个, 资源数-1</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sem_trywait</span><span class="params">(<span class="type">sem_t</span> *sem)</span>;</span><br></pre></td></tr></table></figure></div>

<blockquote>
<p>  当线程调用这个函数，并且 sem 中的资源数 &gt;0，线程不会阻塞，线程会占用 sem 中的一个资源，因此资源数 - 1，直到 sem 中的资源数减为 0 时，资源被耗尽，但是线程不会被阻塞，直接返回错误号，因此可以在程序中添加判断分支，用于处理获取资源失败之后的情况</p>
</blockquote>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 表示的时间是从1971.1.1到某个时间点的时间, 总长度使用秒/纳秒表示</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">timespec</span> &#123;</span></span><br><span class="line">	<span class="type">time_t</span> tv_sec;      <span class="comment">/* Seconds */</span></span><br><span class="line">	<span class="type">long</span>   tv_nsec;     <span class="comment">/* Nanoseconds [0 .. 999999999] */</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 调用该函数线程获取sem中的一个资源，当资源数为0时，线程阻塞，在阻塞abs_timeout对应的时长之后，解除阻塞。</span></span><br><span class="line"><span class="comment">// abs_timeout: 阻塞的时间长度, 单位是s, 是从1970.1.1开始计算的</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sem_timedwait</span><span class="params">(<span class="type">sem_t</span> *sem, <span class="type">const</span> <span class="keyword">struct</span> timespec *abs_timeout)</span>;</span><br></pre></td></tr></table></figure></div>

<blockquote>
<p>  该函数的参数 abs_timeout 和 pthread_cond_timedwait 的最后一个参数是一样的，使用方法不再过多赘述。当线程调用这个函数，并且 sem 中的资源数 &gt;0，线程不会阻塞，线程会占用 sem 中的一个资源，因此资源数 - 1，直到 sem 中的资源数减为 0 时，资源被耗尽，线程被阻塞，当阻塞指定的时长之后，线程解除阻塞</p>
</blockquote>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 调用该函数给sem中的资源数+1</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sem_post</span><span class="params">(<span class="type">sem_t</span> *sem)</span>;</span><br></pre></td></tr></table></figure></div>

<blockquote>
<p>  调用该函数会将 sem 中的资源数 +1，如果有线程在调用 sem_wait、sem_trywait、sem_timedwait 时因为 sem 中的资源数为 0 被阻塞了，这时这些线程会解除阻塞，获取到资源之后继续向下运行。</p>
</blockquote>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 查看信号量 sem 中的整形数的当前值, 这个值会被写入到sval指针对应的内存中</span></span><br><span class="line"><span class="comment">// sval是一个传出参数</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sem_getvalue</span><span class="params">(<span class="type">sem_t</span> *sem, <span class="type">int</span> *sval)</span>;</span><br></pre></td></tr></table></figure></div>

<blockquote>
<p>  通过这个函数可以查看 sem 中现在拥有的资源个数，通过第二个参数 sval 将数据传出，也就是说第二个参数的作用和返回值是一样的</p>
</blockquote>
<h2 id="套接字"><a href="#套接字" class="headerlink" title="套接字"></a>套接字</h2>
        </div>

        

        
            <ul class="post-tags-box text-lg mt-1.5 flex-wrap justify-center flex md:hidden">
                
                    <li class="tag-item mx-0.5">
                        <a href="/tags/Linux/">#Linux</a>&nbsp;
                    </li>
                
            </ul>
        

        

        
            <div class="article-nav my-8 flex justify-between items-center px-2 sm:px-6 md:px-8">
                
                    <div class="article-prev border-border-color shadow-redefine-flat shadow-shadow-color-2 rounded-medium px-4 py-2 hover:shadow-redefine-flat-hover hover:shadow-shadow-color-2">
                        <a class="prev"
                        rel="prev"
                        href="/2021/10/19/2021-10-19-oh-my-zsh/"
                        >
                            <span class="left arrow-icon flex justify-center items-center">
                                <i class="fa-solid fa-chevron-left"></i>
                            </span>
                            <span class="title flex justify-center items-center">
                                <span class="post-nav-title-item">Oh-my-zsh</span>
                                <span class="post-nav-item">上一篇</span>
                            </span>
                        </a>
                    </div>
                
                
                    <div class="article-next border-border-color shadow-redefine-flat shadow-shadow-color-2 rounded-medium px-4 py-2 hover:shadow-redefine-flat-hover hover:shadow-shadow-color-2">
                        <a class="next"
                        rel="next"
                        href="/2021/08/10/2021-08-10-gcc/"
                        >
                            <span class="title flex justify-center items-center">
                                <span class="post-nav-title-item">GCC</span>
                                <span class="post-nav-item">下一篇</span>
                            </span>
                            <span class="right arrow-icon flex justify-center items-center">
                                <i class="fa-solid fa-chevron-right"></i>
                            </span>
                        </a>
                    </div>
                
            </div>
        


        
    </div>

    
        <div class="toc-content-container">
            <div class="post-toc-wrap">
    <div class="post-toc">
        <div class="toc-title">此页目录</div>
        <div class="page-title">Linux基础</div>
        <ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#Linux"><span class="nav-text">Linux</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BB%8B%E7%BB%8D"><span class="nav-text">介绍</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%91%E8%A1%8C%E7%89%88%EF%BC%88ubuntu%EF%BC%89"><span class="nav-text">发行版（ubuntu）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%86%85%E6%A0%B8"><span class="nav-text">内核</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Linux%E7%9B%AE%E5%BD%95"><span class="nav-text">Linux目录</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84%EF%BC%88ubuntu%EF%BC%89"><span class="nav-text">目录结构（ubuntu）</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86%E5%91%BD%E4%BB%A4"><span class="nav-text">文件管理命令</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#cd%E5%91%BD%E4%BB%A4"><span class="nav-text">cd命令</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ls%E5%91%BD%E4%BB%A4"><span class="nav-text">ls命令</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%9B%E5%BB%BA%E5%88%A0%E9%99%A4%E7%9B%AE%E5%BD%95"><span class="nav-text">创建删除目录</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#cp%E5%91%BD%E4%BB%A4"><span class="nav-text">cp命令</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#mv%E5%91%BD%E4%BB%A4"><span class="nav-text">mv命令</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9F%A5%E7%9C%8B%E6%96%87%E4%BB%B6%E5%86%85%E5%AE%B9"><span class="nav-text">查看文件内容</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%93%BE%E6%8E%A5%E7%9A%84%E5%88%9B%E5%BB%BA"><span class="nav-text">链接的创建</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%96%87%E4%BB%B6%E5%B1%9E%E6%80%A7"><span class="nav-text">文件属性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%B6%E4%BB%96%E5%91%BD%E4%BB%A4"><span class="nav-text">其他命令</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%94%A8%E6%88%B7%E7%AE%A1%E7%90%86%E5%91%BD%E4%BB%A4"><span class="nav-text">用户管理命令</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%87%E6%8D%A2%E7%94%A8%E6%88%B7"><span class="nav-text">切换用户</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B7%BB%E5%8A%A0%E5%88%A0%E9%99%A4%E7%94%A8%E6%88%B7"><span class="nav-text">添加删除用户</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B7%BB%E5%8A%A0%E5%88%A0%E9%99%A4%E7%94%A8%E6%88%B7%E7%BB%84"><span class="nav-text">添加删除用户组</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BF%AE%E6%94%B9%E5%AF%86%E7%A0%81"><span class="nav-text">修改密码</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B7%BB%E5%8A%A0sudo%E6%9D%83%E9%99%90"><span class="nav-text">添加sudo权限</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8E%8B%E7%BC%A9%E5%91%BD%E4%BB%A4"><span class="nav-text">压缩命令</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#tar"><span class="nav-text">tar</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#zip"><span class="nav-text">zip</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#rar"><span class="nav-text">rar</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#xz"><span class="nav-text">xz</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9F%A5%E6%89%BE%E5%91%BD%E4%BB%A4"><span class="nav-text">查找命令</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#find"><span class="nav-text">find</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%96%87%E4%BB%B6%E5%90%8D"><span class="nav-text">文件名</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%96%87%E4%BB%B6%E7%B1%BB%E5%9E%8B"><span class="nav-text">文件类型</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%96%87%E4%BB%B6%E5%A4%A7%E5%B0%8F"><span class="nav-text">文件大小</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%9B%AE%E5%BD%95%E5%B1%82%E7%BA%A7"><span class="nav-text">目录层级</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%90%8C%E6%97%B6%E6%89%A7%E8%A1%8C%E5%A4%9A%E4%B8%AA%E6%93%8D%E4%BD%9C"><span class="nav-text">同时执行多个操作</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#grep"><span class="nav-text">grep</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#locate"><span class="nav-text">locate</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%96%87%E4%BB%B6%E6%8F%8F%E8%BF%B0%E7%AC%A6"><span class="nav-text">文件描述符</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%99%9A%E6%8B%9F%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4"><span class="nav-text">虚拟地址空间</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AD%98%E5%9C%A8%E7%9A%84%E6%84%8F%E4%B9%89"><span class="nav-text">存在的意义</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%86%E5%8C%BA"><span class="nav-text">分区</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%96%87%E4%BB%B6%E6%8F%8F%E8%BF%B0%E7%AC%A6-1"><span class="nav-text">文件描述符</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%96%87%E4%BB%B6%E6%8F%8F%E8%BF%B0%E7%AC%A6-2"><span class="nav-text">文件描述符</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%96%87%E4%BB%B6%E6%8F%8F%E8%BF%B0%E7%AC%A6%E8%A1%A8"><span class="nav-text">文件描述符表</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Linux%E7%B3%BB%E7%BB%9F%E6%96%87%E4%BB%B6IO"><span class="nav-text">Linux系统文件IO</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#open-close"><span class="nav-text">open&#x2F;close</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#open%E5%87%BD%E6%95%B0%E5%8E%9F%E5%9E%8B"><span class="nav-text">open函数原型</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#close%E5%87%BD%E6%95%B0%E5%8E%9F%E5%9E%8B"><span class="nav-text">close函数原型</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%89%93%E5%BC%80%E5%B7%B2%E5%AD%98%E5%9C%A8%E6%96%87%E4%BB%B6"><span class="nav-text">打开已存在文件</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%9B%E5%BB%BA%E6%96%B0%E6%96%87%E4%BB%B6"><span class="nav-text">创建新文件</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%96%87%E4%BB%B6%E7%8A%B6%E6%80%81%E5%88%A4%E6%96%AD"><span class="nav-text">文件状态判断</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#read-write"><span class="nav-text">read&#x2F;write</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#read"><span class="nav-text">read</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#write"><span class="nav-text">write</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%96%87%E4%BB%B6%E6%8B%B7%E8%B4%9D"><span class="nav-text">文件拷贝</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#lseek"><span class="nav-text">lseek</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%A7%BB%E5%8A%A8%E6%96%87%E4%BB%B6%E6%8C%87%E9%92%88"><span class="nav-text">移动文件指针</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%96%87%E4%BB%B6%E6%89%A9%E5%B1%95"><span class="nav-text">文件扩展</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#truncate-ftruncate"><span class="nav-text">truncate&#x2F;ftruncate</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#perror"><span class="nav-text">perror</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%94%99%E8%AF%AF%E5%8F%B7"><span class="nav-text">错误号</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%96%87%E4%BB%B6%E5%B1%9E%E6%80%A7%E4%BF%A1%E6%81%AF"><span class="nav-text">文件属性信息</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#file%E5%91%BD%E4%BB%A4"><span class="nav-text">file命令</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#stat%E5%91%BD%E4%BB%A4"><span class="nav-text">stat命令</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#stat-lstat%E5%87%BD%E6%95%B0"><span class="nav-text">stat&#x2F;lstat函数</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%8E%B7%E5%8F%96%E6%96%87%E4%BB%B6%E5%A4%A7%E5%B0%8F"><span class="nav-text">获取文件大小</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%8E%B7%E5%8F%96%E6%96%87%E4%BB%B6%E7%B1%BB%E5%9E%8B"><span class="nav-text">获取文件类型</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%8E%B7%E5%8F%96%E6%96%87%E4%BB%B6%E6%9D%83%E9%99%90"><span class="nav-text">获取文件权限</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%96%87%E4%BB%B6%E6%8F%8F%E8%BF%B0%E7%AC%A6%E5%A4%8D%E5%88%B6%E5%92%8C%E9%87%8D%E5%AE%9A%E5%90%91"><span class="nav-text">文件描述符复制和重定向</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#dup"><span class="nav-text">dup</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#dup2"><span class="nav-text">dup2</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#fcntl"><span class="nav-text">fcntl</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%9B%AE%E5%BD%95%E9%81%8D%E5%8E%86"><span class="nav-text">目录遍历</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%9B%AE%E5%BD%95%E4%B8%89%E5%89%91%E5%AE%A2"><span class="nav-text">目录三剑客</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#opendir"><span class="nav-text">opendir</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#readdir"><span class="nav-text">readdir</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#closedir"><span class="nav-text">closedir</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%81%8D%E5%8E%86%E7%9B%AE%E5%BD%95"><span class="nav-text">遍历目录</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#scandir%E5%87%BD%E6%95%B0"><span class="nav-text">scandir函数</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%96%87%E4%BB%B6%E8%BF%87%E6%BB%A4"><span class="nav-text">文件过滤</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%81%8D%E5%8E%86%E7%9B%AE%E5%BD%95-1"><span class="nav-text">遍历目录</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E6%8E%A7%E5%88%B6"><span class="nav-text">进程控制</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E6%A6%82%E8%BF%B0"><span class="nav-text">进程概述</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%B9%B6%E8%A1%8C%E5%92%8C%E5%B9%B6%E5%8F%91"><span class="nav-text">并行和并发</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#PCB"><span class="nav-text">PCB</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E7%8A%B6%E6%80%81"><span class="nav-text">进程状态</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E5%91%BD%E4%BB%A4"><span class="nav-text">进程命令</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E5%88%9B%E5%BB%BA"><span class="nav-text">进程创建</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%87%BD%E6%95%B0"><span class="nav-text">函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#fork"><span class="nav-text">fork( )</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%88%B6%E5%AD%90%E8%BF%9B%E7%A8%8B"><span class="nav-text">父子进程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E6%89%A7%E8%A1%8C%E4%BD%8D%E7%BD%AE"><span class="nav-text">进程执行位置</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BE%AA%E7%8E%AF%E5%88%9B%E5%BB%BA%E5%AD%90%E8%BF%9B%E7%A8%8B"><span class="nav-text">循环创建子进程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E6%95%B0%E6%95%B0"><span class="nav-text">进程数数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#execl%E5%92%8Cexeclp%E5%87%BD%E6%95%B0"><span class="nav-text">execl和execlp函数</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#execl"><span class="nav-text">execl( )</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#execlp"><span class="nav-text">execlp( )</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%87%BD%E6%95%B0%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="nav-text">函数的使用</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E6%8E%A7%E5%88%B6-1"><span class="nav-text">进程控制</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BB%93%E6%9D%9F%E8%BF%9B%E7%A8%8B"><span class="nav-text">结束进程</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AD%A4%E5%84%BF%E8%BF%9B%E7%A8%8B"><span class="nav-text">孤儿进程</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%83%B5%E5%B0%B8%E8%BF%9B%E7%A8%8B"><span class="nav-text">僵尸进程</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E5%9B%9E%E6%94%B6"><span class="nav-text">进程回收</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#wait"><span class="nav-text">wait</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#waitpid"><span class="nav-text">waitpid</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AE%A1%E9%81%93"><span class="nav-text">管道</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AE%A1%E9%81%93-1"><span class="nav-text">管道</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8C%BF%E5%90%8D%E7%AE%A1%E9%81%93"><span class="nav-text">匿名管道</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%9B%E5%BB%BA%E5%8C%BF%E5%90%8D%E7%AE%A1%E9%81%93"><span class="nav-text">创建匿名管道</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1"><span class="nav-text">进程间通信</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9C%89%E5%90%8D%E7%AE%A1%E9%81%93"><span class="nav-text">有名管道</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%9B%E5%BB%BA%E6%9C%89%E5%90%8D%E7%AE%A1%E9%81%93"><span class="nav-text">创建有名管道</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1-1"><span class="nav-text">进程间通信</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AE%A1%E9%81%93%E7%9A%84%E8%AF%BB%E5%86%99%E8%A1%8C%E4%B8%BA"><span class="nav-text">管道的读写行为</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%86%85%E5%AD%98%E6%98%A0%E5%B0%84"><span class="nav-text">内存映射</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%9B%E5%BB%BA%E5%86%85%E5%AD%98%E6%98%A0%E5%B0%84%E5%8C%BA"><span class="nav-text">创建内存映射区</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1-2"><span class="nav-text">进程间通信</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9C%89%E8%A1%80%E7%BC%98%E5%85%B3%E7%B3%BB"><span class="nav-text">有血缘关系</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%97%A0%E8%A1%80%E7%BC%98%E5%85%B3%E7%B3%BB"><span class="nav-text">无血缘关系</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8B%B7%E8%B4%9D%E6%96%87%E4%BB%B6"><span class="nav-text">拷贝文件</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98"><span class="nav-text">共享内存</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%9B%E5%BB%BA%E3%80%81%E6%89%93%E5%BC%80%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98"><span class="nav-text">创建、打开共享内存</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#shmget"><span class="nav-text">shmget</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#ftok"><span class="nav-text">ftok</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%B3%E8%81%94%E5%92%8C%E8%A7%A3%E9%99%A4%E5%85%B3%E8%81%94"><span class="nav-text">关联和解除关联</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#shmat"><span class="nav-text">shmat</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#shmdt"><span class="nav-text">shmdt</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%A0%E9%99%A4%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98"><span class="nav-text">删除共享内存</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#shmctl"><span class="nav-text">shmctl</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%9B%B8%E5%85%B3shell%E5%91%BD%E4%BB%A4"><span class="nav-text">相关shell命令</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98%E7%8A%B6%E6%80%81"><span class="nav-text">共享内存状态</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1-3"><span class="nav-text">进程间通信</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#shm%E5%92%8Cmmap%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-text">shm和mmap的区别</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AE%88%E6%8A%A4%E8%BF%9B%E7%A8%8B"><span class="nav-text">守护进程</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E7%BB%84"><span class="nav-text">进程组</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BC%9A%E8%AF%9D"><span class="nav-text">会话</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%9B%E5%BB%BA%E5%AE%88%E6%8A%A4%E8%BF%9B%E7%A8%8B"><span class="nav-text">创建守护进程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%88%E6%8A%A4%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%BA%94%E7%94%A8"><span class="nav-text">守护进程的应用</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BF%A1%E5%8F%B7"><span class="nav-text">信号</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BF%A1%E5%8F%B7-1"><span class="nav-text">信号</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BF%A1%E5%8F%B7%E7%BC%96%E5%8F%B7"><span class="nav-text">信号编号</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9F%A5%E7%9C%8B%E4%BF%A1%E5%8F%B7%E4%BF%A1%E6%81%AF"><span class="nav-text">查看信号信息</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BF%A1%E5%8F%B7%E7%9A%84%E7%8A%B6%E6%80%81"><span class="nav-text">信号的状态</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BF%A1%E5%8F%B7%E7%9B%B8%E5%85%B3%E5%87%BD%E6%95%B0"><span class="nav-text">信号相关函数</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#kill-raise-abort"><span class="nav-text">kill raise abort</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AE%9A%E6%97%B6%E5%99%A8"><span class="nav-text">定时器</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BF%A1%E5%8F%B7%E9%9B%86"><span class="nav-text">信号集</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%98%BB%E5%A1%9E%E3%80%81%E6%9C%AA%E5%86%B3%E4%BF%A1%E5%8F%B7%E9%9B%86"><span class="nav-text">阻塞、未决信号集</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BF%A1%E5%8F%B7%E9%9B%86%E5%87%BD%E6%95%B0"><span class="nav-text">信号集函数</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BF%A1%E5%8F%B7%E6%8D%95%E6%8D%89"><span class="nav-text">信号捕捉</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#signal"><span class="nav-text">signal</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#sigaction"><span class="nav-text">sigaction</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#SIGCHLD%E4%BF%A1%E5%8F%B7"><span class="nav-text">SIGCHLD信号</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B"><span class="nav-text">线程</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E6%A6%82%E8%BF%B0"><span class="nav-text">线程概述</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%9B%E5%BB%BA%E7%BA%BF%E7%A8%8B"><span class="nav-text">创建线程</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E5%87%BD%E6%95%B0"><span class="nav-text">线程函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%9B%E5%BB%BA%E7%BA%BF%E7%A8%8B-1"><span class="nav-text">创建线程</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E9%80%80%E5%87%BA"><span class="nav-text">线程退出</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E5%9B%9E%E6%94%B6"><span class="nav-text">线程回收</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E5%87%BD%E6%95%B0-1"><span class="nav-text">线程函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9B%9E%E6%94%B6%E5%AD%90%E7%BA%BF%E7%A8%8B%E6%95%B0%E6%8D%AE"><span class="nav-text">回收子线程数据</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E5%88%86%E7%A6%BB"><span class="nav-text">线程分离</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%B6%E5%AE%83%E7%BA%BF%E7%A8%8B%E5%87%BD%E6%95%B0"><span class="nav-text">其它线程函数</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E5%8F%96%E6%B6%88"><span class="nav-text">线程取消</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8BID%E6%AF%94%E8%BE%83"><span class="nav-text">线程ID比较</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5"><span class="nav-text">线程同步</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5%E6%A6%82%E5%BF%B5"><span class="nav-text">线程同步概念</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E5%90%8C%E6%AD%A5"><span class="nav-text">为什么要同步</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%90%8C%E6%AD%A5%E6%96%B9%E5%BC%8F"><span class="nav-text">同步方式</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BA%92%E6%96%A5%E9%94%81"><span class="nav-text">互斥锁</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BA%92%E6%96%A5%E9%94%81%E5%87%BD%E6%95%B0"><span class="nav-text">互斥锁函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BA%92%E6%96%A5%E9%94%81%E4%BD%BF%E7%94%A8"><span class="nav-text">互斥锁使用</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%AD%BB%E9%94%81"><span class="nav-text">死锁</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AF%BB%E5%86%99%E9%94%81"><span class="nav-text">读写锁</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%AF%BB%E5%86%99%E9%94%81%E5%87%BD%E6%95%B0"><span class="nav-text">读写锁函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%AF%BB%E5%86%99%E9%94%81%E4%BD%BF%E7%94%A8"><span class="nav-text">读写锁使用</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9D%A1%E4%BB%B6%E5%8F%98%E9%87%8F"><span class="nav-text">条件变量</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9D%A1%E4%BB%B6%E5%8F%98%E9%87%8F%E5%87%BD%E6%95%B0"><span class="nav-text">条件变量函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%94%9F%E4%BA%A7%E8%80%85%E5%92%8C%E6%B6%88%E8%B4%B9%E8%80%85"><span class="nav-text">生产者和消费者</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BF%A1%E5%8F%B7%E9%87%8F"><span class="nav-text">信号量</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BF%A1%E5%8F%B7%E9%87%8F%E5%87%BD%E6%95%B0"><span class="nav-text">信号量函数</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A5%97%E6%8E%A5%E5%AD%97"><span class="nav-text">套接字</span></a></li></ol></li></ol>

    </div>
</div>
        </div>
    
</div>



                

            </div>

            

        </div>

        <div class="main-content-footer">
            <footer class="footer mt-5 py-5 h-auto text-base text-third-text-color relative border-t-2 border-t-border-color">
    <div class="info-container py-3 text-center">
        
        <div class="text-center">
            &copy;
            
            2024&nbsp;&nbsp;<i class="fa-solid fa-heart fa-beat" style="--fa-animation-duration: 0.5s; color: #f54545"></i>&nbsp;&nbsp;<a href="/">fetch150zy</a>
            
                
                <p class="post-count space-x-0.5">
                    <span>
                        共 52 篇文章
                    </span>
                    
                </p>
            
        </div>
        
        <div class="relative text-center lg:absolute lg:left-[20px] lg:top-1/2 lg:-translate-y-1/2 lg:text-left">
            <span class="lg:block text-sm">由 <?xml version="1.0" encoding="utf-8"?><!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd"><svg class="relative top-[2px] inline-block align-baseline" version="1.1" id="圖層_1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px" width="1rem" height="1rem" viewBox="0 0 512 512" enable-background="new 0 0 512 512" xml:space="preserve"><path fill="#0E83CD" d="M256.4,25.8l-200,115.5L56,371.5l199.6,114.7l200-115.5l0.4-230.2L256.4,25.8z M349,354.6l-18.4,10.7l-18.6-11V275H200v79.6l-18.4,10.7l-18.6-11v-197l18.5-10.6l18.5,10.8V237h112v-79.6l18.5-10.6l18.5,10.8V354.6z"/></svg><a target="_blank" class="text-base" href="https://hexo.io">Hexo</a> 驱动</span>
            <span class="text-sm lg:block">主题&nbsp;<a class="text-base" target="_blank" href="https://github.com/EvanNotFound/hexo-theme-redefine">Redefine v2.6.1</a></span>
        </div>
        
        
        
        
        
    </div>  
</footer>
        </div>
    </div>

    
        <div class="post-tools">
            <div class="post-tools-container">
    <ul class="article-tools-list">
        <!-- TOC aside toggle -->
        
            <li class="right-bottom-tools page-aside-toggle">
                <i class="fa-regular fa-outdent"></i>
            </li>
        

        <!-- go comment -->
        
    </ul>
</div>

        </div>
    

    <div class="right-side-tools-container">
        <div class="side-tools-container">
    <ul class="hidden-tools-list">
        <li class="right-bottom-tools tool-font-adjust-plus flex justify-center items-center">
            <i class="fa-regular fa-magnifying-glass-plus"></i>
        </li>

        <li class="right-bottom-tools tool-font-adjust-minus flex justify-center items-center">
            <i class="fa-regular fa-magnifying-glass-minus"></i>
        </li>

        <li class="right-bottom-tools tool-dark-light-toggle flex justify-center items-center">
            <i class="fa-regular fa-moon"></i>
        </li>

        <!-- rss -->
        

        

        <li class="right-bottom-tools tool-scroll-to-bottom flex justify-center items-center">
            <i class="fa-regular fa-arrow-down"></i>
        </li>
    </ul>

    <ul class="visible-tools-list">
        <li class="right-bottom-tools toggle-tools-list flex justify-center items-center">
            <i class="fa-regular fa-cog fa-spin"></i>
        </li>
        
            <li class="right-bottom-tools tool-scroll-to-top flex justify-center items-center">
                <i class="arrow-up fas fa-arrow-up"></i>
                <span class="percent"></span>
            </li>
        
        
    </ul>
</div>

    </div>

    <div class="image-viewer-container">
    <img src="">
</div>


    

</main>


    
<script src="/js/libs/Swup.min.js"></script>

<script src="/js/libs/SwupSlideTheme.min.js"></script>

<script src="/js/libs/SwupScriptsPlugin.min.js"></script>

<script src="/js/libs/SwupProgressPlugin.min.js"></script>

<script src="/js/libs/SwupScrollPlugin.min.js"></script>

<script src="/js/libs/SwupPreloadPlugin.min.js"></script>

<script>
    const swup = new Swup({
        plugins: [
            new SwupScriptsPlugin({
                optin: true,
            }),
            new SwupProgressPlugin(),
            new SwupScrollPlugin({
                offset: 80,
            }),
            new SwupSlideTheme({
                mainElement: ".main-content-body",
            }),
            new SwupPreloadPlugin(),
        ],
        containers: ["#swup"],
    });
</script>







<script src="/js/tools/imageViewer.js" type="module"></script>

<script src="/js/utils.js" type="module"></script>

<script src="/js/main.js" type="module"></script>

<script src="/js/layouts/navbarShrink.js" type="module"></script>

<script src="/js/tools/scrollTopBottom.js" type="module"></script>

<script src="/js/tools/lightDarkSwitch.js" type="module"></script>

<script src="/js/layouts/categoryList.js" type="module"></script>







    
<script src="/js/layouts/lazyload.js" type="module"></script>






  
<script src="/js/libs/Typed.min.js"></script>

  
<script src="/js/plugins/typed.js" type="module"></script>









<div class="post-scripts" data-swup-reload-script>
    
        
<script src="/js/tools/tocToggle.js" type="module"></script>

<script src="/js/layouts/toc.js" type="module"></script>

<script src="/js/plugins/tabs.js" type="module"></script>

    
</div>


</body>
</html>

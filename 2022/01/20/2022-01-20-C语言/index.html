<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="keywords" content="computer science">
    
    <meta name="author" content="fetch150zy">
    <!-- preconnect -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>

    
    <!--- Seo Part-->
    
    <link rel="canonical" href="https://fetch150zy.github.io/2022/01/20/2022-01-20-c语言/"/>
    <meta name="robots" content="index,follow">
    <meta name="googlebot" content="index,follow">
    <meta name="revisit-after" content="1 days">
    
        <meta name="description" content="cppreference 中的C文档c primer plus第六版的笔记，包含c基础，代码规范及进阶技术常用的c标准库函数 cppreference - C基本概念注释C 风格注释1&#x2F;* 注释内容 *&#x2F;    C++ 风格注释1&#x2F;&#x2F; 注释内容     C 风格注释可出现在 C++ 风格注释中，反之亦然  注意： 注释在预处理器阶段被移除，宏不能用于组成注释 123456789&#x2F;* 试图用宏组成注">
<meta property="og:type" content="article">
<meta property="og:title" content="C语言">
<meta property="og:url" content="https://fetch150zy.github.io/2022/01/20/2022-01-20-C%E8%AF%AD%E8%A8%80/index.html">
<meta property="og:site_name" content="fetch150zy&#39;blog">
<meta property="og:description" content="cppreference 中的C文档c primer plus第六版的笔记，包含c基础，代码规范及进阶技术常用的c标准库函数 cppreference - C基本概念注释C 风格注释1&#x2F;* 注释内容 *&#x2F;    C++ 风格注释1&#x2F;&#x2F; 注释内容     C 风格注释可出现在 C++ 风格注释中，反之亦然  注意： 注释在预处理器阶段被移除，宏不能用于组成注释 123456789&#x2F;* 试图用宏组成注">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2022-01-20T09:07:46.000Z">
<meta property="article:modified_time" content="2024-03-23T05:43:58.487Z">
<meta property="article:author" content="fetch150zy">
<meta property="article:tag" content="C语言">
<meta name="twitter:card" content="summary">
    
    
    <!--- Icon Part-->
    <link rel="icon" type="image/png" href="/img/pacman.png" sizes="192x192">
    <link rel="apple-touch-icon" sizes="180x180" href="/img/pacman.png">
    <meta name="theme-color" content="#7FCDCD">
    <link rel="shortcut icon" href="/img/pacman.png">
    <!--- Page Info-->
    
    <title>
        
            C语言 -
        
        fetch150zy&#39;s blog
    </title>

    
<link rel="stylesheet" href="/fonts/Chillax/chillax.css">


    <!--- Inject Part-->
    

    
        <style>
    :root {
        --preloader-background-color: #fff;
        --preloader-text-color: #000;
    }

    @media (prefers-color-scheme: dark) {
        :root {
            --preloader-background-color: #202124;
            --preloader-text-color: #fff;
        }
    }

    @media (prefers-color-scheme: light) {
        :root {
            --preloader-background-color: #fff;
            --preloader-text-color: #000;
        }
    }

    @media (max-width: 600px) {
        .ml13 {
            font-size: 2.6rem !important; /* Adjust this value as needed */
        }
    }

    .preloader {
        display: flex;
        flex-direction: column;
        gap: 1rem; /* Tailwind 'gap-4' is 1rem */
        align-items: center;
        justify-content: center;
        position: fixed;
        padding: 12px;
        top: 0;
        right: 0;
        bottom: 0;
        left: 0;
        width: 100vw;
        height: 100vh; /* 'h-screen' is 100% of the viewport height */
        background-color: var(--preloader-background-color);
        z-index: 1100; /* 'z-[1100]' sets the z-index */
        transition: opacity 0.2s ease-in-out;
    }

    .ml13 {
        font-size: 3.2rem;
        /* text-transform: uppercase; */
        color: var(--preloader-text-color);
        letter-spacing: -1px;
        font-weight: 500;
        font-family: 'Chillax-Variable', sans-serif;
        text-align: center;
    }

    .ml13 .word {
        display: inline-flex;
        flex-wrap: wrap;
        white-space: nowrap;
    }

    .ml13 .letter {
        display: inline-block;
        line-height: 1em;
    }
</style>

<div class="preloader">
    
<script src="/js/libs/anime.min.js"></script>

    <h1 class="ml13">
        fetch150zy&#39;s blog
    </h1>
    <script>
        var textWrapper = document.querySelector('.ml13');
        // Split text into words
        var words = textWrapper.textContent.trim().split(' ');

        // Clear the existing content
        textWrapper.innerHTML = '';

        // Wrap each word and its letters in spans
        words.forEach(function(word) {
            var wordSpan = document.createElement('span');
            wordSpan.classList.add('word');
            wordSpan.innerHTML = word.replace(/\S/g, "<span class='letter'>$&</span>");
            textWrapper.appendChild(wordSpan);
            textWrapper.appendChild(document.createTextNode(' ')); // Add space between words
        });


        anime.timeline({loop: true})
            .add({
                targets: '.ml13 .letter',
                translateY: [100,0],
                translateZ: 0,
                opacity: [0,1],
                easing: "easeOutExpo",
                duration: 1400,
                delay: (el, i) => 300 + 30 * i
            }).add({
            targets: '.ml13 .letter',
            translateY: [0,-100],
            opacity: [1,0],
            easing: "easeInExpo",
            duration: 1200,
            delay: (el, i) => 100 + 30 * i
        });

        let themeStatus = JSON.parse(localStorage.getItem('REDEFINE-THEME-STATUS'))?.isDark;

        // If the theme status is not found in local storage, check the preferred color scheme
        if (themeStatus === undefined || themeStatus === null) {
            if (window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches) {
                themeStatus = 'dark';
            } else {
                themeStatus = 'light';
            }
        }

        // Now you can use the themeStatus variable in your code
        if (themeStatus) {
            document.documentElement.style.setProperty('--preloader-background-color', '#202124');
            document.documentElement.style.setProperty('--preloader-text-color', '#fff');
        } else {
            document.documentElement.style.setProperty('--preloader-background-color', '#fff');
            document.documentElement.style.setProperty('--preloader-text-color', '#000');
        }

        window.addEventListener('load', function () {
            hidePreloaderAfterTimeout(1000); // Hide after 1000 milliseconds once the window has loaded
        });

        // Backup failsafe: Hide preloader after a maximum of 5000 milliseconds, regardless of the window load event
        hidePreloaderAfterTimeout(5000);

        function hidePreloaderAfterTimeout(delay) {
            setTimeout(function () {
                var preloader = document.querySelector('.preloader');
                preloader.style.opacity = '0';
                setTimeout(function () {
                    preloader.style.display = 'none';
                }, 200);
            }, delay);
        }
    </script>
</div>
    

    
<link rel="stylesheet" href="/css/style.css">


    
        
<link rel="stylesheet" href="/assets/build/styles.css">

    

    
<link rel="stylesheet" href="/fonts/fonts.css">

    
<link rel="stylesheet" href="/fonts/Satoshi/satoshi.css">

    <!--- Font Part-->
    
    
    
    


    <script id="hexo-configurations">
    window.config = {"hostname":"fetch150zy.github.io","root":"/","language":"zh-CN"};
    window.theme = {"articles":{"style":{"font_size":"18px","line_height":1.4,"image_border_radius":"14px","image_alignment":"center","image_caption":false,"link_icon":true,"title_alignment":"center","headings_top_spacing":{"h1":"5rem","h2":"4rem","h3":"2.8rem","h4":"2.5rem","h5":"2.2rem","h6":"2rem"}},"word_count":{"enable":false,"count":false,"min2read":false},"author_label":{"enable":false,"auto":false,"list":[]},"code_block":{"copy":false,"style":"mac","font":{"enable":false,"family":null,"url":null}},"toc":{"enable":true,"max_depth":6,"number":false,"expand":true,"init_open":true},"copyright":{"enable":false,"default":"cc_by_nc_sa"},"lazyload":true,"recommendation":{"enable":false,"title":"推荐阅读","limit":3,"mobile_limit":2,"placeholder":null,"skip_dirs":[]}},"colors":{"primary":"#7FCDCD","secondary":null,"default_mode":"dark"},"global":{"fonts":{"chinese":{"enable":null,"family":null,"url":null},"english":{"enable":null,"family":null,"url":null}},"content_max_width":"1000px","sidebar_width":"210px","hover":{"shadow":true,"scale":true},"scroll_progress":{"bar":false,"percentage":true},"website_counter":{"url":"https://cn.vercount.one/js","enable":false,"site_pv":false,"site_uv":false,"post_pv":false},"single_page":true,"preloader":true,"open_graph":true,"google_analytics":{"enable":false,"id":null}},"home_banner":{"enable":true,"style":"fixed","image":{"light":"/img/bg15.jpg","dark":"/img/bg15.jpg"},"title":"fetch150zy's blog","subtitle":{"text":["年年岁岁花相似，岁岁年年人不同"],"hitokoto":{"enable":false,"api":"https://v1.hitokoto.cn"},"typing_speed":100,"backing_speed":80,"starting_delay":500,"backing_delay":1500,"loop":true,"smart_backspace":true},"text_color":{"light":"#fff","dark":"#d1d1b6"},"text_style":{"title_size":"2.8rem","subtitle_size":"1.5rem","line_height":1.3},"custom_font":{"enable":false,"family":null,"url":null},"social_links":{"enable":true,"style":"default","links":{"github":"https://github.com/fetch150zy","bilibili":"https://space.bilibili.com/505867894","stack-overflow":"https://stackoverflow.com/users/16738249/fetch150zy","email":"mailto:mars_zhewei@outlook.com"},"qrs":{"weixin":"https://pic.fetch150zy.cn/weixin.png"}}},"plugins":{"feed":{"enable":false},"aplayer":{"enable":false,"type":"fixed","audios":[{"name":null,"artist":null,"url":null,"cover":null,"lrc":null}]},"mermaid":{"enable":false,"version":"9.3.0"}},"version":"2.6.1","navbar":{"auto_hide":false,"color":{"left":"#f78736","right":"#367df7","transparency":35},"width":{"home":"1200px","pages":"1000px"},"links":{"Home":{"path":"/","icon":"fa-regular fa-house"},"Archives":{"path":"/archives","icon":"fa-regular fa-archive"},"About":{"icon":"fa-regular fa-user","submenus":{"Me":"/about","Blog":"https://fetch150zy.cn","Github":"https://github.com/fetch150zy"}}},"search":{"enable":false,"preload":true}},"page_templates":{"friends_column":3,"tags_style":"blur"},"home":{"sidebar":{"enable":true,"position":"right","first_item":"info","announcement":null,"show_on_mobile":true,"links":{"Archives":{"path":"/archives","icon":"fa-regular fa-archive"},"Tags":{"path":"/tags","icon":"fa-regular fa-tags"},"Categories":{"path":"/categories","icon":"fa-regular fa-folder"}}},"article_date_format":"YYYY-MM-DD","categories":{"enable":true,"limit":3},"tags":{"enable":true,"limit":3}},"footerStart":null};
    window.lang_ago = {"second":"%s 秒前","minute":"%s 分钟前","hour":"%s 小时前","day":"%s 天前","week":"%s 周前","month":"%s 个月前","year":"%s 年前"};
    window.data = {"masonry":false};
  </script>
    
    <!--- Fontawesome Part-->
    
<link rel="stylesheet" href="/fontawesome/fontawesome.min.css">

    
<link rel="stylesheet" href="/fontawesome/brands.min.css">

    
<link rel="stylesheet" href="/fontawesome/solid.min.css">

    
<link rel="stylesheet" href="/fontawesome/regular.min.css">

    
    
    
    
        
<link rel="stylesheet" href="/fontawesome/sharp-solid.min.css">

    
<meta name="generator" content="Hexo 7.1.1"></head>


<body>
<div class="progress-bar-container">
    

    
        <span class="pjax-progress-bar"></span>
<!--        <span class="swup-progress-icon">-->
<!--            <i class="fa-solid fa-circle-notch fa-spin"></i>-->
<!--        </span>-->
    
</div>


<main class="page-container" id="swup">

    

    <div class="main-content-container">


        <div class="main-content-header">
            <header class="navbar-container px-6 md:px-12">

    <div class="navbar-content ">
        <div class="left">
            
                <a class="logo-image" href="/">
                    <img src="/img/pacman.png">
                </a>
            
            <a class="logo-title" href="/">
                
                fetch150zy&#39;s blog
                
            </a>
        </div>

        <div class="right">
            <!-- PC -->
            <div class="desktop">
                <ul class="navbar-list">
                    
                        
                            

                            <li class="navbar-item">
                                <!-- Menu -->
                                <a class=""
                                   href="/"
                                        >
                                    <i class="fa-regular fa-house fa-fw"></i>
                                    首页
                                    
                                </a>

                                <!-- Submenu -->
                                
                            </li>
                    
                        
                            

                            <li class="navbar-item">
                                <!-- Menu -->
                                <a class=""
                                   href="/archives"
                                        >
                                    <i class="fa-regular fa-archive fa-fw"></i>
                                    归档
                                    
                                </a>

                                <!-- Submenu -->
                                
                            </li>
                    
                        
                            

                            <li class="navbar-item">
                                <!-- Menu -->
                                <a class="has-dropdown"
                                   href="#"
                                        onClick=&#34;return false;&#34;>
                                    <i class="fa-regular fa-user fa-fw"></i>
                                    关于
                                    <i class="fa-solid fa-chevron-down fa-fw"></i>
                                </a>

                                <!-- Submenu -->
                                
                                    <ul class="sub-menu">
                                        
                                            <li>
                                                <a href="/about">
                                                    ME
                                                </a>
                                            </li>
                                        
                                            <li>
                                                <a target="_blank" rel="noopener" href="https://fetch150zy.cn">
                                                    BLOG
                                                </a>
                                            </li>
                                        
                                            <li>
                                                <a target="_blank" rel="noopener" href="https://github.com/fetch150zy">
                                                    GITHUB
                                                </a>
                                            </li>
                                        
                                    </ul>
                                
                            </li>
                    
                    
                </ul>
            </div>
            <!-- Mobile -->
            <div class="mobile">
                
                <div class="icon-item navbar-bar">
                    <div class="navbar-bar-middle"></div>
                </div>
            </div>
        </div>
    </div>

    <!-- Mobile sheet -->
    <div class="navbar-drawer h-screen w-full absolute top-0 left-0 bg-background-color flex flex-col justify-between">
        <ul class="drawer-navbar-list flex flex-col px-4 justify-center items-start">
            
                
                    

                    <li class="drawer-navbar-item text-base my-1.5 flex flex-col w-full">
                        
                        <a class="py-1.5 px-2 flex flex-row items-center justify-between gap-1 hover:!text-primary active:!text-primary text-2xl font-semibold group border-b border-border-color hover:border-primary w-full "
                           href="/"
                        >
                            <span>
                                首页
                            </span>
                            
                                <i class="fa-regular fa-house fa-sm fa-fw"></i>
                            
                        </a>
                        

                        
                    </li>
            
                
                    

                    <li class="drawer-navbar-item text-base my-1.5 flex flex-col w-full">
                        
                        <a class="py-1.5 px-2 flex flex-row items-center justify-between gap-1 hover:!text-primary active:!text-primary text-2xl font-semibold group border-b border-border-color hover:border-primary w-full "
                           href="/archives"
                        >
                            <span>
                                归档
                            </span>
                            
                                <i class="fa-regular fa-archive fa-sm fa-fw"></i>
                            
                        </a>
                        

                        
                    </li>
            
                
                    

                    <li class="drawer-navbar-item-sub text-base my-1.5 flex flex-col w-full">
                        
                        <div class="py-1.5 px-2 flex flex-row items-center justify-between gap-1 hover:!text-primary active:!text-primary cursor-pointer text-2xl font-semibold group border-b border-border-color hover:border-primary w-full "
                             navbar-data-toggle="submenu-About"
                        >
                            <span>
                                关于
                            </span>
                            
                                <i class="fa-solid fa-chevron-right fa-sm fa-fw transition-all"></i>
                            
                        </div>
                        

                        
                            <div class="flex-col items-start px-2 py-2 hidden" data-target="submenu-About">
                                
                                    <div class="drawer-navbar-item text-base flex flex-col justify-center items-start hover:underline active:underline hover:underline-offset-1 rounded-3xl">
                                        <a class=" text-third-text-color text-xl"
                                           href="/about">ME</a>
                                    </div>
                                
                                    <div class="drawer-navbar-item text-base flex flex-col justify-center items-start hover:underline active:underline hover:underline-offset-1 rounded-3xl">
                                        <a class=" text-third-text-color text-xl"
                                           target="_blank" rel="noopener" href="https://fetch150zy.cn">BLOG</a>
                                    </div>
                                
                                    <div class="drawer-navbar-item text-base flex flex-col justify-center items-start hover:underline active:underline hover:underline-offset-1 rounded-3xl">
                                        <a class=" text-third-text-color text-xl"
                                           target="_blank" rel="noopener" href="https://github.com/fetch150zy">GITHUB</a>
                                    </div>
                                
                            </div>
                        
                    </li>
            

            
            
                
                    
                    
                    <li class="drawer-navbar-item text-base my-1.5 flex flex-col w-full">
                        <a class="py-1.5 px-2 flex flex-row items-center justify-between gap-1 hover:!text-primary active:!text-primary text-2xl font-semibold group border-b border-border-color hover:border-primary w-full active"
                           href="/tags"
                        >
                            <span>Tags</span>
                            <i class="fa-regular fa-tags fa-sm fa-fw"></i>
                        </a>
                    </li>
                
                    
                    <li class="drawer-navbar-item text-base my-1.5 flex flex-col w-full">
                        <a class="py-1.5 px-2 flex flex-row items-center justify-between gap-1 hover:!text-primary active:!text-primary text-2xl font-semibold group border-b border-border-color hover:border-primary w-full active"
                           href="/categories"
                        >
                            <span>Categories</span>
                            <i class="fa-regular fa-folder fa-sm fa-fw"></i>
                        </a>
                    </li>
                
            
        </ul>

        <div class="statistics flex justify-around my-2.5">
    <a class="item tag-count-item flex flex-col justify-center items-center w-20" href="/tags">
        <div class="number text-2xl sm:text-xl text-second-text-color font-semibold">21</div>
        <div class="label text-third-text-color text-sm">标签</div>
    </a>
    <a class="item tag-count-item flex flex-col justify-center items-center w-20" href="/categories">
        <div class="number text-2xl sm:text-xl text-second-text-color font-semibold">18</div>
        <div class="label text-third-text-color text-sm">分类</div>
    </a>
    <a class="item tag-count-item flex flex-col justify-center items-center w-20" href="/archives">
        <div class="number text-2xl sm:text-xl text-second-text-color font-semibold">54</div>
        <div class="label text-third-text-color text-sm">文章</div>
    </a>
</div>
    </div>

    <div class="window-mask"></div>

</header>


        </div>

        <div class="main-content-body">

            

            <div class="main-content">

                
                    <div class="post-page-container flex relative justify-between box-border w-full h-full">
    <div class="article-content-container">

        <div class="article-title relative w-full">
            
                
                
                <img src="/../img/bg/11.png" alt="C语言" class="w-full h-60 sm:h-72 md:h-80 object-cover sm:rounded-t-large dark:brightness-75"/>
                
                <div class="w-full flex items-center absolute bottom-0 justify-center">
                    <h1 class="article-title-cover text-center mx-6 my-6 text-second-text-color bg-background-color-transparent px-4 py-3 text-3xl sm:text-4xl md:text-5xl font-bold backdrop-blur-lg rounded-xl border border-border-color ">C语言</h1>
                </div>
            
            </div>

        
            <div class="article-header flex flex-row gap-2 items-center px-2 sm:px-6 md:px-8">
                <div class="avatar w-[46px] h-[46px] flex-shrink-0 rounded-medium border border-border-color p-[1px]">
                    <img src="/img/avatar.jpg">
                </div>
                <div class="info flex flex-col justify-between">
                    <div class="author flex items-center">
                        <span class="name text-default-text-color text-lg font-semibold">fetch150zy</span>
                        
                    </div>
                    <div class="meta-info">
                        <div class="article-meta-info">
    <span class="article-date article-meta-item">
        <i class="fa-regular fa-pen-fancy"></i>&nbsp;
        <span class="desktop">2022-01-20 17:07:46</span>
        <span class="mobile">2022-01-20 17:07:46</span>
        <span class="hover-info">创建</span>
    </span>
    
        <span class="article-date article-meta-item">
            <i class="fa-regular fa-wrench"></i>&nbsp;
            <span class="desktop">2024-03-23 13:43:58</span>
            <span class="mobile">2024-03-23 13:43:58</span>
            <span class="hover-info">更新</span>
        </span>
    

    
        <span class="article-categories article-meta-item">
            <i class="fa-regular fa-folders"></i>&nbsp;
            <ul>
                
                
                    
                        
                        <li>
                            <a href="/categories/C/">C</a>&nbsp;
                        </li>
                    
                    
                
            </ul>
        </span>
    
    
        <span class="article-tags article-meta-item">
            <i class="fa-regular fa-tags"></i>&nbsp;
            <ul>
                
                    <li>
                        <a href="/tags/C%E8%AF%AD%E8%A8%80/">C语言</a>&nbsp;
                    </li>
                
            </ul>
        </span>
    

    
    
    
    
</div>

                    </div>
                </div>
            </div>
        

        


        <div class="article-content markdown-body px-2 sm:px-6 md:px-8 pb-8">
            <p>cppreference 中的C文档<br>c primer plus第六版的笔记，包含c基础，代码规范及进阶技术<br>常用的c标准库函数</p>
<h1 id="cppreference-C"><a href="#cppreference-C" class="headerlink" title="cppreference - C"></a>cppreference - C</h1><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><h3 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h3><h4 id="C-风格注释"><a href="#C-风格注释" class="headerlink" title="C 风格注释"></a>C 风格注释</h4><div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 注释内容 */</span></span><br></pre></td></tr></table></figure></div>



<h4 id="C-风格注释-1"><a href="#C-风格注释-1" class="headerlink" title="C++ 风格注释"></a>C++ 风格注释</h4><div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 注释内容</span></span><br></pre></td></tr></table></figure></div>

<blockquote>
<p>  C 风格注释可出现在 C++ 风格注释中，反之亦然</p>
</blockquote>
<p><strong>注意：</strong></p>
<p>注释在预处理器阶段被移除，宏不能用于组成注释</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 试图用宏组成注释。 */</span></span><br><span class="line"><span class="comment">/* 但空格替换字符 &quot;//&quot; 。 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> DEBUG</span></span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> PRINTF <span class="comment">//</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> PRINTF printf</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">...  </span><br><span class="line">PRINTF(<span class="string">&quot;Error in file %s at line %i\n&quot;</span>, __FILE__, __LINE__);</span><br></pre></td></tr></table></figure></div>



<h3 id="ASCII"><a href="#ASCII" class="headerlink" title="ASCII"></a>ASCII</h3><h4 id="打印ASCII码表"><a href="#打印ASCII码表" class="headerlink" title="打印ASCII码表"></a>打印ASCII码表</h4><div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;Printable ASCII:&quot;</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">32</span>; i &lt; <span class="number">127</span>; ++i) &#123;</span><br><span class="line">    <span class="built_in">putchar</span>(i);</span><br><span class="line">    <span class="built_in">putchar</span>(i % <span class="number">16</span> == <span class="number">15</span> ? <span class="string">&#x27;\n&#x27;</span> : <span class="string">&#x27; &#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">putchar</span>(<span class="string">&#x27;\n&#x27;</span>);</span><br></pre></td></tr></table></figure></div>



<h3 id="转义序列"><a href="#转义序列" class="headerlink" title="转义序列"></a>转义序列</h3><table>
<thead>
<tr>
<th align="center">转义序列</th>
<th align="center">描述</th>
<th align="center">表示</th>
</tr>
</thead>
<tbody><tr>
<td align="center">\ ‘</td>
<td align="center">单引号</td>
<td align="center">0x27</td>
</tr>
<tr>
<td align="center">\ “</td>
<td align="center">双引号</td>
<td align="center">0x22</td>
</tr>
<tr>
<td align="center">\ ?</td>
<td align="center">问号</td>
<td align="center">0x3f</td>
</tr>
<tr>
<td align="center">\ \</td>
<td align="center">反斜杠</td>
<td align="center">0x5c</td>
</tr>
<tr>
<td align="center">\ a</td>
<td align="center">响铃</td>
<td align="center">0x07</td>
</tr>
<tr>
<td align="center">\ b</td>
<td align="center">退格</td>
<td align="center">0x08</td>
</tr>
<tr>
<td align="center">\ f</td>
<td align="center">换页</td>
<td align="center">0x0c</td>
</tr>
<tr>
<td align="center">\ n</td>
<td align="center">换行</td>
<td align="center">0x0a</td>
</tr>
<tr>
<td align="center">\ r</td>
<td align="center">回车</td>
<td align="center">0x0d</td>
</tr>
<tr>
<td align="center">\ t</td>
<td align="center">水平制表</td>
<td align="center">0x09</td>
</tr>
<tr>
<td align="center">\ v</td>
<td align="center">垂直制表</td>
<td align="center">0x0b</td>
</tr>
<tr>
<td align="center">\ nnn</td>
<td align="center">任意八进制</td>
<td align="center">nnn</td>
</tr>
<tr>
<td align="center">\ Xnn</td>
<td align="center">任意十六进制</td>
<td align="center">nn</td>
</tr>
<tr>
<td align="center">\ Unnnn</td>
<td align="center">Unicode</td>
<td align="center">U+nnnn</td>
</tr>
<tr>
<td align="center">\ Unnnnnnnn</td>
<td align="center">Unicode</td>
<td align="center">U+nnnnnnnn</td>
</tr>
</tbody></table>
<blockquote>
<p>  控制字符：<code>0x00 ~ 0x1f</code></p>
</blockquote>
<ul>
<li><code>&#39;\0&#39;</code>：字符串中的空终止字符</li>
<li><code>&#39;\?&#39;</code>：阻止在字符串字面量内转译<code>三标符</code></li>
</ul>
<h3 id="翻译阶段"><a href="#翻译阶段" class="headerlink" title="翻译阶段"></a>翻译阶段</h3><h4 id="阶段一"><a href="#阶段一" class="headerlink" title="阶段一"></a>阶段一</h4><blockquote>
<p>  映射源文件中的单独字节为源字符集的字符；以对应的单字节表示替换三标符</p>
</blockquote>
<h4 id="阶段二"><a href="#阶段二" class="headerlink" title="阶段二"></a>阶段二</h4><blockquote>
<p>  反斜杠在行尾，删除反斜杠和后面跟随的换行符</p>
</blockquote>
<h4 id="阶段三"><a href="#阶段三" class="headerlink" title="阶段三"></a>阶段三</h4><blockquote>
<p>  将源文件分解为（注释）（空白字符）（序列）（预处理记号）（预处理记号）</p>
<ul>
<li>头文件名：<code>&lt;stdio.h&gt;</code>或<code>&quot;myfile.h&quot;</code></li>
<li>标识符</li>
<li>预处理数字</li>
<li>字符常量和字符串字面量</li>
<li>运算符与标点</li>
<li>其他类别的单独非空字符</li>
</ul>
<p>  以一个空格字符替换每段注释</p>
<p>  保持换行符</p>
</blockquote>
<p><strong>最大吞噬：</strong>通常将能构成一个预处理记号的最长字符序列处理成下个预处理记号</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> foo = <span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> bar = <span class="number">0xE</span>+foo;   <span class="comment">// 错误：非法的预处理数字 0xE+foo</span></span><br><span class="line"><span class="type">int</span> baz = <span class="number">0xE</span> + foo; <span class="comment">// OK</span></span><br><span class="line"><span class="type">int</span> quux = bar+++++baz; <span class="comment">// 错误： bar++ ++ +baz ，而非 bar++ + ++baz </span></span><br></pre></td></tr></table></figure></div>

<p>最大吞噬规则的单独例外是：</p>
<ul>
<li><p>头文件名预处理记号仅在<code>#include</code>指令和<code>#pragma</code>指令中的实现定义位置形成</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MACRO_1 1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MACRO_2 2</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MACRO_3 3</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MACRO_EXPR (MACRO_1 <span class="string">&lt;MACRO_2&gt;</span> MACRO_3) <span class="comment">// OK ： &lt;MACRO_2&gt; 不是头文件名</span></span></span><br></pre></td></tr></table></figure></div></li>
</ul>
<h4 id="阶段四"><a href="#阶段四" class="headerlink" title="阶段四"></a>阶段四</h4><blockquote>
<p>  执行预处理器</p>
<p>  <code>#include</code>指令所引入的每个文件都经历了1 到 4，递归执行</p>
<p>  该阶段结束，从源码移除所有的预处理器指令</p>
</blockquote>
<h4 id="阶段五"><a href="#阶段五" class="headerlink" title="阶段五"></a>阶段五</h4><blockquote>
<p>  将字符常量及字符串字面量中的所有字符及转义序列从源字符集转换成执行字符集</p>
</blockquote>
<h4 id="阶段六"><a href="#阶段六" class="headerlink" title="阶段六"></a>阶段六</h4><blockquote>
<p>  连接相邻的字符串字面量</p>
</blockquote>
<h4 id="阶段七"><a href="#阶段七" class="headerlink" title="阶段七"></a>阶段七</h4><blockquote>
<p>  发生编译：按照语法和语义分析记号，并将它们翻译成翻译单元</p>
</blockquote>
<h4 id="阶段八"><a href="#阶段八" class="headerlink" title="阶段八"></a>阶段八</h4><blockquote>
<p>  发生链接：将翻译单元和满足外部引用所需的库组件到汇集成程序映像，它含有OS中执行的所需信息</p>
</blockquote>
<h3 id="标点"><a href="#标点" class="headerlink" title="标点"></a>标点</h3><p><a class="link"   target="_blank" rel="noopener" href="https://zh.cppreference.com/w/c/language/punctuators" >https://zh.cppreference.com/w/c/language/punctuators <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<h3 id="标识符"><a href="#标识符" class="headerlink" title="标识符"></a>标识符</h3><blockquote>
<p>  标识符是数字、下划线、小写及大写拉丁字母和Unicode字符的任意长度序列</p>
</blockquote>
<p>注意： C++ 中，在任何位置有双下划线的标识符都被保留； C 中，只有以双下划线开始的标识符被保留</p>
<h3 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h3><p>C 拥有四种作用域：</p>
<ul>
<li>块作用域</li>
<li>文件作用域</li>
<li>函数作用域</li>
<li>函数原型作用域</li>
</ul>
<h4 id="嵌套作用域"><a href="#嵌套作用域" class="headerlink" title="嵌套作用域"></a>嵌套作用域</h4><div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a;   <span class="comment">// （文件作用域）</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">fx</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">1</span>; <span class="comment">// （函数作用域）隐藏文件作用域的 a</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="type">int</span> a = <span class="number">2</span>;         <span class="comment">// （块作用域）隐藏外界 a</span></span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, a);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, a);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">gx</span><span class="params">(<span class="type">int</span> a)</span>;   <span class="comment">// （函数声明作用域）</span></span><br></pre></td></tr></table></figure></div>



<h4 id="块作用域"><a href="#块作用域" class="headerlink" title="块作用域"></a>块作用域</h4><p><strong>（块作用域对象默认无链接并拥有自动存储期）</strong></p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> &#123;</span>a, b&#125;;</span><br><span class="line"><span class="type">int</span> <span class="title function_">different</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">sizeof</span>(<span class="keyword">enum</span> &#123;b, a&#125;) != <span class="keyword">sizeof</span>(<span class="type">int</span>))</span><br><span class="line">        <span class="keyword">return</span> a; <span class="comment">// a == 1</span></span><br><span class="line">    <span class="keyword">return</span> b; <span class="comment">// C89 中 b == 0 ， C99 中 b == 1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<blockquote>
<p>  C99前，选择和迭代语句不建立其自身的块作用域</p>
</blockquote>
<h4 id="文件作用域"><a href="#文件作用域" class="headerlink" title="文件作用域"></a>文件作用域</h4><p><strong>（文件作用域的标识符默认拥有外部链接和静态存储期）</strong></p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i; <span class="comment">// i 的作用域开始</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">g</span><span class="params">(<span class="type">int</span> a)</span> &#123; <span class="keyword">return</span> a; &#125; <span class="comment">// g 的作用域开始（注意 &quot;a&quot; 拥有块作用域）</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    i = g(<span class="number">2</span>); <span class="comment">// i 和 g 在作用域中</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>



<h4 id="函数作用域"><a href="#函数作用域" class="headerlink" title="函数作用域"></a>函数作用域</h4><blockquote>
<p>  声明于函数内部的标号（且只有标号），在该函数中的所有位置（所有嵌套块中，其自身声明前后）都在作用域内</p>
</blockquote>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">f</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">   &#123;   </span><br><span class="line">       <span class="keyword">goto</span> label; <span class="comment">// label 在作用域中，尽管之后才声明</span></span><br><span class="line">label:;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">goto</span> label; <span class="comment">// 标号忽略块作用域</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="type">void</span> <span class="title function_">g</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">goto</span> label; <span class="comment">// 错误： g() 中 label 不在作用域中</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>



<h4 id="函数原型作用域"><a href="#函数原型作用域" class="headerlink" title="函数原型作用域"></a>函数原型作用域</h4><div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">f</span><span class="params">(<span class="type">int</span> n,</span></span><br><span class="line"><span class="params">      <span class="type">int</span> a[n])</span>; <span class="comment">// n 在作用域中并指代第一参数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">f</span> <span class="params">( <span class="comment">// 函数名 &#x27;f&#x27; 在文件作用域</span></span></span><br><span class="line"><span class="params"> <span class="type">long</span> <span class="type">double</span> f,            <span class="comment">// 标识符 &#x27;f&#x27; 现在在作用域中，隐藏文件作用域的 &#x27;f&#x27;</span></span></span><br><span class="line"><span class="params"> <span class="type">char</span> (**a)[<span class="number">10</span> * <span class="keyword">sizeof</span> f] <span class="comment">// &#x27;f&#x27; 指代第一参数，它在作用域中</span></span></span><br><span class="line"><span class="params">)</span>;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">enum</span>&#123;</span> n = <span class="number">3</span> &#125;;</span><br><span class="line"><span class="type">int</span> (*(*g)(<span class="type">int</span> n))[n]; <span class="comment">// 函数参数 &#x27;n&#x27; 的作用域在其函数声明器的结尾结束</span></span><br><span class="line">                       <span class="comment">// 数组声明器中，全局 n 在作用域</span></span><br><span class="line"><span class="comment">// （这声明指向返回 3 个 int 的数组的指针的函数的指针）</span></span><br></pre></td></tr></table></figure></div>



<h4 id="声明点"><a href="#声明点" class="headerlink" title="声明点"></a>声明点</h4><ul>
<li><p>结构体、联合体及枚举标签的作用域，在声明该标签的类型指定符中的标签出现后立即开始</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">next</span>;</span> <span class="comment">// Node 在作用域中并指代此 struct</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>
</li>
<li><p>枚举常量的作用域，在枚举项列表中其定义枚举项的出现后立即开始</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> &#123;</span> x = <span class="number">12</span> &#125;;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">enum</span> &#123;</span> x = x + <span class="number">1</span>, <span class="comment">// 新 x 在逗号前不在作用域中，初始化 x 为 13</span></span><br><span class="line">           y = x + <span class="number">1</span>  <span class="comment">// 新枚举项 x 现在在作用域中，初始化 y 为 14</span></span><br><span class="line">         &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></li>
</ul>
<p><strong>注意：</strong></p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">foo</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">baz</span> &#123;</span>&#125;;</span><br><span class="line">    <span class="class"><span class="keyword">enum</span> <span class="title">color</span> &#123;</span>RED, BLUE&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">baz</span> <span class="title">b</span>;</span> <span class="comment">// baz 在作用域中</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">color</span> <span class="title">x</span> =</span> RED; <span class="comment">// color 和 RED 在作用域中</span></span><br></pre></td></tr></table></figure></div>



<h3 id="生存期"><a href="#生存期" class="headerlink" title="生存期"></a>生存期</h3><blockquote>
<p>  在生存期外访问对象是未定义行为</p>
</blockquote>
<h4 id="临时生存期"><a href="#临时生存期" class="headerlink" title="临时生存期"></a>临时生存期</h4><div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">T</span> &#123;</span> <span class="type">double</span> a[<span class="number">4</span>]; &#125;;</span><br><span class="line"><span class="keyword">struct</span> T <span class="title function_">f</span><span class="params">(<span class="type">void</span>)</span> &#123; <span class="keyword">return</span> (<span class="keyword">struct</span> T)&#123;<span class="number">3.15</span>&#125;; &#125;</span><br><span class="line"><span class="type">double</span> <span class="title function_">g1</span><span class="params">(<span class="type">double</span>* x)</span> &#123; <span class="keyword">return</span> *x; &#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">g2</span><span class="params">(<span class="type">double</span>* x)</span> &#123; *x = <span class="number">1.0</span>; &#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">double</span> d = g1(f().a); <span class="comment">// C99 ： UB 访问生存期结束于 g1 开序列点的 a[0]</span></span><br><span class="line">                          <span class="comment">// C11 ： OK ， d 为 3.15</span></span><br><span class="line">    g2(f().a); <span class="comment">// C99 ： UB 修改生存期结束于序列点的 a[0]</span></span><br><span class="line">               <span class="comment">// C11 ： UB 试图修改临时对象</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>



<h3 id="查找与命名空间"><a href="#查找与命名空间" class="headerlink" title="查找与命名空间"></a>查找与命名空间</h3><blockquote>
<p>  在C 程序中遇到标识符时，会查找定位引入该标识符，并且当前在作用域内的声明。弱同一标识符的多个声明属于称作“命名空间”的相异类别，则C 允许它们同时存在于作用域内</p>
</blockquote>
<ul>
<li>标号命名空间：所有声明为标号的标识符</li>
<li>标签名：所有声明为<code>struct union enum</code>名称的标识符，三种标签共享同一命名空间</li>
<li>成员名：所有声明为至少一个<code>struct 或 union</code>成员的标识符，每个结构和联合引入它自己的这种命名空间</li>
<li>所有其他标识符，称之为“通常标识符”（函数名，对象名，typedef名，枚举常量）</li>
</ul>
<blockquote>
<p>  在查找点，根据使用方式确定标识符所属的命名空间</p>
</blockquote>
<ul>
<li>作为<code>goto</code>语句运算符出现的标识符，会在标号命名空间中查找</li>
<li>后随关键词<code>struct union enum</code>的标识符，会在标签命名空间中查找</li>
<li>后随成员访问或通过指针的成员访问运算符的标识符，会在类型成员命名空间中查找，该类型由成员访问运算符左运算数确定</li>
<li>所有其他标识符，会在通常命名空间中查找</li>
</ul>
<h4 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h4><blockquote>
<p>  宏名不是任何命名空间的一部分，因为语义分析前，预处理器会替换它们</p>
<p>  一个常见的举措是将<code>struct/union/enum</code>名称注入通常命名空间，以typedef声明</p>
</blockquote>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">A</span> &#123;</span> &#125;;       <span class="comment">// 于标签命名空间中引入名称A</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">A</span> <span class="title">A</span>;</span> <span class="comment">// 首先，对&quot;struct&quot;后A的查找找到标签命名空间的一个</span></span><br><span class="line">                    <span class="comment">// 然后将名称A引入通常命名空间</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">A</span>* <span class="title">p</span>;</span>        <span class="comment">// OK，此A于标签命名空间中查找</span></span><br><span class="line">A* q;               <span class="comment">// OK，此A于通常命名空间中查找</span></span><br></pre></td></tr></table></figure></div>

<blockquote>
<p>  不同于 C++ 中，枚举常量不是结构体成员，而且其命名空间是通常标识符的命名空间，故而 C 中无结构体作用域，其作用域是出现结构体声明的作用域</p>
</blockquote>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tagged_union</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">   <span class="class"><span class="keyword">enum</span> &#123;</span>INT, FLOAT, STRING&#125; type;</span><br><span class="line">   <span class="type">int</span> integer;</span><br><span class="line">   <span class="type">float</span> floating_point;</span><br><span class="line">   <span class="type">char</span> *<span class="built_in">string</span>;</span><br><span class="line">&#125; tu;</span><br><span class="line"> </span><br><span class="line">tu.type = INT; <span class="comment">// C 中 OK ， C++ 中错误</span></span><br></pre></td></tr></table></figure></div>



<h3 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h3><h4 id="类型分类"><a href="#类型分类" class="headerlink" title="类型分类"></a>类型分类</h4><ul>
<li>类型<code>void</code></li>
<li>基本类型<ul>
<li>类型<code>char</code></li>
<li>有符号整数类型<ul>
<li>标准：<code>signed char</code>、<code>short</code>、<code>int</code>、<code>long</code>、<code>long long</code></li>
<li>扩展：<code>__int128</code> C99</li>
</ul>
</li>
<li>无符号整数类型<ul>
<li>标准：<code>_Bool</code> 、<code>unsigned char</code>、<code>unsigned short</code>、<code>unsigned int</code>、<code>unsigned long</code>、<code>unsigned long long</code></li>
<li>扩展：<code>__uint128</code> C99</li>
</ul>
</li>
<li>浮点类型<ul>
<li>实浮点类型：<code>float</code>、<code>double</code>、<code>long double</code></li>
<li>十进制实浮点类型：<code>_Decimal32</code>、<code>_Decimal64</code>、<code>_Decimal128</code> C23</li>
<li>虚数类型：<code>float _Imaginary</code>、<code>double _Imaginary</code>、<code>long double _Imaginary</code></li>
<li>复数类型：<code>float _Complex</code>、<code>double _Complex</code>、<code>long double _Complex</code></li>
</ul>
</li>
</ul>
</li>
<li>枚举类型</li>
<li>派生类型<ul>
<li>数组类型</li>
<li>结构体类型</li>
<li>联合体类型</li>
<li>函数类型</li>
<li>指针类型</li>
<li>原子类型 C11</li>
</ul>
</li>
</ul>
<blockquote>
<p>  对于上面列出的每个类型，可以存在数种其类型的限定版本，对应<code>const</code>、<code>volatile</code>、<code>restrict</code>的组合</p>
</blockquote>
<h4 id="类型组别"><a href="#类型组别" class="headerlink" title="类型组别"></a>类型组别</h4><ul>
<li>对象类型：所有不是函数类型的类型</li>
<li>字符类型：<code>char</code>、<code>signed char</code>、<code>unsigned char</code></li>
<li>整数类型：<code>char</code>、有符号整数类型、无符号整数类型、枚举类型</li>
<li>实数类型：整数类型和实浮点类型</li>
<li>算数类型：整数类型和浮点类型</li>
<li>标量类型：算术类型和指针类型以及<code>nullptr_t</code>C23</li>
<li>聚合类型：数组类型和结构体类型</li>
<li>派生声明器类型：数组类型、函数类型和指针类型</li>
</ul>
<h4 id="兼容类型"><a href="#兼容类型" class="headerlink" title="兼容类型"></a>兼容类型</h4><blockquote>
<p>  在不同翻译单元中涉及同一对象或函数的声明，不必拥有相同类型，它们只需要拥有相似的类型，也就是兼容类型</p>
<p>  同样的规则应用到函数调用和左值访问，实参类型必须与形参类型兼容，而左值表达式类型必须与被访问对象的类型兼容</p>
</blockquote>
<p>以下类型兼容：</p>
<ul>
<li>它们是同一类型（同名或由<code>typedef</code>引入的别名）</li>
<li>它们是兼容的无限定类型的等同cvr限定版本</li>
<li>它们是指针类型，并指向兼容类型</li>
<li>它们是数组类型，并且<ul>
<li>其元素类型兼容</li>
<li>若都拥有常量大小，则大小相同；未知边界数组与任何兼容元素类型的数组兼容</li>
</ul>
</li>
<li>它们都是结构体、联合体、枚举类型，并且<ul>
<li>若一者以标签声明，则另一者必须以同一标签声明</li>
<li>若它们都是完整类型，则其成员必须在数量上准确对应，以兼容类型声明，并拥有匹配的名称</li>
<li>另外，若它们都是枚举，则对应成员亦必须拥有相同值</li>
<li>另外，若它们是结构体或联合体，则<ul>
<li>对应的元素必须以同一顺序声明（仅结构体）</li>
<li>对应的位域必须有相同宽度</li>
</ul>
</li>
</ul>
</li>
<li>一者为枚举类型，而另一者为该枚举的底层类型</li>
<li>它们是函数类型，且<ul>
<li>其返回类型兼容</li>
<li>它们都使用参数列表，参数数量（包括省略号的使用）相同，而其对应参数，在应用数组到指针和函数到指针类型调整，及剥除顶层限定符后，拥有相同类型</li>
<li>一个是旧式（无参数）定义，另一个有参数列表，参数列表不使用省略号，而每个参数（在函数参数类型调整后）都与默认参数提升后的对应旧式参数兼容</li>
<li>一个是旧式（无参数）声明，另一个拥有参数列表，参数列表不使用省略号，而所有参数（在函数参数类型调整后）不受默认参数提升影响</li>
</ul>
</li>
</ul>
<p>类型<code>char</code>既不与<code>signed char</code>兼容，也不与<code>unsigned char</code>兼容</p>
<h4 id="合成类型"><a href="#合成类型" class="headerlink" title="合成类型"></a>合成类型</h4><p>合成类型能从二个兼容的类型构造；它是与两个类型兼容，并满足下列条件的类型：</p>
<ul>
<li><p>若两个类型均为数组类型</p>
<ul>
<li>若一个类型是常量大小数组，则合成类型为该大小的数组</li>
<li>否则，若一个类型为VLA，其大小由表达式指定且表达式尚未求值，则需要两个类型的合成类型的程序有未定义行为</li>
<li>否则，若一个类型为已指定大小的VLA，则合成类型为该大小的VLA</li>
<li>否则，若一个类型为未定大小的VLA，则该合成类型为未指定大小的VLA</li>
<li>否则，两个数组类型都有未知大小，而合成类型为未知大小的数组</li>
</ul>
<p>合成类型的元素类型是两个元素类型的合成类型</p>
</li>
<li><p>若一个类型是有参数类型列表（函数原型）的函数类型，则合成类型为有该参数类型列表的函数原型</p>
</li>
<li><p>若两个类型均为有参数类型列表的函数类型，则合成类型的参数类型列表中的每个参数类型，是对应参数的合成类型</p>
</li>
</ul>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 给定一下二个文件作用域声明：</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">f</span><span class="params">(<span class="type">int</span> (*)(), <span class="type">double</span> (*)[<span class="number">3</span>])</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">f</span><span class="params">(<span class="type">int</span> (*)(<span class="type">char</span> *), <span class="type">double</span> (*)[])</span>;</span><br><span class="line"><span class="comment">// 生成的函数合成类型为：</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">f</span><span class="params">(<span class="type">int</span> (*)(<span class="type">char</span> *), <span class="type">double</span> (*)[<span class="number">3</span>])</span>;</span><br></pre></td></tr></table></figure></div>

<blockquote>
<p>  对于拥有内部或外部链接，并在其先前声明已经可见的作用域中再次声明的标识符，若先前的声明指定了内部或外部链接，则在后一声明中的标识符类型成为合成类型</p>
</blockquote>
<h4 id="不完整类型"><a href="#不完整类型" class="headerlink" title="不完整类型"></a>不完整类型</h4><p>不完整类型是缺乏足以确定其对象大小的信息对象类型。不完整类型可以在翻译单元的某些点完整</p>
<p>下列类型不完整：</p>
<ul>
<li><p>类型<code>void</code>，此类型不能完整</p>
</li>
<li><p>大小未知的数组，之后指定代销的声明能使之完整</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="type">char</span> a[]; <span class="comment">// a 的类型不完整（这通常出现于头文件）</span></span><br><span class="line"><span class="type">char</span> a[<span class="number">10</span>];      <span class="comment">// a 的类型现在完整（这通常出现于源文件）</span></span><br></pre></td></tr></table></figure></div>
</li>
<li><p>内容未知的结构体或联合体类型，在同一作用域的后面，定义同一结构体或联合体的内容的声明能使之完整</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">node</span> *<span class="title">next</span>;</span> <span class="comment">// struct node 在此点不完整</span></span><br><span class="line">&#125;; <span class="comment">// struct node 在此点完整</span></span><br></pre></td></tr></table></figure></div></li>
</ul>
<h4 id="类型名"><a href="#类型名" class="headerlink" title="类型名"></a>类型名</h4><div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> n; <span class="comment">// 声明 int </span></span><br><span class="line"><span class="keyword">sizeof</span>(<span class="type">int</span>); <span class="comment">// 使用类型名</span></span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> *a[<span class="number">3</span>]; <span class="comment">// 声明 3 个指向 int 指针的数组</span></span><br><span class="line"><span class="keyword">sizeof</span>(<span class="type">int</span> *[<span class="number">3</span>]); <span class="comment">// 使用类型名</span></span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> (*p)[<span class="number">3</span>]; <span class="comment">// 声明指向 3 个 int 的数组的指针</span></span><br><span class="line"><span class="keyword">sizeof</span>(<span class="type">int</span> (*)[<span class="number">3</span>]); <span class="comment">// 使用类型名</span></span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> (*a)[*] <span class="comment">// （在函数参数中）声明指向 VLA 的指针</span></span><br><span class="line"><span class="keyword">sizeof</span>(<span class="type">int</span> (*)[*]) <span class="comment">// （在函数参数中）使用类型名</span></span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> *<span class="title function_">f</span><span class="params">(<span class="type">void</span>)</span>; <span class="comment">// 声明函数</span></span><br><span class="line"><span class="keyword">sizeof</span>(<span class="type">int</span> *(<span class="type">void</span>)); <span class="comment">// 使用类型名</span></span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> (*p)(<span class="type">void</span>); <span class="comment">// 声明指向函数指针</span></span><br><span class="line"><span class="keyword">sizeof</span>(<span class="type">int</span> (*)(<span class="type">void</span>)); <span class="comment">// 使用类型名</span></span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> (*<span class="type">const</span> a[])(<span class="type">unsigned</span> <span class="type">int</span>, ...) = &#123;<span class="number">0</span>&#125;; <span class="comment">// 声明指向函数指针的数组</span></span><br><span class="line"><span class="keyword">sizeof</span>(<span class="type">int</span> (*<span class="type">const</span> [])(<span class="type">unsigned</span> <span class="type">int</span>, ...)); <span class="comment">// 使用类型名</span></span><br></pre></td></tr></table></figure></div>

<p>除了围绕标识符的冗余括号在类型名中有意义，并表示“不指定参数的函数”</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> (n); <span class="comment">// 声明 int 类型的 n</span></span><br><span class="line"><span class="keyword">sizeof</span>(<span class="type">int</span> ()); <span class="comment">// 使用类型“返回 int 的函数”</span></span><br></pre></td></tr></table></figure></div>

<p><strong>类型名用于下列场合：</strong></p>
<ul>
<li>转型运算符</li>
<li><code>sizeof</code></li>
<li>复合字面量</li>
<li>泛型选择</li>
<li><code>_Alignof</code></li>
<li><code>_Alignas</code></li>
<li><code>_Atomic</code></li>
</ul>
<p>类型名可引入新类型：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span>* p = (<span class="type">void</span>*)(<span class="keyword">struct</span> X &#123;<span class="type">int</span> i;&#125; *)<span class="number">0</span>;</span><br><span class="line"><span class="comment">// 用于转型表达式的 &quot;struct X &#123;int i;&#125;*&quot;</span></span><br><span class="line"><span class="comment">// 引入新类型 &quot;struct X&quot;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">X</span> <span class="title">x</span> =</span> &#123;<span class="number">1</span>&#125;; <span class="comment">// struct X 现在在作用域中</span></span><br></pre></td></tr></table></figure></div>



<h3 id="对象与对齐"><a href="#对象与对齐" class="headerlink" title="对象与对齐"></a>对象与对齐</h3><p>C 中，一个对象是执行环境中数据存储的一个区域，其内容可以表示值（值是对象的内容转译为特定类型时的含义）</p>
<ul>
<li>大小（可由<code>sizeof</code>确定）</li>
<li>对齐要求（可由<code>_Alignof</code>确定）</li>
<li>存储期（自动、静态、分配、线程局域）</li>
<li>生存期（等于存储期或临时）</li>
<li>有效类型</li>
<li>值（可以是不确定的）</li>
<li>可选项，表示该对象的标识符</li>
</ul>
<p>对象由声明、分配函数、字符串字面量、复合字面量，及返回拥有数组类型的结构体或联合体的非左值表达式创建</p>
<h4 id="对象表示"><a href="#对象表示" class="headerlink" title="对象表示"></a>对象表示</h4><p>除了位域，每个对象都是由一个或更多字节组成的，每个字节由<code>CHAR_BIT</code>位组成，而且每个对象可以用<code>memcpy</code>复制到<code>unsigned char[n]</code>类型的对象中，这里n是对象的大小，生成的数组内容被称为对象表示</p>
<p>若两个对象拥有相同的对象表示，则它们比较相等（除了浮点数NaN的情况）</p>
<p>若一个对象不表示该对象类型的任意值，则它被称为陷阱表示。以异于字符类型左值表达式读取的方式访问陷阱表示是未定义行为。结构体或联合体的值始终不是陷阱表示，即使任何一个成员的值是陷阱表示</p>
<p>整数类型：大端小端存储</p>
<h4 id="有效类型"><a href="#有效类型" class="headerlink" title="有效类型"></a>有效类型</h4><p>每个对象都拥有有效类型，它决定何种左值访问合法，何种违反严格别名使用规则</p>
<p>若对象是由声明创建的，则该对象的声明类型即是对象的有效类型</p>
<p>若对象是由分配函数<code>realloc</code>创建，则它没有声明类型，这种对象以下列方式获得有效类型：</p>
<ul>
<li>首次通过拥有异于字符类型的类型的左值写入该对象，无论何时该左值的类型都会成为该对象该次写入和所有后继读取的有效类型</li>
<li><code>memcpy</code>或<code>memmove</code>复制另一个对象到该对象，无论何时源对象的有效类型（若它有）都会成为该对象该次写入和所有后继读取的有效类型</li>
<li>任何其他对无声明类型的对象的访问，有效类型是访问所用的左值类型</li>
</ul>
<h4 id="严格别名使用"><a href="#严格别名使用" class="headerlink" title="严格别名使用"></a>严格别名使用</h4><p>给定一个拥有有效类型T1的对象，使用相异类型的T2左值表达式（典型的是解引用指针）访问它是未定义行为，除非：</p>
<ul>
<li>T2和T1是兼容类型</li>
<li>T2和T1兼容的类型的cvr限定版本</li>
<li>T2和T1兼容的类型的有符号或无符号版本</li>
<li>T2是聚合体或联合体类型，其成员中包含一个前述类型（递归地包括子聚合体或被包含联合体的成员）</li>
<li>T2是字符类型（<code>char</code>、<code>signed char</code>、<code>unsigned char</code>）</li>
</ul>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i = <span class="number">7</span>;</span><br><span class="line"><span class="type">char</span>* pc = (<span class="type">char</span>*)(&amp;i);</span><br><span class="line"><span class="keyword">if</span>(pc[<span class="number">0</span>] == <span class="string">&#x27;\x7&#x27;</span>) &#123; <span class="comment">// 通过 char 别名使用是 OK 的</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;This system is little-endian&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;This system is big-endian&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="type">float</span>* pf = (<span class="type">float</span>*)(&amp;i);</span><br><span class="line"><span class="type">float</span> d = *pf; <span class="comment">// UB ： float 左值 *p 不能用来访问 int</span></span><br></pre></td></tr></table></figure></div>

<p>这些规则控制接受二个指针的函数，在通过一个指针写入后，是否必须重读取另一个</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// int* 与 double* 不能别名使用</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">f1</span><span class="params">(<span class="type">int</span> *pi, <span class="type">double</span> *pd, <span class="type">double</span> d)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 从 *pi 的读取可以只做一次，在循环前</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; *pi; i++) *pd++ = d;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">S</span> &#123;</span> <span class="type">int</span> a, b; &#125;;</span><br><span class="line"><span class="comment">// int* 和 struct S* 可以别名使用，因为 S 拥有 int 类型的成员</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">f2</span><span class="params">(<span class="type">int</span> *pi, <span class="keyword">struct</span> S *ps, <span class="keyword">struct</span> S s)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 从 *pi 的读取必须在每次通过 *ps 写入后进行</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; *pi; i++) *ps++ = s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p><strong>使用<code>restrict</code>限定符可用于指示第二个指针不可用作别名使用</strong></p>
<h4 id="对齐"><a href="#对齐" class="headerlink" title="对齐"></a>对齐</h4><blockquote>
<p>  每个完整对象类型拥有一个称作对齐要求的属性，它是一个<code>size_t</code>类型的整数值，表示此类型对象可以分配的相继地址之间的字节数。合法的对齐是二的非负次幂</p>
</blockquote>
<p>类型的对齐要求可以通过<code>_Alignof</code>获得</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">S</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">char</span> a; <span class="comment">// 成员对象大小： 1 ，对齐： 1</span></span><br><span class="line">    <span class="type">char</span> b; <span class="comment">// 成员对象大小： 1 ，对齐： 1</span></span><br><span class="line">&#125;; <span class="comment">// 结构体对象大小： 2 ，对齐： 1</span></span><br><span class="line"> </span><br></pre></td></tr></table></figure></div>

<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">X</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">int</span> n;  <span class="comment">// 成员对象大小： 4 ，对齐： 4</span></span><br><span class="line">    <span class="type">char</span> c; <span class="comment">// 成员对象大小： 1 ，对齐： 1</span></span><br><span class="line">    <span class="comment">// 剩余的三个字节进行空位填充</span></span><br><span class="line">&#125;; <span class="comment">// 结构体对象大小： 8 ，对齐： 4</span></span><br></pre></td></tr></table></figure></div>

<p>每个对象类型将其对齐要求强加于该类型的任何一个对象。所有类型中，最严格的基础对齐是<code>max_align_t</code>的对齐，最弱的对齐是字符类型（<code>char</code>、<code>signed char</code>、<code>unsigned char</code>）</p>
<blockquote>
<p>  若用<code>_Alignas</code>令一个对象的对齐严格于（大于）<code>max_align_t</code>，则他拥有扩展对齐要求，成员拥有扩展对齐的结构或联合体是过对齐类型。是否支持过对齐类型是实现定义的，而且对于每种存储期的支持可以不同</p>
</blockquote>
<h3 id="主函数"><a href="#主函数" class="headerlink" title="主函数"></a>主函数</h3><p>每个要在环境中运行的编码C 程序都含有称作<code>main</code>的函数定义，它是函数的受指定起始点</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span> &#123;&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv)</span> &#123;&#125;</span><br></pre></td></tr></table></figure></div>

<h4 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h4><ul>
<li><code>argc</code>：程序运行环境传递给程序的参数数量</li>
<li><code>argv</code>：参数列表</li>
</ul>
<h4 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h4><p>使用返回语句，则返回值会用隐式调用<code>exit()</code>的参数，<code>EXIT_SUCCESS</code>表示成功终止，<code>EXIT_FAILURE</code>表示不成功终止</p>
<h3 id="未定义行为"><a href="#未定义行为" class="headerlink" title="未定义行为"></a>未定义行为</h3><h4 id="UB与优化"><a href="#UB与优化" class="headerlink" title="UB与优化"></a>UB与优化</h4><p>正确的C 程序是没有未定义行为的，编译器可以在启动优化的条件下编译确实有UB的程序时，生成不期待的结果</p>
<h5 id="有符号溢出"><a href="#有符号溢出" class="headerlink" title="有符号溢出"></a>有符号溢出</h5><div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">foo</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> x+<span class="number">1</span> &gt; x; <span class="comment">// 真或为有符号溢出导致的 UB</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>



<h5 id="越界访问"><a href="#越界访问" class="headerlink" title="越界访问"></a>越界访问</h5><div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> table[<span class="number">4</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="type">int</span> <span class="title function_">exists_in_table</span><span class="params">(<span class="type">int</span> v)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 在最初的 4 个迭代中返回真或因为越界访问 UB</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">4</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (table[i] == v) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>



<h5 id="未初始化标量"><a href="#未初始化标量" class="headerlink" title="未初始化标量"></a>未初始化标量</h5><div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">_Bool</span> p; <span class="comment">// 未初始化局部变量</span></span><br><span class="line"><span class="keyword">if</span>(p) <span class="comment">// 访问未初始化标量是 UB</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;p is true&quot;</span>);</span><br><span class="line"><span class="keyword">if</span>(!p) <span class="comment">// 访问未初始化标量是 UB</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;p is false&quot;</span>);</span><br></pre></td></tr></table></figure></div>



<h5 id="非法标量"><a href="#非法标量" class="headerlink" title="非法标量"></a>非法标量</h5><div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">f</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">  <span class="type">_Bool</span> b = <span class="number">0</span>;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">char</span>* p =(<span class="type">unsigned</span> <span class="type">char</span>*)&amp;b;</span><br><span class="line">  *p = <span class="number">10</span>;</span><br><span class="line">  <span class="comment">// 从 b 读取现在是 UB</span></span><br><span class="line">  <span class="keyword">return</span> b == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>



<h5 id="空指针解引用"><a href="#空指针解引用" class="headerlink" title="空指针解引用"></a>空指针解引用</h5><div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">foo</span><span class="params">(<span class="type">int</span>* p)</span> &#123;</span><br><span class="line">    <span class="type">int</span> x = *p;</span><br><span class="line">    <span class="keyword">if</span>(!p) <span class="keyword">return</span> x; <span class="comment">// 为上述 UB ，或绝不采用此分支</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">bar</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span>* p = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> *p;       <span class="comment">// 无条件 UB</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>



<h5 id="访问传递给realloc的指针"><a href="#访问传递给realloc的指针" class="headerlink" title="访问传递给realloc的指针"></a>访问传递给realloc的指针</h5><div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="type">int</span> *p = (<span class="type">int</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">    <span class="type">int</span> *q = (<span class="type">int</span>*)<span class="built_in">realloc</span>(p, <span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">    *p = <span class="number">1</span>; <span class="comment">// 访问传递给 realloc 的指针是 UB</span></span><br><span class="line">    *q = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span> (p == q) <span class="comment">// 访问传递给 realloc 的指针是 UB</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d%d\n&quot;</span>, *p, *q);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>



<h5 id="无副效应的无限循环"><a href="#无副效应的无限循环" class="headerlink" title="无副效应的无限循环"></a>无副效应的无限循环</h5><div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> <span class="title function_">fermat</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="type">const</span> <span class="type">int</span> MAX = <span class="number">1000</span>;</span><br><span class="line">  <span class="type">int</span> a=<span class="number">1</span>,b=<span class="number">1</span>,c=<span class="number">1</span>;</span><br><span class="line">  <span class="comment">// 无副效应的无限循环是 UB</span></span><br><span class="line">  <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (((a*a*a) == ((b*b*b)+(c*c*c)))) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    a++;</span><br><span class="line">    <span class="keyword">if</span> (a&gt;MAX) &#123; a=<span class="number">1</span>; b++; &#125;</span><br><span class="line">    <span class="keyword">if</span> (b&gt;MAX) &#123; b=<span class="number">1</span>; c++; &#125;</span><br><span class="line">    <span class="keyword">if</span> (c&gt;MAX) &#123; c=<span class="number">1</span>;&#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (fermat())</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Fermat&#x27;s Last Theorem has been disproved.&quot;</span>);</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Fermat&#x27;s Last Theorem has not been disproved.&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>



<h3 id="内存模型"><a href="#内存模型" class="headerlink" title="内存模型"></a>内存模型</h3><h4 id="字节"><a href="#字节" class="headerlink" title="字节"></a>字节</h4><blockquote>
<p>  字节是内存的最小可寻址单元，它定义为一系列连续的位，足以保证有任何基础执行字符集；C支持大小为8位或更多的字节</p>
</blockquote>
<p><code>char</code>、<code>unsigned char</code>、<code>signed char</code>类型的存储和值表示都使用一个字节。字节的位数可以用<code>CHAR_BIT</code>访问</p>
<h4 id="内存位置"><a href="#内存位置" class="headerlink" title="内存位置"></a>内存位置</h4><ul>
<li>一个标量类型（算术类型、指针类型、枚举类型）的对象</li>
<li>或非0长位域的最大连续序列</li>
</ul>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">S</span> &#123;</span></span><br><span class="line">    <span class="type">char</span> a;     <span class="comment">// 内存位置 #1</span></span><br><span class="line">    <span class="type">int</span> b : <span class="number">5</span>;  <span class="comment">// 内存位置 #2</span></span><br><span class="line">    <span class="type">int</span> c : <span class="number">11</span>, <span class="comment">// 内存位置 #2 （连续）</span></span><br><span class="line">          : <span class="number">0</span>,</span><br><span class="line">        d : <span class="number">8</span>;  <span class="comment">// 内存位置 #3</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">        <span class="type">int</span> ee : <span class="number">8</span>; <span class="comment">// 内存位置 #4</span></span><br><span class="line">    &#125; e;</span><br><span class="line">&#125; obj; <span class="comment">// 对象“ obj ”由 4 个分离的内存位置组成</span></span><br></pre></td></tr></table></figure></div>



<h4 id="线程及数据竞争"><a href="#线程及数据竞争" class="headerlink" title="线程及数据竞争"></a>线程及数据竞争</h4><p>一个表达式的求值写入一个内存位置，而另一求值读取或修改同一内存位置时，则这两个表达式冲突，拥有两个冲突表达式的程序有数据竞争，除非：</p>
<ul>
<li>两个冲突求值是原子操作</li>
<li>一个冲突值先发生于另一个（<code>memory_order</code>）</li>
</ul>
<p>若发生数据竞争，则程序行为未定义</p>
<h4 id="内存顺序"><a href="#内存顺序" class="headerlink" title="内存顺序"></a>内存顺序</h4><p>线程从一个内存位置读取值时，它可能看到初始值，被同一线程写入的值，或被其他线程写入的值</p>
<h2 id="关键词"><a href="#关键词" class="headerlink" title="关键词"></a>关键词</h2><p><a class="link"   target="_blank" rel="noopener" href="https://zh.cppreference.com/w/c/keyword" >https://zh.cppreference.com/w/c/keyword <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<h2 id="预处理器"><a href="#预处理器" class="headerlink" title="预处理器"></a>预处理器</h2><h3 id="条件包含"><a href="#条件包含" class="headerlink" title="条件包含"></a>条件包含</h3><p>预处理器支持有条件地编译源文件的某些部分</p>
<h4 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h4><ul>
<li><code>#if</code></li>
<li><code>#ifdef</code></li>
<li><code>#ifndef</code></li>
<li><code>#elif</code></li>
<li><code>#elifdef</code>C23</li>
<li><code>#elifndef</code>C23</li>
<li><code>#else</code></li>
<li><code>#endif</code></li>
</ul>
<h4 id="解释"><a href="#解释" class="headerlink" title="解释"></a>解释</h4><p>条件预处理块由<code>#if #ifdef #ifndef</code>指令开始，然后可选地包含任意多个<code>#elif #elifdef #elifndef</code>指令，接下来最多一个可选的<code>#else</code>指令，并以<code>#endif</code>指令结束</p>
<h4 id="条件的求值"><a href="#条件的求值" class="headerlink" title="条件的求值"></a>条件的求值</h4><p><code>#if #elif</code></p>
<blockquote>
<p>  表达式是常量表达式，仅使用常量和用<code>#define</code>指令定义的标识符，任何非常量，未以<code>#define</code>定义的标识符，求值为0。表达式可以含有形式为<code>defined 标识符</code>或<code>defined (标识符)</code>的一元运算符，若用<code>#define</code>指令定义了该标识符，则返回1，否则返回0。若表达式求值为非零值，则包含该控制代码块并跳过其他，若所用的任何标识符不是常量，则用0替换它。</p>
</blockquote>
<ul>
<li><code>#ifdef 标识符</code>与<code>#if defined 标识符</code>等价</li>
<li><code>#ifndef 标识符</code>与<code>#if !defined 标识符</code>等价</li>
<li><code>#elifdef 标识符</code>与<code>#elif defined 标识符</code>等价</li>
<li><code>#elifndef 标识符</code>与<code>#elif !defined 标识符</code>等价</li>
</ul>
<h3 id="替换文本宏"><a href="#替换文本宏" class="headerlink" title="替换文本宏"></a>替换文本宏</h3><p>预处理器支持文本宏替换及函数文本宏替换</p>
<h4 id="语法-1"><a href="#语法-1" class="headerlink" title="语法"></a>语法</h4><ul>
<li><code>#define 标识符 替换列表(可选)</code></li>
<li><code>#define 标识符(形参) 替换列表</code></li>
<li><code>#define 标识符(形参， ...) 替换列表</code></li>
<li><code>#define 标识符(...) 替换列表</code></li>
<li><code>#undef 标识符</code></li>
</ul>
<h4 id="解释-1"><a href="#解释-1" class="headerlink" title="解释"></a>解释</h4><h5 id="define-指令"><a href="#define-指令" class="headerlink" title="#define 指令"></a>#define 指令</h5><p><code>#define</code>指令定义<code>标识符</code>为宏，即它们指示编译器将所有<code>标识符</code>的后继出现替换为<code>替换列表</code></p>
<h5 id="仿函数宏"><a href="#仿函数宏" class="headerlink" title="仿函数宏"></a>仿函数宏</h5><blockquote>
<p>  仿函数宏将所定义的<code>标识符</code>的每次出现替换为<code>替换列表</code>，额外地接受数个参数，它们会替换<code>替换列表</code>中任何<code>形参</code>的对应出现。对于<code>...</code>可变参数使用<code>__VA_ARGS__</code>标识符访问额外参数</p>
</blockquote>
<h4 id="与-运算符"><a href="#与-运算符" class="headerlink" title="# 与 ## 运算符"></a># 与 ## 运算符</h4><blockquote>
<p>  在仿函数宏中，<code>替换列表</code>中标识符前的<code>#</code>运算符对标识符做形参替换，并将结果环绕在引号中，等效地创建一个字符串字面量</p>
</blockquote>
<blockquote>
<p>  <code>#</code> 出现在 <code>__VA_ARGS__</code> 前时，将整个展开的<code>__VA_ARGS__</code>放入引号</p>
</blockquote>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> showlist(...) puts(#__VA_ARGS__)</span></span><br><span class="line">showlist();            <span class="comment">// 展开成 puts(&quot;&quot;)</span></span><br><span class="line">showlist(<span class="number">1</span>, <span class="string">&quot;x&quot;</span>, <span class="type">int</span>); <span class="comment">// 展开成 puts(&quot;1, \&quot;x\&quot;, int&quot;)</span></span><br></pre></td></tr></table></figure></div>

<p><code>##</code>运算符称为连接或记号粘贴</p>
<h5 id="undef"><a href="#undef" class="headerlink" title="#undef"></a>#undef</h5><blockquote>
<p>  <code>#undef</code> 指令解除定义 <em>标识符</em> ，即它取消先前 <code>#define</code> 对 <em>标识符</em> 的定义。若标识符无与之关联的宏，则忽略此指令</p>
</blockquote>
<h4 id="预定义宏"><a href="#预定义宏" class="headerlink" title="预定义宏"></a>预定义宏</h4><ul>
<li><code>__STDC__</code>：展开成宏常量<code>1</code>，用于指示一致性</li>
<li><code>__STDC_VERSION__</code>：展开成<code>long</code>类型的整数常量，其值随着C 标准的每个版本递增<ul>
<li><code>199409L</code>C95</li>
<li><code>199901L</code>C99</li>
<li><code>201112L</code>C11</li>
<li><code>201710L</code>C17</li>
</ul>
</li>
<li><code>__STDC_HOSTED__</code>：若在操作系统下运行为<code>1</code>，否则为<code>0</code></li>
<li><code>__FILE__</code>：展开成当前文件名，为字符串字面量，可用<code>#line</code>指令更改</li>
<li><code>__LINE__</code>：展开成源文件行号，为整数常量，可用<code>#line</code>指令更改</li>
<li><code>__DATE__</code>：展开成翻译的日期，格式为<code>Mmm dd yyyy</code>的字符串字面量</li>
<li><code>__TIME__</code>：展开成翻译的时间，格式为<code>hh:mm:ss</code>的字符串字面量</li>
</ul>
<p>其他额外宏名：<a class="link"   target="_blank" rel="noopener" href="https://zh.cppreference.com/w/c/preprocessor/replace" >https://zh.cppreference.com/w/c/preprocessor/replace <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<h3 id="源文件包含"><a href="#源文件包含" class="headerlink" title="源文件包含"></a>源文件包含</h3><p>包含另一源文件，到当前源文件中立即执行在指令下一行的位置</p>
<h4 id="语法-2"><a href="#语法-2" class="headerlink" title="语法"></a>语法</h4><ul>
<li><code>#include &lt;问价名&gt;</code>：仅搜索标准包含目录</li>
<li><code>#include &quot;文件名&quot;</code>：现在当前目录下搜索，找不到才会搜索标准目录</li>
</ul>
<h3 id="诊断指令"><a href="#诊断指令" class="headerlink" title="诊断指令"></a>诊断指令</h3><p>显示给定的错误消息并使得程序非良构，或给定的警告消息而不影响程序的合法性<code>C23</code></p>
<h4 id="语法-3"><a href="#语法-3" class="headerlink" title="语法"></a>语法</h4><ul>
<li><code>#error 诊断消息</code>：遇到<code>#error</code>后，显示诊断消息，并令程序非良构（停止编译）</li>
<li><code>#warning 诊断消息</code>C23：显示诊断消息，不影响程序合法性并且编译继续</li>
</ul>
<h3 id="实现定义的行为控制"><a href="#实现定义的行为控制" class="headerlink" title="实现定义的行为控制"></a>实现定义的行为控制</h3><p>实现的定义受<code>#pragma</code>指令控制，像禁用编辑器警告或更改对齐要求，无法识别的语用会被忽略</p>
<h4 id="语法-4"><a href="#语法-4" class="headerlink" title="语法"></a>语法</h4><ul>
<li><code>#pragma 语用形参</code></li>
<li><code>_Pragma(字符串字面量)</code></li>
</ul>
<h4 id="pragma-STDC"><a href="#pragma-STDC" class="headerlink" title="#pragma STDC"></a>#pragma STDC</h4><ul>
<li><code>#pragma STDC FENV_ACCESS 实参</code></li>
<li><code>#pragma STDC FP_CONTRACT 实参</code></li>
<li><code>#pragma STDC CX_LIMITED_DANGE 实参</code></li>
</ul>
<p><strong>其中实参是ON、OFF、DEFAULT之一</strong></p>
<ol>
<li>如果设置为<code>ON</code>，就会告知编译器程序将访问或修改浮点环境，默认值由实现定义，通常是<code>OFF</code></li>
<li>允许浮点表达式的缩略行为，即一种优化，默认值由实现定义，通常是<code>OFF</code></li>
<li>告知编译器，复数的乘法、除法和绝对值可以使用简化的数学公式，而不考虑中间溢出的可能性，默认值为<code>OFF</code></li>
</ol>
<h4 id="pragma-once"><a href="#pragma-once" class="headerlink" title="#pragma once"></a>#pragma once</h4><p>当某个头文件包含它时，指示编译器只对其分析一次，即使它在同一源文件中（直接或间接）被包含了多次也是如此</p>
<blockquote>
<p>  阻止同一头文件被多次包含的标准方式是使用包含防护</p>
</blockquote>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> LIBRARY_FILENAME_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LIBRARY_FILENAME_H</span></span><br><span class="line"><span class="comment">// 头文件的内容</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* LIBRARY_FILENAME_H */</span></span></span><br></pre></td></tr></table></figure></div>

<blockquote>
<p>  非标准</p>
</blockquote>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="comment">// 头文件的内容</span></span><br></pre></td></tr></table></figure></div>



<h4 id="pragma-pack"><a href="#pragma-pack" class="headerlink" title="#pragma pack"></a>#pragma pack</h4><blockquote>
<p>  控制后继定义的类和联合体的最大对齐</p>
</blockquote>
<ul>
<li><code>#pragma pack(实参)</code>：设置当前对齐为参数值</li>
<li><code>#pragma pack()</code>：设置当前对齐为默认值</li>
<li><code>#pragma pack(push)</code>：推入当前对齐的值到内部栈</li>
<li><code>#pragma pack(push, 实参)</code>：推入当前对齐的值到内部栈然后设置当前对齐为参数值</li>
<li><code>#pragma pack(pop)</code>：从内部栈弹出顶条目然后设置（恢复）当前对齐为该值</li>
</ul>
<h3 id="文件名和行信息"><a href="#文件名和行信息" class="headerlink" title="文件名和行信息"></a>文件名和行信息</h3><p>更改预处理器中当前的行号和文件名</p>
<h4 id="语法-5"><a href="#语法-5" class="headerlink" title="语法"></a>语法</h4><ul>
<li><code>#line 行号</code>：更改当前预处理器行号，宏<code>__LINE__</code>在该点后的展开将产生行号加上自此遇到的实际代码行数</li>
<li><code>#line 行号 “文件名”</code>：在上面的基础上将当前预处理器文件名更改为文件名，宏<code>__FILE__</code>在该点后的展开将生成文件名</li>
</ul>
<h2 id="表达式"><a href="#表达式" class="headerlink" title="表达式"></a>表达式</h2><h3 id="值类别"><a href="#值类别" class="headerlink" title="值类别"></a>值类别</h3><p>C 中每个表达式（带有参数的运算符、函数调用、常量、变量名等）以两个独立属性刻画：类型和值类别</p>
<p>每个表达式属于三个值类别之一：左值、非左值以及函数指代器</p>
<h4 id="左值表达式"><a href="#左值表达式" class="headerlink" title="左值表达式"></a>左值表达式</h4><blockquote>
<p>  左值表达式是任何类型异于void的对象类型，且隐含地指代一个对象的表达式，左值表达式求值得到对象标识</p>
</blockquote>
<p>左值表达式可用于下列左值语境：</p>
<ul>
<li>作为取址运算符的运算数（除了指代位域或声明为register的左值）</li>
<li>作为前、后自增运算符的运算数</li>
<li>作为成员访问运算符的左运算数</li>
<li>作为赋值及复合赋值运算符的左运算数</li>
</ul>
<p><code>cosnt/volatile/restrict</code>限定符和原子类型的语义仅应用于左值（左值转换将剥夺限定符并移除原子属性）</p>
<p>下列表达式是左值：</p>
<ul>
<li>标识符，含具名函数形参，只要声明它们为指代对象（而非函数）</li>
<li>字符串字面量</li>
<li>复合字面量</li>
<li>括号表达式，若其无括号版本为左值</li>
<li>成员访问( 点 )运算符的结果，若其左参数是左值</li>
<li>由指针访问成员( -&gt; )运算符的结果</li>
<li>间接使用运算符( 一元* )作用域指向对象指针</li>
<li>下标运算符的结果( [ ] )</li>
</ul>
<h4 id="可修改左值表达式"><a href="#可修改左值表达式" class="headerlink" title="可修改左值表达式"></a>可修改左值表达式</h4><p>一个可修改左值是任何完整类型、非数组、且非<code>const</code>限定的左值表达式，而且若它是结构体、联合体，则递归地没有任何成员为<code>const</code>限定</p>
<p>只有可修改左值表达式可用作自增减运算符的参数，赋值和复合运算符的左参数</p>
<h4 id="非左值对象表达式"><a href="#非左值对象表达式" class="headerlink" title="非左值对象表达式"></a>非左值对象表达式</h4><p>统称为右值，非左值表达式是不指代对象的对象类型表达式，而是没有对象身份或存储位置的值，不能对非左值表达式取址</p>
<ul>
<li>整数、字符、浮点数常量</li>
<li>所有不返回左值的运算符，包括<ul>
<li>任何函数表达式</li>
<li>任何转换类型表达式</li>
<li>作用于非左值结构体、联合体的成员访问（点）运算符</li>
<li>所有算术、关系、逻辑及位运算符</li>
<li>自增和自减运算符（前置形式在C++中是左值）</li>
<li>赋值和复合赋值运算符（在C++中是左值）</li>
<li>条件运算符（C++中可能是左值）</li>
<li>逗号运算符（C++中可能是左值）</li>
<li>取址运算符，即使它被一元 * 运算符的结果中和</li>
</ul>
</li>
</ul>
<h3 id="求值顺序"><a href="#求值顺序" class="headerlink" title="求值顺序"></a>求值顺序</h3><p><a class="link"   target="_blank" rel="noopener" href="https://zh.cppreference.com/w/c/language/eval_order" >https://zh.cppreference.com/w/c/language/eval_order <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<h3 id="常量表达式"><a href="#常量表达式" class="headerlink" title="常量表达式"></a>常量表达式</h3><p>表达式的数种变体被称为常量表达式</p>
<h4 id="预处理器常量表达式"><a href="#预处理器常量表达式" class="headerlink" title="预处理器常量表达式"></a>预处理器常量表达式</h4><h1 id="C基础"><a href="#C基础" class="headerlink" title="C基础"></a>C基础</h1><h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><h3 id="整型"><a href="#整型" class="headerlink" title="整型"></a>整型</h3><ul>
<li><p><strong>有符号整型</strong></p>
<table>
<thead>
<tr>
<th align="center"><em>有符号整型</em></th>
<th align="center"><em>十进制输出格式化</em></th>
<th align="center"><em>八进制格式化输出</em></th>
<th align="center"><em>十六进制格式化输出</em></th>
</tr>
</thead>
<tbody><tr>
<td align="center"><em>signed short int</em></td>
<td align="center"><em>%hd</em></td>
<td align="center"><em>%ho(%#ho)</em></td>
<td align="center"><em>%hx(%#hx)</em></td>
</tr>
<tr>
<td align="center"><em>signed int</em></td>
<td align="center"><em>%d</em></td>
<td align="center"><em>%o(%#o)</em></td>
<td align="center"><em>%x(%#x)</em></td>
</tr>
<tr>
<td align="center"><em>signed long int</em></td>
<td align="center"><em>%ld</em></td>
<td align="center"><em>%lo(%#lo)</em></td>
<td align="center"><em>%lx(%#lx)</em></td>
</tr>
<tr>
<td align="center"><em>signed long long int</em></td>
<td align="center"><em>%lld</em></td>
<td align="center"><em>%llo(%#llo)</em></td>
<td align="center"><em>%llx(%#llx)</em></td>
</tr>
</tbody></table>
<blockquote>
<p>  <strong>tips:</strong>	%X和%x均可实现十六进制输出（一个是大写形式，一个是小写形式）</p>
</blockquote>
</li>
<li><p><strong>无符号整型</strong></p>
<table>
<thead>
<tr>
<th align="center"><em>无符号整型</em></th>
<th align="center"><em>十进制格式化输出</em></th>
<th align="center"><em>八进制格式化输出</em></th>
<th align="center"><em>十六进制格式化输出</em></th>
</tr>
</thead>
<tbody><tr>
<td align="center"><em>unsigned short int</em></td>
<td align="center"><em>%hu</em></td>
<td align="center"><em>%ho</em></td>
<td align="center"><em>%hx</em></td>
</tr>
<tr>
<td align="center"><em>unsigned int</em></td>
<td align="center"><em>%u</em></td>
<td align="center"><em>%o</em></td>
<td align="center"><em>%x</em></td>
</tr>
<tr>
<td align="center"><em>unsigned long int</em></td>
<td align="center"><em>%lu</em></td>
<td align="center"><em>%lo</em></td>
<td align="center"><em>%lx</em></td>
</tr>
<tr>
<td align="center"><em>unsigned long long int</em></td>
<td align="center"><em>%llu</em></td>
<td align="center"><em>%llo</em></td>
<td align="center"><em>%llx</em></td>
</tr>
</tbody></table>
</li>
</ul>
<h3 id="浮点型"><a href="#浮点型" class="headerlink" title="浮点型"></a>浮点型</h3><ul>
<li><p><strong>浮点型格式化</strong></p>
<table>
<thead>
<tr>
<th align="center"><em>浮点数</em></th>
<th align="center"><em>格式化输出</em></th>
<th align="center"><em>指数形式</em></th>
<th align="center"><em>十六进制</em></th>
</tr>
</thead>
<tbody><tr>
<td align="center"><em>float</em></td>
<td align="center"><em>%f</em></td>
<td align="center"><em>%e</em></td>
<td align="center"><em>%a</em></td>
</tr>
<tr>
<td align="center"><em>double</em></td>
<td align="center"><em>%lf</em></td>
<td align="center"><em>%le</em></td>
<td align="center"><em>%la</em></td>
</tr>
<tr>
<td align="center"><em>long double</em></td>
<td align="center"><em>%llf</em></td>
<td align="center"><em>%lle</em></td>
<td align="center"><em>%lla</em></td>
</tr>
</tbody></table>
</li>
</ul>
<h3 id="字符型"><a href="#字符型" class="headerlink" title="字符型"></a>字符型</h3><ul>
<li><p><strong>转义序列</strong></p>
<table>
<thead>
<tr>
<th align="center"><em>转义序列</em></th>
<th align="center"><em>含义</em></th>
<th align="center"><em>转义序列</em></th>
<th align="center"><em>含义</em></th>
</tr>
</thead>
<tbody><tr>
<td align="center"><em>\ b</em></td>
<td align="center"><em>退格</em></td>
<td align="center">*\ *</td>
<td align="center"><em>反斜杠</em></td>
</tr>
<tr>
<td align="center"><em>\ f</em></td>
<td align="center"><em>换页</em></td>
<td align="center"><em>\ ‘</em></td>
<td align="center"><em>单引号</em></td>
</tr>
<tr>
<td align="center"><em>\ n</em></td>
<td align="center"><em>换行</em></td>
<td align="center"><em>\ “</em></td>
<td align="center"><em>双引号</em></td>
</tr>
<tr>
<td align="center"><em>\ r</em></td>
<td align="center"><em>回车</em></td>
<td align="center"><em>\ ?</em></td>
<td align="center"><em>问号</em></td>
</tr>
<tr>
<td align="center"><em>\ t</em></td>
<td align="center"><em>水平制表符</em></td>
<td align="center"><em>\0oo</em></td>
<td align="center"><em>八进制数</em></td>
</tr>
<tr>
<td align="center"><em>\xhh</em></td>
<td align="center"><em>十六进制数</em></td>
<td align="center"></td>
<td align="center"></td>
</tr>
</tbody></table>
</li>
<li><p><strong>字符处理函数</strong></p>
<table>
<thead>
<tr>
<th align="center"><em>函数名</em></th>
<th align="center"><em>如果是下列参数时返回值为真</em></th>
</tr>
</thead>
<tbody><tr>
<td align="center"><em>isalnum( )</em></td>
<td align="center"><em>字母或数字</em></td>
</tr>
<tr>
<td align="center"><em>isalpha( )</em></td>
<td align="center"><em>字母</em></td>
</tr>
<tr>
<td align="center"><em>isblank( )</em></td>
<td align="center"><em>空格、水平制表符或换行符</em></td>
</tr>
<tr>
<td align="center"><em>iscntrl( )</em></td>
<td align="center"><em>控制字符</em></td>
</tr>
<tr>
<td align="center"><em>isdigit( )</em></td>
<td align="center"><em>数字</em></td>
</tr>
<tr>
<td align="center"><em>isgraph( )</em></td>
<td align="center"><em>除空格外的任意可打印字符</em></td>
</tr>
<tr>
<td align="center"><em>islower( )</em></td>
<td align="center"><em>小写字母</em></td>
</tr>
<tr>
<td align="center"><em>isprint( )</em></td>
<td align="center"><em>可打印字符</em></td>
</tr>
<tr>
<td align="center"><em>ispunct( )</em></td>
<td align="center"><em>标点符号</em></td>
</tr>
<tr>
<td align="center"><em>isspace( )</em></td>
<td align="center"><em>空白字符</em></td>
</tr>
<tr>
<td align="center"><em>isupper( )</em></td>
<td align="center"><em>大写字母</em></td>
</tr>
<tr>
<td align="center"><em>isxdigit( )</em></td>
<td align="center"><em>十六进制数字符</em></td>
</tr>
</tbody></table>
<blockquote>
<p>  上面所有函数均在头文件<code>ctype.h</code>中</p>
</blockquote>
<ol>
<li><p><strong><em>两个字符映射函数</em></strong></p>
<table>
<thead>
<tr>
<th align="center"><em>函数名</em></th>
<th align="center"><em>行为</em></th>
</tr>
</thead>
<tbody><tr>
<td align="center"><em>tolower()</em></td>
<td align="center"><em>如果是大写字符返回小写字符，否则返回原始参数</em></td>
</tr>
<tr>
<td align="center"><em>toupper()</em></td>
<td align="center"><em>如果是小写字符返回大写字符，否则返回原始参数</em></td>
</tr>
</tbody></table>
</li>
</ol>
</li>
</ul>
<h3 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h3><ul>
<li><p><strong>虚数和复数</strong></p>
<ol>
<li><p><strong><em>complex.h提供的一些对复数进行基本操作的函数</em></strong></p>
<blockquote>
<p>  <strong>creal</strong>	         获取复数的实部</p>
<p>  <strong>cimag</strong>		   获取复数的虚部</p>
<p>  <strong>conj</strong>			  获取复数的共轭</p>
<p>  <strong>carg</strong>			 获取复平面上穿过原点和复数在复平面表示的点,的直线和实数轴之间的夹角</p>
<p>  <strong>cproj</strong>			返回复数在黎曼球面上的投影</p>
</blockquote>
</li>
<li><p><strong><em>两个虚数宏</em></strong></p>
<p><code>_Complex_I</code> 和 <code>I</code></p>
</li>
<li><p><strong><em>Exp</em></strong></p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">complex</span> <span class="type">double</span> a = <span class="number">3.0</span> + <span class="number">4.0</span> * _Complex_I;</span><br><span class="line"><span class="type">complex</span> <span class="type">double</span> a = <span class="number">3.0</span> + <span class="number">4.0</span> * I;</span><br><span class="line"><span class="type">_Complex</span> <span class="type">double</span> a = <span class="number">3.0</span> + <span class="number">4.0</span> * _Complex_I;</span><br><span class="line"><span class="type">_Complex</span> <span class="type">double</span> a = <span class="number">3.0</span> + <span class="number">4.0</span> * I;</span><br></pre></td></tr></table></figure></div></li>
</ol>
</li>
<li><p><strong>布尔值</strong></p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdbool.h&gt;</span></span></span><br><span class="line"><span class="comment">// and you can use bool</span></span><br><span class="line"><span class="type">bool</span> flag = <span class="literal">false</span>;</span><br><span class="line"><span class="comment">// or use _Bool</span></span><br><span class="line"><span class="type">_Bool</span> flag = <span class="literal">true</span>;</span><br></pre></td></tr></table></figure></div></li>
</ul>
<h3 id="格式化输出"><a href="#格式化输出" class="headerlink" title="格式化输出"></a>格式化输出</h3><ul>
<li><p><strong>格式</strong></p>
<table>
<thead>
<tr>
<th align="center"><em>转换说明</em></th>
<th align="center"><em>输出</em></th>
</tr>
</thead>
<tbody><tr>
<td align="center"><em>%a    %A</em></td>
<td align="center"><em>浮点数、十六进制数、p计数法</em></td>
</tr>
<tr>
<td align="center"><em>%c</em></td>
<td align="center"><em>单个字符</em></td>
</tr>
<tr>
<td align="center"><em>%d    %i</em></td>
<td align="center"><em>有符号十进制数</em></td>
</tr>
<tr>
<td align="center"><em>%e    %E</em></td>
<td align="center"><em>浮点数e计数法</em></td>
</tr>
<tr>
<td align="center"><em>%f</em></td>
<td align="center"><em>浮点数十进制计法</em></td>
</tr>
<tr>
<td align="center"><em>%g    %G</em></td>
<td align="center"><em>根据值不同自动选择%f或%e</em></td>
</tr>
<tr>
<td align="center"><em>%o</em></td>
<td align="center"><em>无符号八进制数</em></td>
</tr>
<tr>
<td align="center"><em>%x    %X</em></td>
<td align="center"><em>无符号十六进制数</em></td>
</tr>
<tr>
<td align="center"><em>%p</em></td>
<td align="center"><em>指针</em></td>
</tr>
<tr>
<td align="center"><em>%s</em></td>
<td align="center"><em>字符串</em></td>
</tr>
<tr>
<td align="center"><em>%u</em></td>
<td align="center"><em>无符号十进制数</em></td>
</tr>
<tr>
<td align="center"><em>%%</em></td>
<td align="center"><em>百分号</em></td>
</tr>
</tbody></table>
</li>
<li><p><strong>修饰符</strong></p>
<table>
<thead>
<tr>
<th align="center"><em>修饰符</em></th>
<th align="center"><em>含义</em></th>
</tr>
</thead>
<tbody><tr>
<td align="center"><em>标记</em></td>
<td align="center"><em>- + space 0<br>exp: “%-10d”</em></td>
</tr>
<tr>
<td align="center"><em>数字</em></td>
<td align="center"><em>最小字段宽度<br>exp: “%4d”</em></td>
</tr>
<tr>
<td align="center"><em><br>.数字</em></td>
<td align="center"><em>精度<br>对于%e和%f转换，表示小数位数<br>对于%g转换，表示有效数字的最大位数<br>对于%s转换，表示打印字符的最大数量<br>对于整型转换，表示打印数字的最小位数，前补0<br>exp: “%5.2f”，字符宽度5，两位小数</em></td>
</tr>
<tr>
<td align="center"><em>h</em></td>
<td align="center"><em>表示short int 或 unsigned short int<br>exp: “%hu”</em></td>
</tr>
<tr>
<td align="center"><em>hh</em></td>
<td align="center"><em>表示signed char 或 unsigned char的值<br>exp: “%hhu”</em></td>
</tr>
<tr>
<td align="center"><em>j</em></td>
<td align="center"><em>表示intmax_t或uintmax_t，这些类型定义在stdint.h中<br>exp: “%jd”</em></td>
</tr>
<tr>
<td align="center"><em>l and ll</em></td>
<td align="center"><em>表示long, unsigned long 和 long long, unsigned long long<br>exp: “%ld”    “%llu”</em></td>
</tr>
<tr>
<td align="center"><em>L</em></td>
<td align="center"><em>和浮点型转换一起使用，表示long double类型的值<br>exp: “%Le”</em></td>
</tr>
<tr>
<td align="center"><em>t</em></td>
<td align="center"><em>表示ptrdiff_t（两个指针的差值）<br>exp: “%td”</em></td>
</tr>
<tr>
<td align="center"><em>z</em></td>
<td align="center"><em>表示size_t类型的值<br>exp: “%zd”</em></td>
</tr>
</tbody></table>
</li>
<li><p><strong>标记</strong></p>
<table>
<thead>
<tr>
<th align="center"><em>标记</em></th>
<th align="center"><em>含义</em></th>
</tr>
</thead>
<tbody><tr>
<td align="center"><em>-</em></td>
<td align="center"><em>左对齐， exp: “%-20s”</em></td>
</tr>
<tr>
<td align="center"><em>+</em></td>
<td align="center"><em>有符号值若为正，显示加号，若为负，显示减号<br>exp: “%+6.2f”</em></td>
</tr>
<tr>
<td align="center"><em>space</em></td>
<td align="center"><em>有符号值为正，前导空格，为负，值前面显示减号并覆盖一个空格<br>exp: “% 6.2f”</em></td>
</tr>
<tr>
<td align="center"><em>#</em></td>
<td align="center"><em>%o 前导0，%x 前导0x<br>对于浮点数保证小数点后一定会打印一位</em></td>
</tr>
<tr>
<td align="center"><em>0</em></td>
<td align="center"><em>前导0</em></td>
</tr>
</tbody></table>
</li>
</ul>
<h3 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h3><ul>
<li><p><strong>逻辑运算符</strong></p>
<table>
<thead>
<tr>
<th align="center"><em>逻辑运算符</em></th>
<th align="center"><em>含义</em></th>
<th align="center"><em>iso646.h</em></th>
</tr>
</thead>
<tbody><tr>
<td align="center"><em>&amp;&amp;</em></td>
<td align="center"><em>与</em></td>
<td align="center"><em>and</em></td>
</tr>
<tr>
<td align="center"><em>||</em></td>
<td align="center"><em>或</em></td>
<td align="center"><em>or</em></td>
</tr>
<tr>
<td align="center"><em>!</em></td>
<td align="center"><em>非</em></td>
<td align="center"><em>not</em></td>
</tr>
</tbody></table>
<p><strong>三元运算符</strong>	 <code>expression ? res1 : res2</code></p>
</li>
</ul>
<h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><h3 id="使用函数"><a href="#使用函数" class="headerlink" title="使用函数"></a>使用函数</h3><ul>
<li><p><strong>函数原型（函数声明）</strong></p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">return_type <span class="title function_">function_name</span><span class="params">(type args, ...)</span>;</span><br><span class="line">return_type <span class="title function_">function_name</span><span class="params">(type, ...)</span>;				<span class="comment">// 可省略形参名</span></span><br></pre></td></tr></table></figure></div>


</li>
<li><p><strong>函数定义</strong></p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">return_type <span class="title function_">function_name</span><span class="params">(type args, ...)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* something */</span></span><br><span class="line">    <span class="keyword">return</span> val;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<blockquote>
<p>  当<code>return_type</code>为<code>void</code>时返回值为空<code>return ;</code></p>
<p>  当<code>args</code>为空时参数列表填入<code>void</code></p>
</blockquote>
</li>
<li><p><strong>函数调用</strong></p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">return_type return_val = function_name(args, ...);</span><br></pre></td></tr></table></figure></div></li>
</ul>
<h3 id="数组作为函数参数"><a href="#数组作为函数参数" class="headerlink" title="数组作为函数参数"></a>数组作为函数参数</h3><ul>
<li><p><strong>作为参数列表</strong></p>
<ol>
<li><p><strong><em>函数原型</em></strong></p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">type <span class="title function_">func</span><span class="params">(type *ar, type n)</span>;</span><br><span class="line">type <span class="title function_">func</span><span class="params">(type *, type)</span>;</span><br><span class="line">type <span class="title function_">func</span><span class="params">(type ar[], type n)</span>;</span><br><span class="line">type <span class="title function_">func</span><span class="params">(type [], type)</span>;		<span class="comment">// 一维数组</span></span><br><span class="line"></span><br><span class="line">type <span class="title function_">func</span><span class="params">(type (*pt)[<span class="number">4</span>])</span>;</span><br><span class="line">type <span class="title function_">func</span><span class="params">(type pt[][<span class="number">4</span>])</span>;		<span class="comment">// 二维数组</span></span><br></pre></td></tr></table></figure></div>


</li>
<li><p><strong><em>函数定义处</em></strong></p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">type <span class="title function_">func</span><span class="params">(type *arr, type n)</span>;</span><br><span class="line">type <span class="title function_">func</span><span class="params">(type arr[], type n)</span>;</span><br></pre></td></tr></table></figure></div>

<blockquote>
<p>  在函数定义处不能省略参数名</p>
</blockquote>
</li>
</ol>
</li>
<li><p><strong>作为返回值</strong></p>
<blockquote>
<p>  谨慎操作，请勿将栈区内存指针作为返回值</p>
</blockquote>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">type *<span class="title function_">func</span><span class="params">(args, ...)</span></span><br><span class="line">&#123;</span><br><span class="line">    type arr[] = &#123;...&#125;;</span><br><span class="line">    <span class="keyword">return</span> arr;		<span class="comment">// wrong</span></span><br><span class="line">    type *arr = (type *)<span class="built_in">malloc</span>(...);</span><br><span class="line">    <span class="keyword">return</span> arr;		<span class="comment">// right</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></li>
</ul>
<h3 id="函数和指针"><a href="#函数和指针" class="headerlink" title="函数和指针"></a>函数和指针</h3><ul>
<li><p><strong>定义函数指针</strong></p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">ToUpper</span><span class="params">(<span class="type">char</span> *)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">SumN</span><span class="params">(<span class="type">int</span> *arr)</span>;</span><br><span class="line"><span class="type">void</span> (*ptu)(<span class="type">char</span> *);</span><br><span class="line">ptu = ToUpper;			<span class="comment">// ok</span></span><br><span class="line">ptu = SumN;				<span class="comment">// wrong</span></span><br></pre></td></tr></table></figure></div>

<blockquote>
<p>  类型要匹配</p>
</blockquote>
</li>
<li><p><strong>两种语法</strong></p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">ToUpper</span><span class="params">(<span class="type">char</span> *)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">ToLower</span><span class="params">(<span class="type">char</span> *)</span>;</span><br><span class="line"><span class="type">void</span> (*pf)(<span class="type">char</span> *);</span><br><span class="line"><span class="type">char</span> mis[] = <span class="string">&quot;Nina Metier&quot;</span>;</span><br><span class="line">pf = ToUpper;</span><br><span class="line">(*pf)(mis); 	<span class="comment">// 用法1</span></span><br><span class="line">pf = ToLower;</span><br><span class="line">pf(mis); 		<span class="comment">// 用法2</span></span><br></pre></td></tr></table></figure></div>

<blockquote>
<p>  两种方法是等价的</p>
</blockquote>
</li>
</ul>
<h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><h3 id="一维数组"><a href="#一维数组" class="headerlink" title="一维数组"></a>一维数组</h3><ul>
<li><p><strong>创建一维数组</strong></p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">type arr[size];</span><br></pre></td></tr></table></figure></div>

<blockquote>
<p>  <code>size</code>必须是常量或常量表达式（如果你不是想使用VLA的话）</p>
</blockquote>
<ol>
<li><p><strong><em>初始化数组</em></strong></p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> powers[<span class="number">8</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">8</span>, <span class="number">16</span>, <span class="number">32</span>, <span class="number">64</span>&#125;;				<span class="comment">// init the arr, size 8</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> powers[<span class="number">8</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">8</span>, <span class="number">16</span>, <span class="number">32</span>, <span class="number">64</span>&#125;;			<span class="comment">// read only</span></span><br><span class="line"><span class="type">int</span> vals[<span class="number">4</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>&#125;;									<span class="comment">// [1, 2, 0, 0]</span></span><br><span class="line"><span class="type">int</span> days[] = &#123;<span class="number">31</span>, <span class="number">28</span>, <span class="number">31</span>, <span class="number">30</span>, <span class="number">31</span>, <span class="number">30</span>, <span class="number">31</span>, <span class="number">31</span>, <span class="number">30</span>, <span class="number">31</span>&#125;;	<span class="comment">// auto match</span></span><br><span class="line"><span class="type">size_t</span> days_size = <span class="keyword">sizeof</span>(days);</span><br><span class="line"><span class="type">int</span> arr[<span class="number">6</span>] = &#123;[<span class="number">5</span>] = <span class="number">21</span>&#125;;								<span class="comment">/* designated initializer(指定初始化器)</span></span><br><span class="line"><span class="comment">														   [0, 0, 0, 0, 0, 21] */</span></span><br><span class="line"><span class="type">int</span> stuff[] = &#123;<span class="number">1</span>, [<span class="number">6</span>] = <span class="number">23</span>&#125;;							<span class="comment">// [1, 0, 0, 0, 0, 0, 23]</span></span><br><span class="line"><span class="type">int</span> staff[] = &#123;<span class="number">1</span>, [<span class="number">3</span>] = <span class="number">4</span>, <span class="number">9</span>, <span class="number">10</span>&#125;;						<span class="comment">// [1, 0, 0, 4, 9, 10]</span></span><br></pre></td></tr></table></figure></div></li>
</ol>
</li>
<li><p><strong>使用一维数组</strong></p>
<blockquote>
<p>  通过下标和指针两种形式</p>
</blockquote>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">arr[pos], *(arr+pos);</span><br></pre></td></tr></table></figure></div></li>
</ul>
<h3 id="二维及多维数组"><a href="#二维及多维数组" class="headerlink" title="二维及多维数组"></a>二维及多维数组</h3><ul>
<li><p><strong>创建二维数组</strong></p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">type arr[rows][cols];</span><br></pre></td></tr></table></figure></div>

<blockquote>
<p>  <code>rows cols</code>必须是常量或常量表达式</p>
</blockquote>
<ol>
<li><p><strong><em>初始化</em></strong></p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> arr[<span class="number">2</span>][<span class="number">3</span>] = &#123;</span><br><span class="line">    &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;,</span><br><span class="line">    &#123;<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> sq[<span class="number">2</span>][<span class="number">3</span>] = &#123; &#123;<span class="number">5</span>, <span class="number">6</span>&#125;, &#123;<span class="number">7</span>, <span class="number">8</span>&#125; &#125;;				<span class="comment">/* 5, 6, 0</span></span><br><span class="line"><span class="comment">												   7, 8, 0 */</span></span><br><span class="line"><span class="type">int</span> sq[<span class="number">2</span>][<span class="number">3</span>] = &#123;<span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>&#125;;					<span class="comment">/* 5, 6, 7</span></span><br><span class="line"><span class="comment">												   8, 0, 0 */</span></span><br></pre></td></tr></table></figure></div></li>
</ol>
</li>
<li><p><strong>使用二维数组</strong></p>
<blockquote>
<p>  指针和下标两种形式（具体用法在C进阶部分补充）</p>
</blockquote>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">arr[rows][cols], *(*(arr+rows)+cols);</span><br></pre></td></tr></table></figure></div></li>
</ul>
<h3 id="VLA"><a href="#VLA" class="headerlink" title="VLA"></a>VLA</h3><div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">sum2d</span><span class="params">(<span class="type">int</span> rows, <span class="type">int</span> cols, <span class="type">int</span> arr[rows][cols])</span>;</span><br><span class="line"><span class="comment">// 在函数原型中可以省略形参名</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sum2d</span><span class="params">(<span class="type">int</span>, <span class="type">int</span>, <span class="type">int</span> arr[*][*])</span></span><br></pre></td></tr></table></figure></div>

<blockquote>
<p>  rows cols必须定义在arr前</p>
</blockquote>
<h3 id="复合字面量"><a href="#复合字面量" class="headerlink" title="复合字面量"></a>复合字面量</h3><div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 一个普通的数组声明（一维） */</span></span><br><span class="line"><span class="type">int</span> diva[<span class="number">2</span>] = &#123;<span class="number">10</span>, <span class="number">20</span>&#125;;</span><br><span class="line"><span class="comment">// 复合字面量</span></span><br><span class="line">(<span class="type">int</span> [<span class="number">2</span>])&#123;<span class="number">10</span>, <span class="number">20</span>&#125;;</span><br><span class="line">(<span class="type">int</span> [])&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 必须在创建复合字面量时就使用它</span></span><br><span class="line"><span class="type">int</span> *ptr = (<span class="type">int</span> [<span class="number">2</span>])&#123;<span class="number">1</span>, <span class="number">2</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* （二维） */</span></span><br><span class="line"><span class="type">int</span> (*ptr)[<span class="number">4</span>];</span><br><span class="line">ptr = (<span class="type">int</span> [<span class="number">2</span>][<span class="number">4</span>])&#123;&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;, &#123;<span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>&#125;&#125;;</span><br></pre></td></tr></table></figure></div>



<h2 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h2><h3 id="指针和数组"><a href="#指针和数组" class="headerlink" title="指针和数组"></a>指针和数组</h3><p><code>&amp;(取地址)		*(解引用)</code></p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> arr[<span class="number">10</span>] = &#123;...&#125;;</span><br><span class="line"><span class="type">int</span> *ptr = arr;</span><br><span class="line"><span class="comment">/* *(ptr + i) = arr[i] = *(arr + i)</span></span><br><span class="line"><span class="comment">   ptr + i = &amp;arr[i] = arr + i */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 只有是指针变量时才能使用自增运算符</span></span><br><span class="line"><span class="type">int</span> arr[<span class="number">10</span>];</span><br><span class="line"><span class="type">int</span> *ptr = arr;</span><br><span class="line">ptr++;									<span class="comment">// 合法</span></span><br><span class="line">arr++;									<span class="comment">// 不合法</span></span><br></pre></td></tr></table></figure></div>



<h3 id="指针与const"><a href="#指针与const" class="headerlink" title="指针与const"></a>指针与const</h3><ul>
<li><p><strong>const与数组</strong></p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">type <span class="title function_">func</span><span class="params">(<span class="type">const</span> type arr[])</span>;</span><br></pre></td></tr></table></figure></div>

<blockquote>
<p>  在函数进行参数传递时若不想修改数组的内容可使用const修饰参数</p>
<blockquote>
<p>  只能把非const数据的地址赋给普通指针（c允许，但是更改值是未定义的，c++不允许）</p>
<p>  可以把普通数据的地址赋给const指针</p>
<p>  不要把const数组名作为实参传递给函数</p>
</blockquote>
</blockquote>
</li>
<li><p><strong>指针常量</strong></p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> arr[<span class="number">10</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>&#125;;</span><br><span class="line"><span class="type">int</span> * <span class="type">const</span> pc = arr;</span><br><span class="line">pc++;								<span class="comment">// not allowed</span></span><br><span class="line">*(pc) = <span class="number">100</span>;						<span class="comment">// allowed</span></span><br></pre></td></tr></table></figure></div>


</li>
<li><p><strong>常量指针</strong></p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> arr[<span class="number">10</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>&#125;;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> *pc = arr;</span><br><span class="line">pc++;								<span class="comment">// allowed</span></span><br><span class="line">*(pc) = <span class="number">100</span>;						<span class="comment">// not allowed</span></span><br></pre></td></tr></table></figure></div></li>
</ul>
<h3 id="指针的兼容性"><a href="#指针的兼容性" class="headerlink" title="指针的兼容性"></a>指针的兼容性</h3><div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> **p;				<span class="comment">// 不能通过*p更改所指向的内容</span></span><br><span class="line"><span class="type">int</span> *p1;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> n = <span class="number">10</span>;</span><br><span class="line">p = &amp;p1;</span><br><span class="line">*p = &amp;n;</span><br><span class="line">*p1 = <span class="number">10</span>;					<span class="comment">// 间接的更改了n的值</span></span><br></pre></td></tr></table></figure></div>

<blockquote>
<p>  在进行两级解引用时，把非const指针赋给const指针也是不安全的</p>
</blockquote>
<h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><h3 id="表示字符串"><a href="#表示字符串" class="headerlink" title="表示字符串"></a>表示字符串</h3><ul>
<li><p><strong>定义字符串</strong></p>
<ol>
<li><p><strong><em>字符串字面量（字符串常量）</em></strong></p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;i am a string.&quot;</span>;</span><br><span class="line"><span class="comment">// exp:</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s, %p, %c\n&quot;</span>, <span class="string">&quot;We&quot;</span>, <span class="string">&quot;are&quot;</span>, *<span class="string">&quot;space&quot;</span>);</span><br><span class="line"><span class="comment">// output: We, 0x1000000f61, s</span></span><br></pre></td></tr></table></figure></div>


</li>
<li><p><strong><em>字符串数组和初始化</em></strong></p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> <span class="built_in">string</span>[<span class="number">40</span>] = <span class="string">&quot;Hello, everyone.&quot;</span>;</span><br><span class="line"><span class="type">char</span> <span class="built_in">string</span>[] = <span class="string">&quot;If you can&#x27;t think of anything, fake it.&quot;</span>;</span><br><span class="line"><span class="type">char</span> <span class="built_in">string</span>[<span class="number">40</span>] = &#123;<span class="string">&#x27;H&#x27;</span>, <span class="string">&#x27;e&#x27;</span>, <span class="string">&#x27;l&#x27;</span>, <span class="string">&#x27;l&#x27;</span>, <span class="string">&#x27;o&#x27;</span>, <span class="string">&#x27;\0&#x27;</span>&#125;;	<span class="comment">// 没有&#x27;\0&#x27;就不是一个字符串而是一个字符数组</span></span><br><span class="line"><span class="type">const</span> <span class="type">char</span> *<span class="built_in">string</span> = <span class="string">&quot;Hello.&quot;</span>;</span><br></pre></td></tr></table></figure></div>


</li>
<li><p><strong><em>数组和指针</em></strong></p>
<p>初始化数组把静态存储区的字符串拷贝到数组中<br>初始化指针是把字符串的首地址赋给指针</p>
</li>
<li><p><strong><em>字符串数组</em></strong></p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">char</span> *<span class="built_in">string</span>[<span class="number">10</span>] = &#123;<span class="string">&quot;hello&quot;</span>, <span class="string">&quot;hi&quot;</span>&#125;;</span><br><span class="line"><span class="type">char</span> <span class="built_in">string</span>[<span class="number">2</span>][<span class="number">10</span>] = &#123;<span class="string">&quot;hello&quot;</span>, <span class="string">&quot;hi&quot;</span>&#125;;</span><br></pre></td></tr></table></figure></div>

<blockquote>
<p>  推荐第一种写法，节省空间，第二种写法每个字符串都被储存了两遍（如果你不需要更改字符串的值）</p>
</blockquote>
</li>
</ol>
</li>
<li><p><strong>指针和字符串</strong></p>
<p><code>string = s （浅拷贝，只拷贝地址）</code></p>
</li>
</ul>
<h3 id="字符串输入"><a href="#字符串输入" class="headerlink" title="字符串输入"></a>字符串输入</h3><ul>
<li><p><strong>分配空间</strong></p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> name[<span class="number">100</span>];</span><br></pre></td></tr></table></figure></div>


</li>
<li><p><strong>字符串读入函数</strong></p>
<ol>
<li><p><em><strong>gets fgets gets_s</strong></em></p>
<ul>
<li><p><em>char *gets(char *string)</em></p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> <span class="built_in">string</span>[<span class="number">100</span>];</span><br><span class="line">gets(<span class="built_in">string</span>);						<span class="comment">// 不安全（已舍弃）</span></span><br></pre></td></tr></table></figure></div>


</li>
<li><p><em>char *fgets(char *s, int size, FILE *stream)</em></p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> SIZE 40</span></span><br><span class="line"><span class="type">char</span> buff[<span class="number">100</span>];</span><br><span class="line">fgets(buff, SIZE, <span class="built_in">stdin</span>);			<span class="comment">// fgets会存储\n</span></span><br></pre></td></tr></table></figure></div>


</li>
<li><p><em>char *gets_s(char *buffer,size_t sizeInCharacters)</em></p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> SIZE 100</span></span><br><span class="line"><span class="type">char</span> buff[<span class="number">100</span>];</span><br><span class="line">gets_s(buff, SIZE);					<span class="comment">// gets_s会舍弃换行符</span></span><br></pre></td></tr></table></figure></div>

<blockquote>
<p>  当输入太长时使用fgets，其余情况gets_s可完美替换gets</p>
</blockquote>
</li>
</ul>
</li>
<li><p><strong><em>scanf</em></strong></p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> <span class="built_in">string</span>[<span class="number">100</span>];</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%10s&quot;</span>, <span class="built_in">string</span>); </span><br></pre></td></tr></table></figure></div>

<blockquote>
<p>  scanf与gets一样不安全，但是可以使用%nd来限制读入宽度</p>
</blockquote>
</li>
</ol>
</li>
</ul>
<h3 id="字符串输出"><a href="#字符串输出" class="headerlink" title="字符串输出"></a>字符串输出</h3><ul>
<li><p><strong>puts fputs</strong></p>
<ol>
<li><p>**<em>int puts( const char *s)</em>**</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> <span class="built_in">string</span>[<span class="number">100</span>] = <span class="string">&quot;hello world.&quot;</span>;</span><br><span class="line"><span class="built_in">puts</span>(<span class="built_in">string</span>);</span><br></pre></td></tr></table></figure></div>

<blockquote>
<p>  puts函数输出直到’\0’，并在结尾自动加上换行符</p>
</blockquote>
</li>
<li><p>**<em>int fputs(const char *str, FILE *stream)</em>**</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> <span class="built_in">string</span>[<span class="number">100</span>] = <span class="string">&quot;hello c.&quot;</span>;</span><br><span class="line"><span class="built_in">fputs</span>(<span class="built_in">string</span>, <span class="built_in">stdout</span>);</span><br></pre></td></tr></table></figure></div>

<blockquote>
<p>  fputs不会在结尾自动加上换行符</p>
</blockquote>
</li>
</ol>
<p><em><strong>puts与gets配套使用，fgets与fputs配套使用</strong></em></p>
</li>
<li><p><strong>printf</strong></p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> <span class="built_in">string</span>[<span class="number">100</span>] = <span class="string">&quot;hello c.&quot;</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, <span class="built_in">string</span>);</span><br></pre></td></tr></table></figure></div>

<blockquote>
<p>  需要自己加上换行符</p>
</blockquote>
</li>
</ul>
<h3 id="字符串函数"><a href="#字符串函数" class="headerlink" title="字符串函数"></a>字符串函数</h3><ul>
<li><p><strong>strlen</strong></p>
<ol>
<li><p>**<em>unsigned int strlen (char *s)</em>**</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> <span class="built_in">string</span>[] = <span class="string">&quot;hello.&quot;</span>;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> lens = <span class="built_in">strlen</span>(<span class="built_in">string</span>);</span><br></pre></td></tr></table></figure></div></li>
</ol>
</li>
<li><p><strong>strcat strncat</strong></p>
<ol>
<li><p>**<em>char *strcat(char *dest, const char *src)</em>**</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> s1[] = <span class="string">&quot;hello &quot;</span>;</span><br><span class="line"><span class="type">char</span> s2[] = <span class="string">&quot;hi.&quot;</span>;</span><br><span class="line"><span class="built_in">strcat</span>(s1, s2);</span><br><span class="line"><span class="comment">// s1 = hello hi.</span></span><br></pre></td></tr></table></figure></div>


</li>
<li><p>**<em>char *strncat(char *dest, const char *src, size_t n)</em>**</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> s1[] = <span class="string">&quot;hello &quot;</span>;</span><br><span class="line"><span class="type">char</span> s2[] = <span class="string">&quot;hi.&quot;</span>;</span><br><span class="line"><span class="built_in">strncat</span>(s1, s2, <span class="number">1</span>);</span><br><span class="line"><span class="comment">// s1 = hello h</span></span><br></pre></td></tr></table></figure></div></li>
</ol>
</li>
<li><p><strong>strcmp strncmp</strong></p>
<ol>
<li><p>**<em>int strcmp(const char *str1, const char *str2)</em>**</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> str1[] = <span class="string">&quot;ab&quot;</span>;</span><br><span class="line"><span class="type">char</span> str2[] = <span class="string">&quot;aB&quot;</span>;</span><br><span class="line"><span class="type">int</span> res = <span class="built_in">strcmp</span>(str1, str2);</span><br><span class="line"><span class="comment">// res &gt; 0 (b &gt; B)</span></span><br></pre></td></tr></table></figure></div>

<p><del>如果返回值小于 0，则表示 str1 小于 str2</del></p>
<p><del>如果返回值大于 0，则表示 str1 大于 str2</del></p>
<p><del>如果返回值等于 0，则表示 str1 等于 str2</del></p>
</li>
<li><p>**<em>int strncmp(const char *str1, const char *str2, size_t n)</em>**</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> str1[] = <span class="string">&quot;ab&quot;</span>;</span><br><span class="line"><span class="type">char</span> str2[] = <span class="string">&quot;aB&quot;</span>;</span><br><span class="line"><span class="type">int</span> res = <span class="built_in">strcmp</span>(str1, str2, <span class="number">1</span>);</span><br><span class="line"><span class="comment">// res = 0 (a = a)</span></span><br></pre></td></tr></table></figure></div></li>
</ol>
</li>
<li><p><strong>strcpy strncpy</strong></p>
<ol>
<li><p><em>**char *strcpy(char <em>dest, const char <em>src)</em></em></em></p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> src[<span class="number">10</span>];</span><br><span class="line"><span class="built_in">strcpy</span>(src, <span class="string">&quot;hello.&quot;</span>);</span><br><span class="line"><span class="comment">// src = &quot;hello.&quot;</span></span><br></pre></td></tr></table></figure></div>


</li>
<li><p>**<em>char *strncpy(char *dest, const char *src, size_t n)</em>**</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> src[<span class="number">10</span>];</span><br><span class="line"><span class="built_in">strcpy</span>(src, <span class="string">&quot;hello.&quot;</span>, <span class="number">2</span>);</span><br><span class="line"><span class="comment">// src = &quot;he&quot;</span></span><br></pre></td></tr></table></figure></div></li>
</ol>
</li>
<li><p><strong>sprintf</strong></p>
<ol>
<li><p>**<em>int sprintf(char *str, char * format [, argument, …])</em>**</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> buf[<span class="number">80</span>];</span><br><span class="line"><span class="built_in">sprintf</span>(buf, <span class="string">&quot;The ASCII code of a is %d.&quot;</span>, <span class="string">&#x27;a&#x27;</span>);</span><br><span class="line"><span class="comment">// buf = &quot;The ASCII code of a is 97.&quot;</span></span><br></pre></td></tr></table></figure></div></li>
</ol>
</li>
</ul>
<h3 id="字符串转化为数字-stdlib-h"><a href="#字符串转化为数字-stdlib-h" class="headerlink" title="字符串转化为数字(stdlib.h)"></a>字符串转化为数字(stdlib.h)</h3><ul>
<li><p><strong>atoi atof atol</strong></p>
<ol>
<li><p><strong><em>int atoi (const char * str)</em></strong></p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> *<span class="built_in">string</span> = <span class="string">&quot;324&quot;</span>;</span><br><span class="line"><span class="type">int</span> num = atoi(<span class="built_in">string</span>);</span><br><span class="line"><span class="comment">// num = 324</span></span><br></pre></td></tr></table></figure></div>

<blockquote>
<p>  double atof (const char * str)</p>
<p>  long atol(const char * str)</p>
</blockquote>
</li>
</ol>
</li>
<li><p><strong>strtol strtoul</strong></p>
<ol>
<li><p><em><strong>long strtol(const char * restrict nptr, char ** restrict endptr, int base)</strong></em></p>
<blockquote>
<p>  restrict nptr 为要转换的字符串，restrict endptr 为第一个不能转换的字符的指针，base 为字符串所采用的进制</p>
</blockquote>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> <span class="built_in">string</span>[] = <span class="string">&quot;2001 60c0c0 -1101110100110100100000 0x6fffff&quot;</span>;</span><br><span class="line"><span class="type">char</span> *pend;</span><br><span class="line"><span class="type">long</span> <span class="type">int</span> ln1 = strtol(<span class="built_in">string</span>, &amp;pend, <span class="number">10</span>);				<span class="comment">// 十进制</span></span><br><span class="line"><span class="type">long</span> <span class="type">int</span> ln2 = strtol(<span class="built_in">string</span>, &amp;pend, <span class="number">16</span>);				<span class="comment">// 十六进制</span></span><br><span class="line"><span class="type">long</span> <span class="type">int</span> ln3 = strtol(<span class="built_in">string</span>, &amp;pend, <span class="number">2</span>);				<span class="comment">// 二进制</span></span><br></pre></td></tr></table></figure></div>

<blockquote>
<p>  unsigned long strtol(const char * restrict nptr, char ** restrict endptr, int base)</p>
</blockquote>
</li>
</ol>
</li>
<li><p><strong>数字转化为字符串</strong></p>
<p><code>itoa ftoa sprintf</code></p>
</li>
</ul>
<h2 id="文件输入-输出"><a href="#文件输入-输出" class="headerlink" title="文件输入&#x2F;输出"></a>文件输入&#x2F;输出</h2><h3 id="与文件进行通信"><a href="#与文件进行通信" class="headerlink" title="与文件进行通信"></a>与文件进行通信</h3><ul>
<li><p><strong>文件是什么</strong></p>
<p><strong><em>两种文件模式： 文本模式， 二进制模式</em></strong></p>
<blockquote>
<p>  <em>所有文件内容都以二进制形式存储</em></p>
<blockquote>
<p>  <em>文件最初以二进制编码的字符表示文本，该文件就是文本文件</em></p>
<p>  <em>文件以二进制代表机器语言或数值数据（图片，音乐），该文件就是二进制文件</em></p>
</blockquote>
</blockquote>
</li>
<li><p><strong>标准文件</strong></p>
<p><strong><em>标准输入 标准输出 标准错误输出</em></strong></p>
</li>
</ul>
<h3 id="标准IO"><a href="#标准IO" class="headerlink" title="标准IO"></a>标准IO</h3><p>关于exit(0) 和 return(0)<br>在最初的调用中，return (0) 和 exit(0) 一样<br>在递归程序中，exit(0) 会直接终止程序</p>
<ul>
<li><p><strong>fopen( )函数</strong></p>
<ol>
<li><p><strong><em>FILE * fopen ( const char * filename, const char * mode )</em></strong></p>
<table>
<thead>
<tr>
<th align="center"><em>模式字符串</em></th>
<th align="center"><em>含义</em></th>
</tr>
</thead>
<tbody><tr>
<td align="center"><em>“r”</em></td>
<td align="center"><em>读模式打开文件</em></td>
</tr>
<tr>
<td align="center"><em>“w”</em></td>
<td align="center"><em>写模式打开文件（覆盖写）</em></td>
</tr>
<tr>
<td align="center"><em>“a”</em></td>
<td align="center"><em>写模式打开文件（追加写）</em></td>
</tr>
<tr>
<td align="center"><em>“r+”</em></td>
<td align="center"><em>读写模式打开（更新模式）</em></td>
</tr>
<tr>
<td align="center"><em>“w+”</em></td>
<td align="center"><em>读写模式打开（更新模式），覆盖写</em></td>
</tr>
<tr>
<td align="center"><em>“a+”</em></td>
<td align="center"><em>读写模式打开（更新模式），追加写</em></td>
</tr>
<tr>
<td align="center"><em>“rb” “wb” “ab” “ab+”..</em></td>
<td align="center"><em>二进制模式打开</em></td>
</tr>
<tr>
<td align="center"><em>“wx” “wbx” “w+x”..</em></td>
<td align="center"><em>如果文件已存在或以独占模式打开，则打开失败</em></td>
</tr>
</tbody></table>
</li>
</ol>
<p><strong><em>对于UNIX 和 Linux这样只有一个文件类型的系统，二进制模式和非二进制模式一样</em></strong><br><em>fopen( ) 将返回文件指针 (FILE)</em></p>
</li>
<li><p><strong>getc putc</strong></p>
<p><strong><em>getc( ) putc( ) 与 getchar( ) putchar( ) 类似</em></strong></p>
<blockquote>
<p>  <em>int getc ( FILE * stream )</em></p>
</blockquote>
<blockquote>
<p>  <em>int putc ( int character, FILE * stream )</em></p>
</blockquote>
<p><strong><em>当stream为stdin，getc &#x3D; getchar，当stream为stdout，putc &#x3D; putchar</em></strong></p>
</li>
<li><p><strong>fclose( )函数</strong></p>
<p><strong><em>fclose( fp )函数关闭指定的文件，必要时刷新缓冲区</em></strong></p>
<blockquote>
<p>  <em>int fclose(FILE * stream)</em></p>
</blockquote>
<p><em>如果成功关闭，返回0,否则返回EOF</em></p>
</li>
<li><p><strong>指向标准文件的指针</strong></p>
<table>
<thead>
<tr>
<th align="center"><em>标准文件</em></th>
<th align="center"><em>文件指针</em></th>
<th align="center"><em>使用的设备</em></th>
</tr>
</thead>
<tbody><tr>
<td align="center"><em>标准输入</em></td>
<td align="center"><em>stdin</em></td>
<td align="center"><em>键盘</em></td>
</tr>
<tr>
<td align="center"><em>标准输出</em></td>
<td align="center"><em>stdout</em></td>
<td align="center"><em>显示器</em></td>
</tr>
<tr>
<td align="center"><em>标准错误</em></td>
<td align="center"><em>stderr</em></td>
<td align="center"><em>显示器</em></td>
</tr>
</tbody></table>
</li>
</ul>
<h3 id="文件IO"><a href="#文件IO" class="headerlink" title="文件IO"></a>文件IO</h3><ul>
<li><p><strong>fprintf( ) 和 fscanf( ) 函数</strong></p>
<blockquote>
<p>  <em>int fprintf(FILE *stream, const char *format, …)</em></p>
</blockquote>
<blockquote>
<p>  <em>int fscanf(FILE *stream, const char * format, … )</em></p>
</blockquote>
</li>
<li><p><strong>fegts( ) 和 fputs( ) 函数</strong></p>
<blockquote>
<p>  <em>char *fgets(char *buff, int size, FILE *stream)</em></p>
</blockquote>
<blockquote>
<p>  <em>int fputs(const char *buff, FILE *stream)</em></p>
</blockquote>
<p><strong><em>tips:    fputs不会在末尾加换行符，fgets保留了换行符</em></strong></p>
</li>
</ul>
<h3 id="随机访问"><a href="#随机访问" class="headerlink" title="随机访问"></a>随机访问</h3><ul>
<li><p><strong>fseek( ) ftell( )</strong></p>
<blockquote>
<p>  <em>int fseek(FILE * stream, long offset, int whence)</em></p>
</blockquote>
<blockquote>
<p>  <em>long ftell(FILE * stream)</em></p>
</blockquote>
<table>
<thead>
<tr>
<th>模式</th>
<th>偏移量的起始点</th>
</tr>
</thead>
<tbody><tr>
<td><em>SEEK_SET</em></td>
<td><em>文件开始处</em></td>
</tr>
<tr>
<td><em>SEEK_SUR</em></td>
<td><em>当前位置</em></td>
</tr>
<tr>
<td><em>SEEK_END</em></td>
<td><em>文件末尾</em></td>
</tr>
</tbody></table>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">fseek(fp, <span class="number">0L</span>, SEEK_SET); 		<span class="comment">// 定位至文件开始处</span></span><br><span class="line">fseek(fp, <span class="number">2L</span>, SEEK_CUR); 		<span class="comment">// 从文件当前位置前移2个字节</span></span><br><span class="line">fseek(fp, <span class="number">-10L</span>, SEEK_END); 		<span class="comment">// 从文件结尾处回退10个字节</span></span><br></pre></td></tr></table></figure></div>

<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">FILE *fp = fopen(<span class="string">&quot;demo.txt&quot;</span>,<span class="string">&quot;rb&quot;</span>);  </span><br><span class="line">fseek(fp, <span class="number">0L</span>, SEEK_END);</span><br><span class="line">len = ftell(fp)+<span class="number">1</span>;				<span class="comment">// 获取文件的长</span></span><br></pre></td></tr></table></figure></div>

<p><strong>_tips:    移植性更好的方法是逐字节读取整个文件直到文件末尾来实现SEEK_END</strong></p>
</li>
<li><p><strong>fgetpos( ) 和 fsetpos( ) 函数</strong></p>
<p><strong><em>针对大文件</em></strong></p>
<blockquote>
<p>  <em>int fgetpos(FILE * restrict stream, fpos_t * restrict pos)</em></p>
</blockquote>
<blockquote>
<p>  <em>int fsetpos(FILE *stream, const fpos_t *pos)</em></p>
</blockquote>
</li>
</ul>
<h3 id="其它标准IO函数"><a href="#其它标准IO函数" class="headerlink" title="其它标准IO函数"></a>其它标准IO函数</h3><table>
<thead>
<tr>
<th align="center">函数原型</th>
<th align="center">解释</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><em>int ungetc(int c, FILE *fp)</em></td>
<td align="center"><em>用于把指定字符放回输入流中</em></td>
</tr>
<tr>
<td align="center"><em>int fflush(FILE *fp)</em></td>
<td align="center"><em>刷新缓冲区，如果fp为空指针，刷新所有缓冲区</em></td>
</tr>
<tr>
<td align="center"><br><em>int setvbuf(FILE * restrict fp, char * restrict buf, int mode, size_t size)</em></td>
<td align="center"><em>创建指定大小的缓冲区<br>_ IOFBF 完全缓冲<br>_ IOLBF 行缓冲<br>_ IONBF 无缓冲</em></td>
</tr>
<tr>
<td align="center"><em>size_t fwrite(const void * restrict ptr, size_t size, size_t nmemb, FILE * restrict fp)</em></td>
<td align="center"><em>把二进制数据写入文件</em></td>
</tr>
<tr>
<td align="center"><em>size_t fread(void * restrict ptr, size_t size, size_t nmemb, FILE * restrict fp)</em></td>
<td align="center"><em>从流中读入二进制数据存储到ptr中</em></td>
</tr>
<tr>
<td align="center"><em>int feof(FILE *fp)</em></td>
<td align="center"><em>检测到文件结尾时，feof返回非0值</em></td>
</tr>
<tr>
<td align="center"><em>int ferror(FILE *fp)</em></td>
<td align="center"><em>当读写出现错误时，ferror返回非0值</em></td>
</tr>
<tr>
<td align="center"><em>void clearerr(FILE *fp)</em></td>
<td align="center"><em>对指定流的错误标志进行重置</em></td>
</tr>
<tr>
<td align="center"><em>FILE *tmpfile(void)</em></td>
<td align="center"><em>创建临时文件，在程序结束时就被删除</em></td>
</tr>
<tr>
<td align="center"><em>char *tmpnam(char *name)</em></td>
<td align="center"><em>参数为NULL时返回指向静态数组的指针，该数组包含创建的文件名</em></td>
</tr>
<tr>
<td align="center"><em>int remove(char const *filename)</em></td>
<td align="center"><em>删除指定文件</em></td>
</tr>
<tr>
<td align="center"><em>int rename(char *oldname, char const *newname)</em></td>
<td align="center"><em>更改文件名</em></td>
</tr>
</tbody></table>
<h2 id="结构和其他数据形式"><a href="#结构和其他数据形式" class="headerlink" title="结构和其他数据形式"></a>结构和其他数据形式</h2><h3 id="定义结构"><a href="#定义结构" class="headerlink" title="定义结构"></a>定义结构</h3><ul>
<li><p><strong>创建结构及初始化</strong></p>
<ol>
<li><p><strong><em>创建结构及声明</em></strong></p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">name</span> &#123;</span>...&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">name</span> <span class="title">a</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">name</span> *<span class="title">pa</span>;</span></span><br></pre></td></tr></table></figure></div>

<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">name</span> &#123;</span>...&#125;a;</span><br></pre></td></tr></table></figure></div>


</li>
<li><p><strong><em>结构体初始化</em></strong></p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">person</span> &#123;</span></span><br><span class="line">    <span class="type">char</span> name[<span class="number">10</span>];</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">person</span> <span class="title">a</span> =</span> &#123;</span><br><span class="line">    <span class="string">&quot;mark&quot;</span>,</span><br><span class="line">    <span class="number">18</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>


</li>
<li><p><strong><em>结构的指定初始化器</em></strong></p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">book</span> <span class="title">gift</span> =</span> &#123;</span><br><span class="line">    .value = <span class="number">25.99</span>,</span><br><span class="line">    .author = <span class="string">&quot;James Broad&quot;</span>,</span><br><span class="line">    .title = <span class="string">&quot;Rue for the Toad&quot;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div></li>
</ol>
</li>
<li><p><strong>声明结构数组及访问成员</strong></p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">book</span> <span class="title">lib</span>[<span class="title">MAXSIZE</span>];</span></span><br><span class="line">lib[<span class="number">0</span>].value;</span><br><span class="line">lib-&gt;value;					<span class="comment">// 访问第一个元素的value成员</span></span><br></pre></td></tr></table></figure></div>


</li>
<li><p><strong>嵌套结构</strong></p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">person</span> &#123;</span><span class="type">unsigned</span> <span class="type">int</span> age; <span class="type">char</span> bith[<span class="number">20</span>]; <span class="type">char</span> name[<span class="number">20</span>];&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">book</span> &#123;</span></span><br><span class="line">    person author;</span><br><span class="line">    <span class="type">double</span> value;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div></li>
</ul>
<h3 id="指向结构的指针"><a href="#指向结构的指针" class="headerlink" title="指向结构的指针"></a>指向结构的指针</h3><ul>
<li><p><strong>声明和初始化结构指针</strong></p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">guys</span> <span class="title">barney</span>, <span class="title">fellows</span>[20];</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">guys</span> *<span class="title">him</span> =</span> &amp;barney;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">guys</span> *<span class="title">him</span> =</span> fellow;</span><br></pre></td></tr></table></figure></div></li>
</ul>
<p><strong><em>tips:    如果要用结构存储字符串，用字符数组作为成员比较简单。用指向char的指针也行，但是误用会导致严重后果</em></strong></p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"> <span class="class"><span class="keyword">struct</span> <span class="title">names</span> &#123;</span></span><br><span class="line">     <span class="type">char</span> *first;</span><br><span class="line">     <span class="type">char</span> *last;</span><br><span class="line"> &#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">names</span> <span class="title">veep</span> =</span> &#123;<span class="string">&quot;Brad&quot;</span>, <span class="string">&quot;Summers&quot;</span>&#125;;			<span class="comment">// 没问题</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">names</span> <span class="title">person</span>;</span></span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, person.first);							<span class="comment">// 危险（不要这样使用）</span></span><br></pre></td></tr></table></figure></div>



<ul>
<li><p><strong>结构、指针和malloc</strong></p>
<blockquote>
<p>  <strong><em>使用malloc分配内存并使用指针存储地址</em></strong></p>
</blockquote>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">names</span> &#123;</span></span><br><span class="line">    <span class="type">char</span> *first;</span><br><span class="line">    <span class="type">char</span> *last;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">names</span> <span class="title">vp</span>;</span></span><br><span class="line">vp-&gt;first = (<span class="type">char</span> *)<span class="built_in">malloc</span>(size;</span><br><span class="line"><span class="comment">// 使用后 free</span></span><br><span class="line"><span class="built_in">free</span>(vp-&gt;first);</span><br></pre></td></tr></table></figure></div></li>
</ul>
<h3 id="关于结构一些特殊处理"><a href="#关于结构一些特殊处理" class="headerlink" title="关于结构一些特殊处理"></a>关于结构一些特殊处理</h3><ul>
<li><p><strong>复合字面量和结构</strong></p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// exp:</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">book</span> &#123;</span><span class="type">char</span> title[<span class="number">10</span>], <span class="type">char</span> author[<span class="number">10</span>], <span class="type">double</span> value;&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">book</span> <span class="title">readFirst</span>;</span></span><br><span class="line">readFirst = (<span class="keyword">struct</span> book)&#123;<span class="string">&quot;Crime&quot;</span>, <span class="string">&quot;Fyodor&quot;</span>, <span class="number">11.25</span>&#125;;</span><br></pre></td></tr></table></figure></div>

<p><strong><em>还可以把复合字面量作为函数的参数</em></strong></p>
</li>
<li><p><strong>伸缩型数组成员</strong></p>
<p><strong><em>数组成员必须是最后一个成员，且至少要有一个成员。使用时可以通过malloc来动态开辟任意大小的数组空间</em></strong></p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">demo</span> &#123;</span><span class="type">int</span> a; <span class="type">int</span> arr[];&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">demo</span> *<span class="title">p</span>;</span></span><br><span class="line">p = (<span class="keyword">struct</span> demo *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> demo) + <span class="number">5</span> * <span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">p = (<span class="keyword">struct</span> demo *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> demo) + <span class="number">10</span> * <span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br></pre></td></tr></table></figure></div>

<p><strong><em>带伸缩型数组成员的结构有一些特殊处理要求</em></strong></p>
<blockquote>
<p>  <em>不能用结构进行复制或拷贝</em></p>
<p>  <em>不要以按值方式把这种结构传递给结构</em></p>
<p>  <em>不要使用带伸缩型数组成员的结构作为数组成员或另一个结构的成员</em></p>
</blockquote>
</li>
<li><p><strong>匿名结构</strong></p>
<p><strong><em>通过嵌套格式来实现匿名结构体</em></strong></p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">outer</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> v;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">        <span class="type">char</span> <span class="built_in">string</span>[<span class="number">20</span>], name[<span class="number">20</span>];</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>

<p><em>使用时可以直接把匿名结构体中的成员看成outer的成员使用</em></p>
</li>
<li><p><strong>把结构内容保存到文件</strong></p>
<p><strong><em>一般我们采用二进制格式写入</em></strong></p>
<ol>
<li><p><strong>使用fprintf( )</strong></p>
<p><em>效率比较低，可以通过固定字段宽度的格式来解决字段位置问题</em></p>
</li>
<li><p><strong>使用fwrite( )</strong></p>
<p><em>一次读写整个记录而非一个字段</em></p>
<p><strong><em>缺点是可能导致数据文件不具有可移植性</em></strong></p>
</li>
</ol>
</li>
</ul>
<h3 id="联合union"><a href="#联合union" class="headerlink" title="联合union"></a>联合union</h3><p><strong><em>联合（union）是一种数据类型，能在同一个内存空间中存储不同的数据类型（不是同时存储）</em></strong></p>
<ul>
<li><p><strong>创建初始化union</strong></p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">hold</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> digit;</span><br><span class="line">    <span class="type">double</span> bigfl;</span><br><span class="line">    <span class="type">char</span> letter;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">hold</span> <span class="title">a</span>;</span></span><br><span class="line">a.letter = <span class="string">&#x27;A&#x27;</span>;</span><br><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">hold</span> <span class="title">b</span> =</span> a;		<span class="comment">// 用另一个union来初始化</span></span><br><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">hold</span> <span class="title">c</span> =</span> &#123;<span class="number">8</span>&#125;;		<span class="comment">// 初始化联合的digit成员</span></span><br><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">hold</span> <span class="title">d</span> =</span> &#123;.bigfl = <span class="number">12.3</span>&#125;;	<span class="comment">// 指定初始化器初始化bigfl成员</span></span><br></pre></td></tr></table></figure></div>


</li>
<li><p><strong>使用union</strong></p>
<p><code>.</code>表示正在使用哪种运算符， 和使用指针访问结构体一样，使用<code>-&gt;</code></p>
</li>
<li><p><strong>匿名联合</strong></p>
<blockquote>
<p>  与匿名结构类似</p>
</blockquote>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">data</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> vp;</span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span><span class="type">double</span> v; <span class="type">char</span> ch;&#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div></li>
</ul>
<h3 id="枚举enum"><a href="#枚举enum" class="headerlink" title="枚举enum"></a>枚举enum</h3><p><strong><em>可以使用枚举类型来声明符号名称表示整型常量</em></strong></p>
<ul>
<li><p><strong>创建枚举类型</strong></p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">spectrum</span> &#123;</span>red, orange, yellow, green, blue, violet&#125;;</span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">spectrum</span> <span class="title">color</span>;</span></span><br></pre></td></tr></table></figure></div>

<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">color = blue;</span><br><span class="line"><span class="keyword">if</span> (color == yellow);</span><br><span class="line">...</span><br></pre></td></tr></table></figure></div>

<blockquote>
<p>  <em>枚举符是int类型，但是枚举变量可以是任意整数类型</em></p>
</blockquote>
<p><strong><em>C允许枚举变量使用++运算符，C++不允许，如果要将C代码并入C++程序，必须声明为int类型</em></strong></p>
</li>
<li><p><strong>概念及用法</strong></p>
<ol>
<li><p><strong><em>enum常量</em></strong></p>
<blockquote>
<p>  <em>enum成员从技术层面上看就是int类型的常量</em></p>
</blockquote>
</li>
<li><p><strong><em>默认值</em></strong></p>
<blockquote>
<p>  <em>默认情况下，枚举列表中的常量被赋予0, 1, 2…</em></p>
</blockquote>
</li>
<li><p><strong><em>赋值</em></strong></p>
<blockquote>
<p>  <em>可以为枚举常量指定整数值</em></p>
</blockquote>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">feline</span> &#123;</span>cat, lynx = <span class="number">10</span>, puma, tiger&#125;;</span><br></pre></td></tr></table></figure></div>

<p><strong><em>cat值默认为0, lynx &#x3D; 10, puma &#x3D; 11, tiger &#x3D; 12</em></strong></p>
</li>
<li><p><strong><em>enum用法</em></strong></p>
<p><strong><em>枚举类型的目的就是为了提高程序的可读性和可维护性</em></strong></p>
</li>
<li><p><strong><em>共享名称空间</em></strong></p>
<p><strong><em>两个不同作用域的同名变量不冲突，两个相同作用域的同名变量冲突</em></strong></p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rect</span> &#123;</span><span class="type">double</span> x; <span class="type">double</span> y;&#125;;</span><br><span class="line"><span class="type">int</span> rect;							<span class="comment">// 不会产生冲突</span></span><br></pre></td></tr></table></figure></div>

<blockquote>
<p>  <em>结构，联合，枚举享有相同的名称空间</em></p>
</blockquote>
</li>
</ol>
</li>
</ul>
<h3 id="typedef"><a href="#typedef" class="headerlink" title="typedef"></a>typedef</h3><p><strong><em>使用typedef可以为某一类型自定义名称</em></strong></p>
<ul>
<li><p><strong>与define的不同之处</strong></p>
<ol>
<li><strong><em>typedef创建的符号只受限于类型，不能用于值</em></strong></li>
<li><strong><em>typedef由编译器解释，不是预处理器</em></strong></li>
<li><strong><em>typedef更灵活</em></strong></li>
</ol>
</li>
<li><p><strong>使用</strong></p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">char</span> byte;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> byte unsigned char</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span>...&#125;name;	<span class="comment">// 可省略结构标签</span></span><br></pre></td></tr></table></figure></div></li>
</ul>
<h2 id="位操作"><a href="#位操作" class="headerlink" title="位操作"></a>位操作</h2><h3 id="C按位运算符"><a href="#C按位运算符" class="headerlink" title="C按位运算符"></a>C按位运算符</h3><ul>
<li><p><strong>按位逻辑运算符</strong></p>
<table>
<thead>
<tr>
<th align="center"><em>逻辑运算</em></th>
<th align="center"><em>位操作符</em></th>
<th align="center"><em>用处</em></th>
</tr>
</thead>
<tbody><tr>
<td align="center"><em>按位取反</em></td>
<td align="center"><em>~</em></td>
<td align="center"><em>清空位</em></td>
</tr>
<tr>
<td align="center"><em>按位与</em></td>
<td align="center"><em>&amp;</em></td>
<td align="center"><em>掩码（检查位）</em></td>
</tr>
<tr>
<td align="center"><em>按位或</em></td>
<td align="center"><em>|</em></td>
<td align="center"><em>打开位</em></td>
</tr>
<tr>
<td align="center"><em>按位异或</em></td>
<td align="center"><em>^</em></td>
<td align="center"><em>切换位</em></td>
</tr>
</tbody></table>
</li>
<li><p><strong>移位运算符</strong></p>
<ol>
<li><p><em><strong>左移：&lt;&lt;</strong></em></p>
<p>将其左侧运算对象每一位的值向左移动其右侧运算对象指定的位数  </p>
<p>左侧运算对象移出左末端位的值丢失， 用0填充空出的位置</p>
</li>
<li><p><em><strong>右移：&gt;&gt;</strong></em></p>
<p>将其左侧运算对象每一位的值向右移动其右侧运算对象指定的位数  </p>
<p>左侧运算对象移出右末端位的值丢。 对于无符号类型， 用0 填充空出的位置  </p>
<p>对于有符号类型， 其结果取决于机器。 空出的位置可用0填充， 或者用符号位（即， 最左端的位） 的副本填充</p>
</li>
</ol>
</li>
</ul>
<h3 id="位字段"><a href="#位字段" class="headerlink" title="位字段"></a>位字段</h3><blockquote>
<p>  位字段通过结构体来创建</p>
</blockquote>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">box_props</span> &#123;</span></span><br><span class="line">    <span class="type">bool</span> opaque : <span class="number">1</span> ;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> fill_color : <span class="number">3</span> ;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> : <span class="number">4</span> ;</span><br><span class="line">    <span class="type">bool</span> show_border : <span class="number">1</span> ;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> border_color : <span class="number">3</span> ;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> border_style : <span class="number">2</span> ;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> : <span class="number">2</span> ;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> big_bit : <span class="number">26</span> ;</span><br><span class="line">&#125;demo;</span><br><span class="line">demo.opaque = <span class="number">1</span>;			<span class="comment">// 确保所赋的值在字段可容纳的范围</span></span><br></pre></td></tr></table></figure></div>

<p><strong><em>tips:    如果声明总位数超过一个unsigned int 类型大小，会用到下一个unsigned int 类型的存储位置</em></strong></p>
<p><strong><em>并且编译器会自动移动跨界的字段，保持unsigend int 的边界对齐</em></strong></p>
<blockquote>
<p>  当相邻成员的类型相同时，如果它们的位宽之和小于类型的 sizeof 大小，那么后面的成员紧邻前一个成员存储，直到不能容纳为止；</p>
<p>  如果它们的位宽之和大于类型的 sizeof 大小，那么后面的成员将从新的存储单元开始，其偏移量为类型大小的整数倍</p>
</blockquote>
<blockquote>
<p>  当相邻成员的类型不同时，不同的编译器有不同的实现方案，GCC会压缩存储，而 VC&#x2F;VS 不会</p>
</blockquote>
<blockquote>
<p>  如果成员之间穿插着非位域成员，那么不会进行压缩</p>
</blockquote>
<ul>
<li><p><strong>无名位字段</strong></p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> field1 : <span class="number">1</span> ;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> : <span class="number">2</span> ;				<span class="comment">// 无名位字段</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> field2 : <span class="number">1</span> ;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> : <span class="number">0</span> ;				<span class="comment">// 无名位字段</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> field3 : <span class="number">1</span> ;</span><br><span class="line">&#125; stuff;</span><br></pre></td></tr></table></figure></div>

<p><strong><em>填充，强迫字段对齐</em></strong></p>
</li>
</ul>
<h3 id="对齐特性"><a href="#对齐特性" class="headerlink" title="对齐特性"></a>对齐特性</h3><p>_Alignof运算符给出一个类型的对齐要求<code>size_t d_align = _Alignof(float)</code></p>
<p>_Alignas 说明符指定一个变量或类型的对齐值<code>_Alignas(double) char c1</code></p>
<p>对齐动态分配内存<code>void *aligned_alloc(size_t alignment, size_t size)</code></p>
<h1 id="C进阶"><a href="#C进阶" class="headerlink" title="C进阶"></a>C进阶</h1><h2 id="预处理"><a href="#预处理" class="headerlink" title="预处理"></a>预处理</h2><h3 id="编译流程"><a href="#编译流程" class="headerlink" title="编译流程"></a>编译流程</h3><ul>
<li><p><strong>编译器翻译</strong></p>
<p>编译器把源代码中出现的字符映射到源字符集</p>
<p>编译器定位每个反斜杠后面跟着换行符的实例， 并删除它们</p>
<p>编译器把文本划分成预处理记号序列、 空白序列和注释序列</p>
</li>
<li><p><strong>预处理</strong></p>
<ol>
<li><p><strong><em>#define</em></strong></p>
<p><em>使用define来定义明示常量（符号常量）</em></p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> TWO 2</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FOUR TWO*TWO</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PX printf(<span class="string">&quot;X is %d.\n&quot;</span>, x)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FMT <span class="string">&quot;X is %d.\n&quot;</span></span></span><br></pre></td></tr></table></figure></div>

<ul>
<li><p><em>字符型字符串 和 记号型字符串</em></p>
</li>
<li><p><em>重定义常量</em></p>
<blockquote>
<p>  <strong><em>只有新定义和旧定义完全相同才允许重定义</em></strong></p>
<blockquote>
<p>  <em>具有相同定义意味着替换体中的记号必须相同</em>  </p>
<p>  <em>如果确实需要重定义常量，使用const和作用域规则更容易</em></p>
</blockquote>
</blockquote>
</li>
<li><p><em>在 #define中使用参数</em></p>
<p><strong><em>用于创建类函数宏</em></strong></p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> SQUARE(X) X*X</span></span><br></pre></td></tr></table></figure></div>

<p><strong><em>用宏参数创建字符串：#运算符</em></strong></p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> PSQR(X) printf(<span class="string">&quot;The square of &quot;</span>#X<span class="string">&quot; is %d.\n&quot;</span>, ((X)*(X)));</span></span><br><span class="line"><span class="type">int</span> t = <span class="number">5</span>;</span><br><span class="line">PSQR(t);		<span class="comment">// The square of t is 25</span></span><br><span class="line">PSQR(<span class="number">5</span>);		<span class="comment">// The square of 5 is 25</span></span><br></pre></td></tr></table></figure></div>

<p><strong><em>预处理器黏合剂：##运算符</em></strong></p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> XNAME(n) x##n</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">XNAME</span><span class="params">(<span class="number">1</span>)</span> = <span class="number">10</span>;			<span class="comment">// x1 = 10</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">XNAME</span><span class="params">(x)</span> = <span class="number">20</span>;			<span class="comment">// xx = 20</span></span><br></pre></td></tr></table></figure></div>

<p><strong>_ 变参宏：… 和 _ _ VA _ ARGS _ _</strong></p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> PR(...) printf(__VA_ARGS__)</span></span><br><span class="line">PR(<span class="string">&quot;Hello\n&quot;</span>);</span><br><span class="line">PR(<span class="string">&quot;weight=%d, shipping=$%.2f\n&quot;</span>, wt, sp); </span><br></pre></td></tr></table></figure></div>

<blockquote>
<p>  <em>宏生成内联代码，执行效率上比函数高，但是多次调用内存开销大（宏本质上就是插入代码片段）</em></p>
</blockquote>
</li>
</ul>
</li>
<li><p><strong><em>文件包含：#include</em></strong></p>
<ul>
<li><p><em>#include的两种形式</em></p>
<p>文件名在尖括号里，告诉预处理器在标准系统目录中查找该文件</p>
<p>文件名在双引号里，告诉预处理器首先在当前目录中（或文件名指定的其它目录中）查找该文件</p>
</li>
<li><p><em>使用头文件</em></p>
<p><strong><em>头文件一般都含有以下内容：</em></strong></p>
<ol>
<li>明示常量</li>
<li>宏函数</li>
<li>函数声明</li>
<li>结构模板定义</li>
<li>类型定义</li>
</ol>
<blockquote>
<p>  还可以通过头文件声明外部变量供其它文件共享</p>
</blockquote>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> status = <span class="number">0</span>;				<span class="comment">// 该变量具有文件作用域，在源代码文件</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> status;			<span class="comment">// 在头文件中</span></span><br></pre></td></tr></table></figure></div>

<p><strong><em>需要使用头文件的另一种情况是：</em></strong></p>
<p>使用具有文件作用域、 内部链接和const 限定符的变量或数组。 const 防止值被意外修改， static 意味着每个包含<br>该头文件的文件都获得一份副本。 因此， 不需要在一个文件中进行定义式声明， 在其他文件中进行引用式声明。</p>
</li>
</ul>
</li>
</ol>
</li>
</ul>
<h3 id="其他命令"><a href="#其他命令" class="headerlink" title="其他命令"></a>其他命令</h3><ul>
<li><p><strong>#undef</strong></p>
<p><strong><em>用于取消已定义的#define指令</em></strong></p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> LIMIT 100</span></span><br><span class="line"><span class="meta">#<span class="keyword">undef</span> LIMIT</span></span><br></pre></td></tr></table></figure></div>

<blockquote>
<p>  #define宏的作用域从它在文件中的声明处开始， 直到用#undef指令取消宏为止， 或延伸至文件尾（以二者中先满足的条件作为宏作用域的结<br>  束） 。 另外还要注意， 如果宏通过头文件引入， 那么#define在文件中的位置取决于#include指令的位置。</p>
</blockquote>
</li>
<li><p><strong>条件编译</strong></p>
<ol>
<li><p><strong><em>#ifdef #else #endif</em></strong></p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _LABEL		<span class="comment">// 如果该宏已定义，执行 1</span></span></span><br><span class="line"><span class="comment">/* ...1 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span>				<span class="comment">// 否则执行 2</span></span></span><br><span class="line"><span class="comment">/* ...2 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure></div>


</li>
<li><p><em><strong>#ifndef</strong></em></p>
<blockquote>
<p>  <em>与#ifdef逻辑相反，使用类似</em></p>
</blockquote>
<p><strong><em>防止相同的宏被重复定义</em></strong></p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> _LABEL</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _LABEL</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure></div>

<p><strong><em>防止多次包含同一个文件</em></strong></p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> THINGS_H_</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> THINGS_H_</span></span><br><span class="line"><span class="comment">/* ... */</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure></div>


</li>
<li><p><em><strong>#if #elif</strong></em></p>
<blockquote>
<p>  <em>#if指令很像C语言中的if。 #if后面跟整型常量表达式， 如果表达式为非零， 则表达式为真。 可以在指令中使用C的关系运算符和逻辑运算符</em></p>
</blockquote>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">if</span> SYS == 1</span></span><br><span class="line"><span class="comment">/* ... */</span></span><br><span class="line"><span class="meta">#<span class="keyword">elif</span> SYS == 0</span></span><br><span class="line"><span class="comment">/* ... */</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="comment">/* ... */</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure></div>

<ul>
<li><p><em>另一种方式实现#ifdef</em></p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">if</span> defined (IBMPC)</span></span><br><span class="line"><span class="comment">/* ... */</span></span><br><span class="line"><span class="meta">#<span class="keyword">elif</span> defined (VAX)</span></span><br><span class="line"><span class="comment">/* ... */</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="comment">/* ... */</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure></div></li>
</ul>
</li>
</ol>
</li>
<li><p><strong>预定义宏</strong></p>
<table>
<thead>
<tr>
<th align="center">宏</th>
<th align="center">含义</th>
</tr>
</thead>
<tbody><tr>
<td align="center">_ _ DATE _ _</td>
<td align="center">预处理的时间</td>
</tr>
<tr>
<td align="center">_ _ FILE _ _</td>
<td align="center">表示当前源代码文件名的字符串字面量</td>
</tr>
<tr>
<td align="center">_ _ LINE _ _</td>
<td align="center">表示当前源代码文件中行号的整型常量</td>
</tr>
<tr>
<td align="center">_ _ STDC _ _</td>
<td align="center">设置为1时，表明实现遵循C标准</td>
</tr>
<tr>
<td align="center">_ _ STDC_HOSTED _ _</td>
<td align="center">本机环境设置为1,否则设置为0</td>
</tr>
<tr>
<td align="center">_ _ STDC_VERSION _ _</td>
<td align="center">支持C99标准设置为199901L；支持C11标准设置为201112L</td>
</tr>
<tr>
<td align="center">_ _ TIME _ _</td>
<td align="center">翻译代码的时间</td>
</tr>
</tbody></table>
</li>
<li><p><strong>#line #error</strong></p>
<p><strong><em>#line指令重置 _ _ LINE _ _ 和 _ _ FILE _ _ 宏报告的行号和文件名</em></strong></p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">line</span> 1000				<span class="comment">// 重置行号</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">line</span> 10 <span class="string">&quot;main.c&quot;</span>		<span class="comment">// 重置行号和文件名</span></span></span><br></pre></td></tr></table></figure></div>

<p><strong><em>#error指令让预处理器发出一条错误消息，该消息包含指令中的文本，如果可能的话编译应该中断</em></strong></p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">if</span> __STDC_VERSION__ != 201112L</span></span><br><span class="line"><span class="meta">#<span class="keyword">error</span> Not C11</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure></div>


</li>
<li><p><strong>#pragma</strong></p>
<p><strong><em>#pragma把编译器指令放入了源代码中</em></strong></p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> c9x on</span></span><br><span class="line"><span class="keyword">_Pragma</span>(<span class="string">&quot;nonstandardtreatmenttypeB on&quot;</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> nonstandardtreatmenttypeB on			<span class="comment">// 等价</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// _Pragma 运算符完成“解字符串”（destringizing） 的工作</span></span><br><span class="line"><span class="keyword">_Pragma</span>(<span class="string">&quot;use_bool \&quot;true \&quot;false&quot;</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> use_bool <span class="string">&quot;true &quot;</span>false</span></span><br></pre></td></tr></table></figure></div>



<ol>
<li><p><strong><em>#pragma message</em></strong></p>
<p><em>在编译信息输出窗口中输出相应的信息，这对于源代码信息的控制是非常重要</em></p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _X86</span></span><br><span class="line">#Pragma <span class="title function_">message</span><span class="params">(“_X86 macro activated!”)</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure></div>


</li>
<li><p><strong><em>#pragma code_seg</em></strong></p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> code_seg( [<span class="string">&quot;section-name&quot;</span>[,<span class="string">&quot;section-class&quot;</span>] ] )</span></span><br></pre></td></tr></table></figure></div>

<p><em>设置程序中函数代码存放的代码段，当我们开发驱动程序的时候就会使用到它</em></p>
</li>
<li><p><strong><em>#pragma once</em></strong></p>
<p><em>只要在头文件的最开始加入这条指令就能够保证头文件被编译一次</em></p>
</li>
<li><p><strong><em>#pragma hdrstop</em></strong></p>
<p><em>表示预编译头文件到此为止，后面的头文件不进行预编译，排除一些头文件</em></p>
</li>
<li><p><strong><em>#pragma startup</em></strong></p>
<p><em>单元之间有依赖关系，需要指定编译优先级，通过#pragma startup来指定编译优先级</em></p>
</li>
<li><p><strong><em>#pragma resource</em></strong></p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> resource <span class="string">&quot;*.dfm&quot;</span></span></span><br></pre></td></tr></table></figure></div>

<p><em>表示把*.dfm 文件中的资源加入工程</em></p>
</li>
<li><p><em><strong>#pragma warning</strong></em></p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> <span class="keyword">warning</span>( disable : 4507 34; once : 4385; <span class="keyword">error</span> : 164 )</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> <span class="keyword">warning</span>(disable:4507 34) 	<span class="comment">// 不显示 4507 和 34 号警告信息</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> <span class="keyword">warning</span>(once:4385) 			<span class="comment">// 4385 号警告信息仅报告一次</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> <span class="keyword">warning</span>(<span class="keyword">error</span>:164) 			<span class="comment">// 把 164 号警告信息作为一个错误</span></span></span><br></pre></td></tr></table></figure></div>

<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> <span class="keyword">warning</span>( push [ ,n ] )		<span class="comment">// 保存现在所有警告信息的现有警告状态，并把全局警告等级设为n(1-4)</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> <span class="keyword">warning</span>( pop )				<span class="comment">// 向栈中弹出最后一个警告信息，在入栈和出栈之间所作的一切改动取消</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> <span class="keyword">warning</span>( push )</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> <span class="keyword">warning</span>( disable : 4705 )</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> <span class="keyword">warning</span>( disable : 4706 )</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> <span class="keyword">warning</span>( disable : 4707 )</span></span><br><span class="line"><span class="comment">//.......</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> <span class="keyword">warning</span>( pop )				<span class="comment">// 重新保存所有的警告信息(包括 4705， 4706 和 4707)</span></span></span><br></pre></td></tr></table></figure></div>


</li>
<li><p><em><strong>#pragma comment</strong></em></p>
<p><em>将一个注释记录放入一个对象文件或可执行文件中</em></p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> comment(lib, <span class="string">&quot;user32.lib&quot;</span>)</span></span><br><span class="line"><span class="comment">// 将 user32.lib 库文件加入到本工程中</span></span><br></pre></td></tr></table></figure></div>

<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> comment(linker, <span class="string">&quot;/include:__mySymbol&quot;</span>)</span></span><br></pre></td></tr></table></figure></div>

<blockquote>
<p>  <em>linker:将一个链接选项放入目标文件中,你可以使用这个指令来代替由命令行传入的或<br>  者在开发环境中设置的链接选项,你可以指定&#x2F;include 选项来强制包含某个对象</em></p>
</blockquote>
</li>
<li><p><em><strong>#pragma pack</strong></em></p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TestStruct1</span> &#123;</span>	<span class="comment">//编译器默认进行内存对齐（浪费了存储空间）</span></span><br><span class="line">    <span class="type">char</span> c1; <span class="type">short</span> s; <span class="type">char</span> c2; <span class="type">int</span> i;</span><br><span class="line">&#125;; <span class="comment">//  c1 00000000, s 00000002, c2 00000004, i 00000008</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TestStruct2</span> &#123;</span>	<span class="comment">// 小技巧来优化</span></span><br><span class="line">    <span class="type">char</span> c1; <span class="type">char</span> c2; <span class="type">short</span> s; <span class="type">int</span> i;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>

<ul>
<li><p><em>利用#pragma pack（）来改变编译器的默认对齐方式</em></p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">使用指令<span class="meta">#<span class="keyword">pragma</span> pack (n)，编译器将按照 n 个字节对齐</span></span><br><span class="line">使用指令<span class="meta">#<span class="keyword">pragma</span> pack ()，编译器将取消自定义字节对齐方式</span></span><br></pre></td></tr></table></figure></div></li>
</ul>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> pack(push) 				<span class="comment">//保存当前对其方式到 packing stack</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> pack(push,n)</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> pack(push)</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> pack(n) 				<span class="comment">//n=1,2,4,8,16 保存当前对齐方式，设置按 n 字节对齐</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> pack(pop) 				<span class="comment">//packing stack 出栈，并将对其方式设置为出栈的对齐方</span></span></span><br></pre></td></tr></table></figure></div></li>
</ol>
</li>
<li><p><strong>泛型选择</strong></p>
<blockquote>
<p>  _<em>Generic(x, int: 0, float: 1, double: 2, default: 3)</em></p>
</blockquote>
</li>
</ul>
<h3 id="内联函数"><a href="#内联函数" class="headerlink" title="内联函数"></a>内联函数</h3><p><strong><em>规定了内联函数的定义与调用该函数的代码必须在同一个文件中</em></strong></p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">inline</span> <span class="type">static</span> <span class="type">void</span> <span class="title function_">eatline</span><span class="params">()</span> <span class="comment">// 内联函数定义/原型</span></span><br><span class="line">&#123; </span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p><em>内联函数应该比较短小。 把较长的函数变成内联并未节约多少时间， 因为执行函数体的时间比调用函数的时间长得多</em>  </p>
<p>如果程序有多个文件都要使用某个内联函数， 那么这些文件中都必须包含该内联函数的定义。 最简单的做法是， 把内联  </p>
<p>函数定义放入头文件， 并在使用该内联函数的文件中包含该头文件即可。</p>
<h3 id="const-define"><a href="#const-define" class="headerlink" title="const &amp; define"></a>const &amp; define</h3><p><strong><em>const为只读变量，在C语言中使用const修饰的变量仍然为变量</em></strong></p>
<ul>
<li><p><strong>const 更加节省空间，避免了不必要的内存分配，同时提高了效率</strong></p>
<blockquote>
<p>  <em>编译器通常不为普通 const 只读变量分配存储空间，而是将它们保存在符号表中</em></p>
<p>  <em>const 定义的只读变量在程序运行过程中只有一份拷贝（因为它是全局的只读变量，存放在静态区）</em></p>
<p>  <em>#define 定义的宏常量在内存中有若干个拷贝</em></p>
</blockquote>
</li>
</ul>
<h2 id="指针和数组-1"><a href="#指针和数组-1" class="headerlink" title="指针和数组"></a>指针和数组</h2><p><strong><em>指针是指针，数组是数组</em></strong></p>
<h3 id="两种访问形式"><a href="#两种访问形式" class="headerlink" title="两种访问形式"></a>两种访问形式</h3><ul>
<li><p><strong>指针和数组均可以通过下表和解引用形式来访问元素</strong></p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> arr[] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line"><span class="type">int</span> *arr = a;</span><br><span class="line"></span><br><span class="line">arr[<span class="number">0</span>], arr[<span class="number">1</span>], arr[<span class="number">2</span>];</span><br><span class="line">*(arr), *(arr+<span class="number">1</span>), *(arr+<span class="number">2</span>);			<span class="comment">// right</span></span><br></pre></td></tr></table></figure></div>


</li>
<li><p><strong>指针和数组的区别</strong></p>
<ol>
<li><p><strong><em>sizeof</em></strong></p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> *pa, a[<span class="number">10</span>];</span><br><span class="line"><span class="keyword">sizeof</span>(pa) == <span class="number">8</span>;		<span class="comment">// 64位操作系统下（寻址能力为8字节）</span></span><br><span class="line"><span class="keyword">sizeof</span>(a) == <span class="number">40</span>;		<span class="comment">// sizeof(int) * 10 = 40</span></span><br></pre></td></tr></table></figure></div>


</li>
<li><p><strong><em>访问流程</em></strong></p>
<p>当你通过指针变量去访问数组时，先访问内存获取指针的值（即数组首地址），再通过地址指针来访问数据。  </p>
<p>在定义数组时，编译器在某个地方保存了数组首地址，通过数组名访问数组时，直接计算偏移量然后直接访问。</p>
</li>
<li><p><strong><em>左值与右值</em></strong></p>
<blockquote>
<p>  <em>指针变量可以是右值和左值，可以使用自增运算符。数组名是左值，不可改变。</em></p>
</blockquote>
</li>
<li><p><strong><em>易错</em></strong></p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// file 1</span></span><br><span class="line"><span class="type">int</span> arr[<span class="number">10</span>];</span><br><span class="line"><span class="comment">// file 2</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> *arr;			</span><br></pre></td></tr></table></figure></div>

<blockquote>
<p>  <em>定义为数组，声明为指针和定义为指针，声明为数组均错误。</em></p>
</blockquote>
</li>
</ol>
</li>
</ul>
<h3 id="一维二维数组与指针"><a href="#一维二维数组与指针" class="headerlink" title="一维二维数组与指针"></a>一维二维数组与指针</h3><ul>
<li><p><strong><em>一维</em></strong></p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> arr[<span class="number">10</span>];</span><br><span class="line"><span class="type">int</span> *p1 = &amp;arr[<span class="number">0</span>];</span><br><span class="line"><span class="type">int</span> *p2 = arr;</span><br><span class="line">*(p1 + pos), p1[pos];</span><br></pre></td></tr></table></figure></div>



<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> (*p3)[<span class="number">10</span>] = &amp;arr;</span><br><span class="line">*(*p3 + pos), (*p3)[pos];</span><br></pre></td></tr></table></figure></div>


</li>
<li><p><strong><em>二维</em></strong></p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> arr[rows][cols];</span><br><span class="line"><span class="type">int</span> *p1 = &amp;arr[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line"><span class="type">int</span> *p2 = arr[<span class="number">0</span>];</span><br><span class="line">*(p1+i*cols+j), p1[i*cols+j];</span><br></pre></td></tr></table></figure></div>



<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> (*p3)[<span class="number">10</span>] = &amp;arr[<span class="number">0</span>];</span><br><span class="line"><span class="type">int</span> (*p4)[<span class="number">10</span>] = arr;</span><br><span class="line">*(*(p3+i)+j), p3[i][j];</span><br></pre></td></tr></table></figure></div>



<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> (*p5)[<span class="number">5</span>][<span class="number">10</span>] = &amp;arr;</span><br><span class="line">*(*(*p5+i)+j), (*p5)[i][j];</span><br></pre></td></tr></table></figure></div></li>
</ul>
<h3 id="指针数组与函数指针"><a href="#指针数组与函数指针" class="headerlink" title="指针数组与函数指针"></a>指针数组与函数指针</h3><ul>
<li><p><strong>指针数组</strong></p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> *pa[<span class="number">5</span>];</span><br><span class="line"><span class="type">char</span> **ppa;</span><br></pre></td></tr></table></figure></div>


</li>
<li><p><strong>函数指针</strong></p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span>* <span class="title function_">func</span><span class="params">(<span class="type">char</span> *s)</span>;</span><br><span class="line"><span class="type">char</span>* (*pf)(<span class="type">char</span> *s);</span><br><span class="line">pf = &amp;func, <span class="comment">/* or */</span> pf = func;</span><br></pre></td></tr></table></figure></div>

<ol>
<li><p><strong><em>函数指针数组</em></strong></p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span>* (*pf[<span class="number">5</span>])(<span class="type">char</span> *s);</span><br><span class="line">pf[<span class="number">0</span>] = &amp;func;</span><br></pre></td></tr></table></figure></div>


</li>
<li><p><strong><em>函数指针数组指针</em></strong></p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span>* (*(*pf)[<span class="number">5</span>])(<span class="type">char</span> *s);</span><br><span class="line">pf[<span class="number">0</span>][<span class="number">0</span>] = &amp;func;</span><br></pre></td></tr></table></figure></div></li>
</ol>
</li>
</ul>
<h2 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h2><h3 id="堆-栈-静态区"><a href="#堆-栈-静态区" class="headerlink" title="堆 栈 静态区"></a>堆 栈 静态区</h3><ul>
<li><p>&#x3D;&#x3D;静态区&#x3D;&#x3D;：<strong>保存自动全局变量和 static 变量（包括 static 全局和局部变量）</strong></p>
<p><strong>静态区的内容在总个程序的生命周期内都存在由编译器在编译的时候分配</strong></p>
</li>
<li><p>&#x3D;&#x3D;栈&#x3D;&#x3D;：<strong>保存局部变量。栈上的内容只在函数的范围内存在，当函数运行结束</strong></p>
<p><strong>这些内容也会自动被销毁。其特点是效率高，但空间大小有限</strong></p>
</li>
<li><p>&#x3D;&#x3D;堆&#x3D;&#x3D;：<strong>由 malloc 系列函数或 new 操作符分配的内存。其生命周期由 free 或 delete 决定。<br>在没有释放之前一直存在，直到程序结束。其特点是使用灵活，空间比较大，但容易出错</strong></p>
</li>
</ul>
<h3 id="常见的内存错误"><a href="#常见的内存错误" class="headerlink" title="常见的内存错误"></a>常见的内存错误</h3><ul>
<li><p><strong>函数的入口检验</strong></p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">assert(<span class="literal">NULL</span> != p); 		<span class="comment">// 函数入口处</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="literal">NULL</span> != p);			<span class="comment">// 非参数处</span></span><br></pre></td></tr></table></figure></div>

<p><strong><em>在使用这些检验时都要求p在定义时被初始化为NULL</em></strong></p>
<blockquote>
<p>  <em>assert是一个宏，当括号里面值为假，程序终止并报错</em></p>
<blockquote>
<p>  <strong><em>这个宏只在debug版本上起作用，在release版本被编译器优化掉</em></strong></p>
</blockquote>
</blockquote>
</li>
</ul>
<h3 id="存储类别"><a href="#存储类别" class="headerlink" title="存储类别"></a>存储类别</h3><ul>
<li><p><strong>作用域</strong><br><em>作用域描述程序中可访问标识符的区域</em></p>
<ol>
<li><p><strong><em>块作用域</em></strong></p>
<blockquote>
<p>  <em>变量x, y只在该块内有效</em></p>
</blockquote>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">func &#123;</span><br><span class="line">    x, y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>


</li>
<li><p><strong><em>文件作用域</em></strong></p>
<blockquote>
<p>  <em>从它的定义处到该定义所在文件的末尾均可见</em></p>
<p>  <em>这样的变量可用于多个函数， 所以文件作用域变量也称为全局变量（global variable）</em></p>
</blockquote>
</li>
</ol>
</li>
<li><p><strong>链接</strong></p>
<p><em>C 变量有 3 种链接属性： 外部链接、 内部链接、或无链接</em><br><em>具有块作用域、 函数作用域或函数原型作用域的变量都是无链接变量</em><br><em>具有文件作用域的变量才可以是外部链接和内部链接</em></p>
<blockquote>
<p>  内部链接的文件作用域		文件作用域</p>
<p>  外部链接的文件作用域  	  全局作用域（程序作用域）</p>
</blockquote>
<ol>
<li><p><strong><em>static修饰符</em></strong></p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> giants = <span class="number">5</span>;					<span class="comment">// 外部链接</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> dodgers = <span class="number">3</span>;			<span class="comment">// 内部链接</span></span><br></pre></td></tr></table></figure></div></li>
</ol>
</li>
<li><p><strong>存储期</strong><br><em>C对象有4种存储期： 静态存储期、 线程存储期、 自动存储期、 动态分配存储期</em></p>
<blockquote>
<p>  1.所有的文件作用域变量都具有静态存储期</p>
<p>  2.具有线程存储期的对象，从声明时到线程结束一直存在。_Thread_local声明一个对象时，每个线程都获得该变量的私有备份</p>
<p>  3.块作用域的变量（局部变量）通常具有自动存储期。使用static在块中声明的局部变量具有静态存储期</p>
</blockquote>
<table>
<thead>
<tr>
<th align="center">存储类别</th>
<th align="center">存储期</th>
<th align="center">作用域</th>
<th align="center">链接</th>
<th align="center">声明方式</th>
</tr>
</thead>
<tbody><tr>
<td align="center">自动</td>
<td align="center">自动</td>
<td align="center">块</td>
<td align="center">无</td>
<td align="center">块内</td>
</tr>
<tr>
<td align="center">寄存器</td>
<td align="center">自动</td>
<td align="center">块</td>
<td align="center">无</td>
<td align="center">块内，register</td>
</tr>
<tr>
<td align="center">静态外部链接</td>
<td align="center">静态</td>
<td align="center">文件</td>
<td align="center">外部</td>
<td align="center">所有函数外</td>
</tr>
<tr>
<td align="center">静态内部链接</td>
<td align="center">静态</td>
<td align="center">文件</td>
<td align="center">内部</td>
<td align="center">所有函数外，static</td>
</tr>
<tr>
<td align="center">静态无链接</td>
<td align="center">静态</td>
<td align="center">块</td>
<td align="center">无</td>
<td align="center">块内，static</td>
</tr>
</tbody></table>
</li>
<li><p><strong>自动变量</strong></p>
<blockquote>
<p>  <em>属于自动存储类别的变量具有自动存储期、 块作用域且无链接。 默认情况下， 声明在块或函数头中的任何变量都属于自动存储类别。为了显式表达可以使用auto关键字</em></p>
</blockquote>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;	<span class="comment">// block</span></span><br><span class="line">    <span class="keyword">auto</span> <span class="type">int</span> x = <span class="number">100</span>;			<span class="comment">// 自动存储类别的变量</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>


</li>
<li><p><strong>寄存器变量</strong></p>
<blockquote>
<p>  <em>寄存器变量和自动变量都一样。 也就是说， 它们都是块作用域、 无链接和自动存储期。 使用存储类别说明符register便可声明寄存器变量</em></p>
</blockquote>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;	<span class="comment">// block</span></span><br><span class="line">    <span class="keyword">register</span> <span class="type">int</span> x = <span class="number">100</span>;		<span class="comment">// 自动存储类别（更快，但是不能对该变量使用地址运算符）</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>


</li>
<li><p><strong>块作用域的静态变量</strong></p>
<blockquote>
<p>  <em>自动变量一样， 具有相同的作用域， 但是程序离开它们所在的函数后， 这些变量不会消失。 也就是说， 这种变量具有块作用域、 无链接， 但是具有静态存储期</em></p>
</blockquote>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;	<span class="comment">// block</span></span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> x = <span class="number">100</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p><em><strong>tips:	不能在函数的形参中使用static</strong></em></p>
</li>
<li><p><strong>外部链接的静态变量</strong></p>
<p><em>外部链接的静态变量具有文件作用域、 外部链接和静态存储期</em></p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> errupt;					<span class="comment">// 外部定义的变量</span></span><br><span class="line"><span class="type">double</span> up[<span class="number">100</span>];				<span class="comment">// 外部定义的数组</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">char</span> coal;			<span class="comment">// coal定义在另一个文件（必须要加extern）</span></span><br><span class="line"></span><br><span class="line">function &#123;</span><br><span class="line">    <span class="keyword">extern</span> <span class="type">int</span> errupt;</span><br><span class="line">    <span class="keyword">extern</span> <span class="type">double</span> up[];			<span class="comment">// 可选的声明（非必须）</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p><em>如果不得已要使用与外部变量名同名的局部变量，可以在局部变量的声明中使用auto存储类别说明符来表达这种意图</em></p>
<ol>
<li><p><strong><em>初始化外部变量</em></strong></p>
<blockquote>
<p>  <em>外部变量和自动变量类似，也可以被显式初始化，未初始化的会被自动初始化为0，并且只能使用常量表达式来初始化</em></p>
</blockquote>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="type">int</span> x = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> y = x * <span class="number">2</span>;					<span class="comment">// not allowed</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span> &#123;<span class="keyword">return</span> <span class="number">0</span>;&#125;</span><br></pre></td></tr></table></figure></div>


</li>
<li><p><strong><em>使用外部变量</em></strong></p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> x;</span><br><span class="line">main &#123;</span><br><span class="line">    <span class="keyword">extern</span> <span class="type">int</span> x;			<span class="comment">// extern可选</span></span><br><span class="line">    <span class="comment">// op x</span></span><br><span class="line">&#125;</span><br><span class="line">func &#123;</span><br><span class="line">    <span class="comment">// op x</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>


</li>
<li><p><strong><em>定义和声明</em></strong></p>
<blockquote>
<p>  <em>外部变量只能初始化一次，且必须在定义该变量时进行</em></p>
</blockquote>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// file_one.c</span></span><br><span class="line"><span class="type">char</span> permis = <span class="string">&#x27;N&#x27;</span>;</span><br><span class="line">...</span><br><span class="line"><span class="comment">// file_two.c</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">char</span> permis = <span class="string">&#x27;Y&#x27;</span>;		<span class="comment">// 错误（变量在file_one.c中已经创建并初始化</span></span><br></pre></td></tr></table></figure></div></li>
</ol>
</li>
<li><p><strong>内部链接的静态变量</strong><br><em>内部链接的静态变量具有静态存储期、文件作用域和内部链接</em></p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> svil = <span class="number">1</span>;		<span class="comment">// 静态变量，内部链接</span></span><br><span class="line">func &#123;</span><br><span class="line">    <span class="keyword">extern</span> <span class="type">int</span> svil = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>


</li>
<li><p><strong>多文件</strong><br><em>在一个文件中进行定义式声明，然后在其它文件中进行引用式声明来实现共享</em></p>
</li>
<li><p><strong>存储类别说明符</strong><br><em><strong>auto register static extern _Thread_local typedef</strong></em></p>
<blockquote>
<p>  _Thread_local例外，可以和static或extern一起使用</p>
</blockquote>
<ol>
<li><p><strong><em>auto</em></strong></p>
<blockquote>
<p>  <em>auto说明符表明变量是自动存储期， 只能用于块作用域的变量声明中。</em></p>
<p>  <em>在块中声明的变量本身就具有自动存储期， 所以使用auto主要是为了明</em></p>
<p>  <em>确表达要使用与外部变量同名的局部变量的意图。</em></p>
</blockquote>
</li>
<li><p><strong><em>register</em></strong></p>
<blockquote>
<p>  <em>register说明符也只用于块作用域的变量， 它把变量归为寄存器存储类</em></p>
<p>  <em>别， 请求最快速度访问该变量。 同时， 还保护了该变量的地址不被获取。</em></p>
</blockquote>
</li>
<li><p><strong><em>static</em></strong><br><em>static 说明符创建的对象具有静态存储期， 载入程序时创建对象， 当程序结束时对象消失。</em></p>
<blockquote>
<p>  <em>static 用于文件作用域声明， 作用域受限于该文件</em></p>
</blockquote>
<blockquote>
<p>  <em>static 用于块作用域声明， 作用域则受限于该块</em></p>
</blockquote>
</li>
<li><p><strong><em>extern</em></strong></p>
<p><em>extern 说明符表明声明的变量定义在别处</em></p>
<blockquote>
<p>  <em>如果包含 extern 的声明具有文件作用域， 则引用的变量必须具有外部链接。</em></p>
</blockquote>
<blockquote>
<p>  <em>如果包含 extern 的声明具有块作用域， 则引用的变量可能具有外部链接或内部链接</em></p>
</blockquote>
</li>
</ol>
</li>
<li><p><strong>存储类别和函数</strong><br><em><strong>外部函数 静态函数 内联函数</strong></em></p>
<ol>
<li><p><strong><em>外部函数（默认）</em></strong></p>
<blockquote>
<p>  <em>外部函数可以被其它文件的函数访问</em></p>
</blockquote>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// file 1</span></span><br><span class="line"><span class="type">double</span> <span class="title function_">quick_pow</span><span class="params">(<span class="type">double</span> x, <span class="type">int</span> n)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// file 2</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">double</span> <span class="title function_">quick_pow</span><span class="params">(<span class="type">double</span> x, <span class="type">int</span> n)</span>;</span><br></pre></td></tr></table></figure></div>


</li>
<li><p><strong><em>静态函数</em></strong></p>
<blockquote>
<p>  <em>使用static修饰，只能在本文件中调用</em></p>
</blockquote>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">double</span> <span class="title function_">quick_pow</span><span class="params">(<span class="type">double</span> x, <span class="type">int</span> n)</span>;</span><br></pre></td></tr></table></figure></div></li>
</ol>
<p><em><strong>tips:    用extern关键字声明定义在其他文件中的函数。 这样做是为了表明当前文件中使用的函数被定义在别处。 除非使用static关键字，<br>否则一般函数声明都默认为extern。</strong></em></p>
</li>
</ul>
<h3 id="分配内存"><a href="#分配内存" class="headerlink" title="分配内存"></a>分配内存</h3><ul>
<li><p><strong>malloc free</strong><br><em><strong>malloc返回值强转为匹配的类型，提高可读性。如果malloc分配内存失败将返回空指针</strong></em></p>
<ol>
<li><p><em><strong>malloc</strong></em></p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span> *ptd;</span><br><span class="line">ptd = (<span class="type">double</span> *)<span class="built_in">malloc</span>(size * <span class="keyword">sizeof</span>(<span class="type">double</span>));		<span class="comment">// 比变长数组更灵活</span></span><br></pre></td></tr></table></figure></div>


</li>
<li><p><em><strong>free</strong></em></p>
<blockquote>
<p>  <em>通常malloc()要和free()配套使用</em></p>
</blockquote>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span> *ptd = (<span class="type">double</span> *)<span class="built_in">malloc</span>(size * <span class="keyword">sizeof</span>(<span class="type">double</span>));</span><br><span class="line"><span class="built_in">free</span>(ptd);</span><br></pre></td></tr></table></figure></div>

<p><strong><em>tips:	free很重要，对于动态开辟的内存不使用时一定要free防止内存泄漏</em></strong></p>
</li>
</ol>
</li>
<li><p><strong>calloc</strong><br><strong><em>与malloc类似，要存储不同的类型，应使用强制类型转换</em></strong></p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">long</span> *ptr;</span><br><span class="line">ptr = (<span class="type">long</span> *)<span class="built_in">calloc</span>(size, <span class="keyword">sizeof</span>(<span class="type">long</span>));</span><br><span class="line"><span class="built_in">free</span>(ptr);</span><br></pre></td></tr></table></figure></div>


</li>
<li><p><strong>VLA和动态内存分配</strong></p>
<blockquote>
<p>  <em>变长数组是自动存储类别，在块结束时变长数组占用的内存会自动释放</em></p>
<p>  <em>被调函数创建一个数组并返回指针， 供主调函数访问， 然后主调函数在末尾调用free()释放之前被调函数分配的内存</em></p>
<p>  <em>free()所用的指针变量可以与 malloc()的指针变量不同， 但是两个指针必须储存相同的地址。 但是， 不能释放同一块内存两次</em></p>
</blockquote>
<p><strong><em>在多维数组方面，使用变长数组更方便</em></strong></p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> m = <span class="number">5</span>, n = <span class="number">6</span>;</span><br><span class="line"><span class="type">int</span> ar2[m][n];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> (*p)[n];</span><br><span class="line">p = (<span class="type">int</span>(*)[n])<span class="built_in">malloc</span>(m*n*<span class="keyword">sizeof</span>(<span class="type">int</span>));				<span class="comment">// m x n</span></span><br></pre></td></tr></table></figure></div>


</li>
<li><p><strong>存储类别和动态内存分配</strong></p>
<ol>
<li><strong><em>静态数据（字符串字面量）占用一个区域</em></strong></li>
<li><strong><em>自动存储类别的变量所占用的内存通常作为栈来处理</em></strong></li>
<li><strong><em>动态开辟的内存要比栈慢，占用内存堆或自由内存</em></strong></li>
</ol>
</li>
</ul>
<h3 id="ANSI-C类型限定符"><a href="#ANSI-C类型限定符" class="headerlink" title="ANSI C类型限定符"></a>ANSI C类型限定符</h3><p><strong>_const volatie restrict <em>Atomic</em></strong></p>
<ul>
<li><p><strong>const</strong></p>
<blockquote>
<p>  <em>const对于全局变量</em></p>
</blockquote>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// file 1.c</span></span><br><span class="line"><span class="type">const</span> <span class="type">double</span> PI = <span class="number">3.14</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> arr[] = &#123;<span class="number">1</span>, <span class="number">2</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// file 2.c</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">const</span> <span class="type">double</span> PI;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">const</span> <span class="type">int</span> arr[];</span><br></pre></td></tr></table></figure></div>

<blockquote>
<p>  <em>使用头文件来解决，在需要使用到的C文件中添加该头文件即可</em></p>
</blockquote>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// head.h</span></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="type">double</span> PI = <span class="number">3.14</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="type">int</span> arr[] = &#123;<span class="number">1</span>, <span class="number">2</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// file.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;head.h&quot;</span>		<span class="comment">// and then you can use PI and arr</span></span></span><br></pre></td></tr></table></figure></div>

<p><strong><em>tips:   如果数据过大不建议使用这种方式</em></strong></p>
</li>
<li><p><strong>volatile</strong><br><strong><em>volatile涉及到编译器优化，主要用于声明一些易变的变量</em></strong></p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">volatile</span> <span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">...				<span class="comment">// cnt++</span></span><br></pre></td></tr></table></figure></div>


</li>
<li><p><strong>restrict</strong><br><strong><em>允许编译器优化某部分代码以更好地支持计算，只能用于指针，表明该指针是访问数据对象的唯一且初始化的方式</em></strong></p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> * <span class="keyword">restrict</span> restar = (<span class="type">int</span> *)<span class="built_in">malloc</span>(size * <span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line"><span class="comment">// restar是访问这块内存区域唯一且初始化的方式</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// exp:</span></span><br><span class="line">restar[<span class="number">1</span>] += <span class="number">2</span>;</span><br><span class="line">restar[<span class="number">1</span>] += <span class="number">3</span>;</span><br><span class="line"><span class="comment">// 被编译器替换为</span></span><br><span class="line">restar[<span class="number">1</span>] += <span class="number">5</span>;</span><br></pre></td></tr></table></figure></div>


</li>
<li><p><strong>_Atomic （C11）</strong></p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> hogs;</span><br><span class="line">hogs = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">_Atomic</span> <span class="type">int</span> hogs;</span><br><span class="line"><span class="type">atomic_store</span>(&amp;hogs, <span class="number">10</span>);		<span class="comment">// stdatomic.h中的宏</span></span><br></pre></td></tr></table></figure></div>

<blockquote>
<p>  <em>hogs存储10是一个原子过程，其它线程不能访问hogs</em></p>
</blockquote>
</li>
<li><p><strong>旧关键字的新位置</strong></p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">ofmouth</span><span class="params">(<span class="type">int</span> * <span class="type">const</span> a1, <span class="type">int</span> * <span class="keyword">restrict</span> a2, <span class="type">int</span> n)</span>; <span class="comment">// 以前的风格</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">ofmouth</span><span class="params">(<span class="type">int</span> a1[<span class="type">const</span>], <span class="type">int</span> a2[<span class="keyword">restrict</span>], <span class="type">int</span> n)</span>; 	<span class="comment">// C99允许</span></span><br><span class="line"><span class="type">double</span> <span class="title function_">stick</span><span class="params">(<span class="type">double</span> ar[<span class="type">static</span> <span class="number">20</span>])</span>;						<span class="comment">// 还要指定数组大小，方便编译器优化代码</span></span><br></pre></td></tr></table></figure></div></li>
</ul>
<h2 id="编码风格"><a href="#编码风格" class="headerlink" title="编码风格"></a>编码风格</h2><h3 id="合理规范头文件"><a href="#合理规范头文件" class="headerlink" title="合理规范头文件"></a>合理规范头文件</h3><ul>
<li><p><strong>原则</strong></p>
<ol>
<li><p><strong><em>头文件适合放接口的声明,不适合放置实践</em></strong></p>
<blockquote>
<p>  头文件是模块（Module）或单元（Unit）的对外接口。头文件中应放置对外部的声明，如对外提供的函数声明、宏定义、类型定义等</p>
</blockquote>
<ul>
<li><em>内部使用的函数（相当于类的私有方法）声明不应放在头文件中</em></li>
<li><em>内部使用的宏、枚举、结构定义不应放入头文件中</em></li>
<li><em>变量定义不应放在头文件中，应放在.c文件中</em></li>
<li><em>变量的声明尽量不要放在头文件中，亦即尽量不要使用全局变量作为接口。变量是模块或单元的内部实现细节，不应通过在头文件中声明的方式直接暴露给外部，应通过函数接口的方式进行对外暴露。即使必须使用全局变量，也只应当在.c中定义全局变量，在.h中仅声明变量为全局的</em></li>
</ul>
</li>
<li><p><strong><em>头文件应当职责单一</em></strong></p>
<blockquote>
<p>  头文件过于复杂，依赖过于复杂是导致编译时间过长的主要原因。很多现有代码中头文件过大，职责过多，再加上循环依赖的问题，可能导致为了在.c中使用一个宏，而包含十几个头文件</p>
</blockquote>
</li>
<li><p><strong><em>头文件应向稳定的方向包含</em></strong></p>
<blockquote>
<p>  头文件的包含关系是一种依赖，一般来说，应当让不稳定的模块依赖稳定的模块，从而当不稳定的模块发生变化时，不会影响（编译）稳定的模块</p>
</blockquote>
<blockquote>
<p>  除了不稳定的模块依赖于稳定的模块外，更好的方式是两个模块共同依赖于接口，这样任何一个模块的内部实现更改都不需要重新编译另外一个模块。在这里，我们假设接口本身是最稳定的</p>
</blockquote>
</li>
</ol>
</li>
<li><p><strong>规则</strong></p>
<ol>
<li><p><strong><em>每一个.c文件应有一个同名.h文件，用于声明需要对外公开的接口</em></strong></p>
<blockquote>
<p>  如果一个.c文件不需要对外公布任何接口，则其就不应当存在，除非它是程序的入口，如main函数所在的文件</p>
</blockquote>
<p>现有某些产品中，习惯一个.c文件对应两个头文件，一个用于存放对外公开的接口，一个用于存放内部需要用到的定义、声明等，以控制.c文件的代码行    数。编者不提倡这种风格。这种风格的根源在于源文件过大，应首先考虑拆分.c文件，使之不至于太大。另外，一旦把私有定义、声明放到独立的头文件  中，就无法从技术上避免别人include之，难以保证这些定义最后真的只是私有的</p>
<p>本规则反过来并不一定成立。有些特别简单的头文件，如命令ID定义头文件，不需要有对应的.c存在</p>
<ul>
<li><p><em>源文件内部的函数调用关系</em></p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">bar</span><span class="params">()</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">foo</span><span class="params">()</span> &#123; bar(); &#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">bar</span><span class="params">()</span> &#123; Do something; &#125;</span><br></pre></td></tr></table></figure></div>

<blockquote>
<p>  这一类的函数声明，应当在.c的头部声明，并声明为static的</p>
</blockquote>
</li>
</ul>
</li>
<li><p><strong>_ 禁止头文件循环依赖_</strong></p>
<blockquote>
<p>  头文件循环依赖，指a.h包含b.h，b.h包含c.h，c.h包含a.h之类导致任何一个头文件修改，都导致所有包含了a.h&#x2F;b.h&#x2F;c.h的代码全部重新编译一遍。而如果是单向依赖，如a.h包含b.h，b.h包含c.h，而c.h不包含任何头文件，则修改a.h不会导致包含了b.h&#x2F;c.h的源代码重新编译</p>
</blockquote>
</li>
<li><p><strong><em>.c&#x2F;.h文件禁止包含用不到的头文件</em></strong></p>
<blockquote>
<p>  很多系统中头文件包含关系复杂，开发人员为了省事起见，可能不会去一一钻研，直接包含一切想到的头文件，甚至有些产品干脆发布了一个god.h，其中包含了所有头文件，然后发布给各个项目组使用，这种只图一时省事的做法，导致整个系统的编译时间进一步恶化，并对后来人的维护造成了巨大的麻烦</p>
</blockquote>
</li>
<li><p><strong><em>头文件应当自包含</em></strong></p>
<blockquote>
<p>  简单的说，自包含就是任意一个头文件均可独立编译。如果一个文件包含某个头文件，还要包含另外一个头文件才能工作的话，就会增加交流障碍，给这个头文件的用户增添不必要的负担</p>
</blockquote>
</li>
<li><p><strong><em>总是编写内部#include保护符（#define 保护）</em></strong></p>
<blockquote>
<p>  多次包含一个头文件可以通过认真的设计来避免。如果不能做到这一点，就需要采取阻止头文件内容被包含多于一次的机制</p>
</blockquote>
<ul>
<li><em>通常的手段是为每个文件配置一个宏，当头文件第一次被包含时就定义这个宏，并在头文件被再次包含时使用它以排除文件内容</em></li>
<li><em>所有头文件都应当使用#define 防止头文件被多重包含，命名格式为FILENAME_H，为了保证唯一性，更好的命名是PROJECTNAME_PATH_FILENAME_H</em></li>
</ul>
<p><strong><em>定义包含保护符时，应该遵守如下规则</em></strong></p>
<ul>
<li><p><em>保护符使用唯一名称</em></p>
</li>
<li><p><em>不要在受保护部分的前后放置代码或者注释</em></p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> VOS_INCLUDE_TIMER_TIMER_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> VOS_INCLUDE_TIMER_TIMER_H</span></span><br><span class="line">...</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure></div>



<p>例外情况：头文件的版权声明部分以及头文件的整体注释部分（如阐述此头文件的开发背景、使用注意事项等）可以放在保护符(#ifndef XX_H)前面</p>
</li>
</ul>
</li>
<li><p><strong><em>禁止在头文件中定义变量</em></strong></p>
<blockquote>
<p>  在头文件中定义变量，将会由于头文件被其他.c文件包含而导致变量重复定义</p>
</blockquote>
</li>
<li><p><strong><em>只能通过包含头文件的方式使用其他.c提供的接口，禁止在.c中通过extern的方式使用外部函数接口、变量</em></strong></p>
<blockquote>
<p>  若a.c使用了b.c定义的foo()函数，则应当在b.h中声明extern int foo(int input)；并在a.c中通过#include 来使用foo。禁止通过在a.c中直接写extern int foo(int input);来使用foo，后面这种写法容易在foo改变时可能导致声明和定义不一致</p>
</blockquote>
</li>
<li><p><strong>_ 禁止在extern “C”中包含头文件_</strong></p>
<blockquote>
<p>  在extern “C”中包含头文件，会导致extern “C”嵌套，Visual Studio对extern “C”嵌套层次有限制，嵌套层次太多会编译错误</p>
</blockquote>
<ul>
<li><p><em>导致被包含头文件的原有意图遭到破坏</em></p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> A_H__</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> A_H__</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> __cplusplus</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">foo</span><span class="params">(<span class="type">int</span>)</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> a(value) foo(value)</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">a</span><span class="params">(<span class="type">int</span>)</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* A_H__ */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> B_H__</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> B_H__</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> __cplusplus</span></span><br><span class="line"><span class="keyword">extern</span> &quot;C&quot; &#123;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;a.h&quot;</span></span></span><br><span class="line">    <span class="type">void</span> <span class="title function_">b</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> __cplusplus</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* B_H__ */</span></span></span><br></pre></td></tr></table></figure></div>

<p>使用C++预处理器展开b.h，将会得到</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> &#123;</span><br><span class="line">    <span class="type">void</span> <span class="title function_">foo</span><span class="params">(<span class="type">int</span>)</span>;</span><br><span class="line">    <span class="type">void</span> <span class="title function_">b</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>按照a.h作者的本意，函数foo是一个C++自由函数，其链接规范为”C++”。但在b.h中，由于#include “a.h”被放到了extern “C” { }的内部，函数foo的链接规范被不正确地更改了</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;xxx.h&quot;</span></span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span></span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></li>
</ul>
</li>
</ol>
</li>
<li><p><strong>建议</strong></p>
<ol>
<li><p><strong><em>一个模块通常包含多个.c文件，建议放在同一个目录下，目录名即为模块名。为方便外部使用者，建议每一个模块提供一个.h，文件名为目录名</em></strong></p>
<blockquote>
<p>  需要注意的是，这个.h并不是简单的包含所有内部的.h，它是为了模块使用者的方便，对外整体提供的模块接口</p>
</blockquote>
</li>
<li><p><strong>_ 如果一个模块包含多个子模块，则建议每一个子模块提供一个对外的.h，文件名为子模块名_</strong></p>
<blockquote>
<p>  降低接口使用者的编写难度</p>
</blockquote>
</li>
<li><p><strong><em>头文件不要使用非习惯用法的扩展名，如.inc</em></strong></p>
</li>
<li><p><strong><em>同一产品统一包含头文件排列方式</em></strong></p>
<blockquote>
<p>  常见的包含头文件排列方式：功能块排序、文件名升序、稳定度排序</p>
</blockquote>
<ul>
<li><p><em>exp:</em></p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;a.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;b.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;c/d.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;c/e.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;f.h&gt;</span></span></span><br></pre></td></tr></table></figure></div>

<blockquote>
<p>  升序方式排列头文件可以避免头文件被重复包含</p>
</blockquote>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;product.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;platform.h&gt;</span></span></span><br></pre></td></tr></table></figure></div>

<blockquote>
<p>  稳定度排序，建议将不稳定的头文件放在前面，如把产品的头文件放在平台的头文件前面</p>
</blockquote>
</li>
</ul>
</li>
</ol>
</li>
</ul>
<h3 id="函数-1"><a href="#函数-1" class="headerlink" title="函数"></a>函数</h3><ul>
<li><p><strong>原则</strong></p>
<ol>
<li><p><strong><em>一个函数仅完成一个功能</em></strong></p>
<blockquote>
<p>  一个函数实现多个功能给开发、使用、维护都带来很大的困难</p>
</blockquote>
</li>
<li><p><strong><em>重复代码应该尽可能提炼成函数</em></strong></p>
<blockquote>
<p>  重复代码提炼成函数可以带来维护成本的降低</p>
</blockquote>
</li>
</ol>
</li>
<li><p><strong>规则</strong></p>
<ol>
<li><p><strong><em>避免函数过长,新增函数不超过50行(非空非注释行)</em></strong></p>
<blockquote>
<p>  本规则仅对新增函数做要求，对已有函数修改时，建议不增加代码行</p>
</blockquote>
</li>
<li><p><strong><em>避免函数的代码块嵌套过深，新增函数的代码块嵌套不超过4层</em></strong></p>
<blockquote>
<p>  本规则仅对新增函数做要求，对已有的代码建议不增加嵌套层次</p>
</blockquote>
</li>
<li><p><strong><em>可重入函数应避免使用共享变量；若需要使用，则应通过互斥手段（关中断、信号量）对其加以保护</em></strong></p>
<blockquote>
<p>  可重入函数是指可能被多个任务并发调用的函数。在多任务操作系统中，函数具有可重入性是多个任务可以共用此函数的必要条件。</p>
<p>  共享变量指的全局变量和static变量</p>
</blockquote>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> g_exam;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> <span class="title function_">example</span><span class="params">( <span class="type">int</span> para )</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> temp;</span><br><span class="line"></span><br><span class="line">    [申请信号量操作]    <span class="comment">// 若申请不到“信号量”，说明另外的进程正处于</span></span><br><span class="line">    g_exam = para;     <span class="comment">//给g_exam赋值并计算其平方过程中（即正在使用此</span></span><br><span class="line">    temp = square_exam( );  <span class="comment">// 信号），本进程必须等待其释放信号后，才可继</span></span><br><span class="line">    [释放信号量操作]    <span class="comment">// 续执行。其它线程必须等待本线程释放信号量后</span></span><br><span class="line">    <span class="comment">// 才能再使用本信号。</span></span><br><span class="line">    <span class="keyword">return</span> temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>


</li>
<li><p><strong><em>对参数的合法性检查，由调用者负责还是由接口函数负责，应在项目组&#x2F;模块内应统一规定。缺省由调用者负责</em></strong></p>
<blockquote>
<p>  对于模块间接口函数的参数的合法性检查这一问题，往往有两个极端现象，即：要么是调用者和被调用者对参数均不作合法性检查，结果就遗漏了合法性检查这一必要的处理过程，造成问题隐患；要么就是调用者和被调用者均对参数进行合法性检查，这种情况虽不会造成问题，但产生了冗余代码，降低了效率</p>
</blockquote>
</li>
<li><p><strong><em>对函数的错误返回码要全面处理</em></strong></p>
<blockquote>
<p>  一个函数（标准库中的函数&#x2F;第三方库函数&#x2F;用户定义的函数）能够提供一些指示错误发生的方法。这可以通过使用错误标记、特殊的返回数据或者其他手段，不管什么时候函数提供了这样的机制，调用程序应该在函数返回时立刻检查错误指示</p>
</blockquote>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">FILE *fp = fopen( <span class="string">&quot;./writeAlarmLastTime.log&quot;</span>,<span class="string">&quot;r&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (fp == <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">char</span> buff[<span class="number">128</span>] = <span class="string">&quot;&quot;</span>;</span><br><span class="line"><span class="built_in">fscanf</span>(fp,“%s”, buff); <span class="comment">/* 读取最新的告警时间；由于文件writeAlarmLastTime.log为空，导致buff为空 */</span></span><br><span class="line">fclose(fp);</span><br><span class="line"><span class="type">long</span> fileTime = getAlarmTime(buff); <span class="comment">/* 解析获取最新的告警时间；getAlarmTime函数未检查buff指针，导致宕机 */</span></span><br></pre></td></tr></table></figure></div>


</li>
<li><p><strong><em>设计高扇入，合理扇出（小于7）的函数</em></strong></p>
<blockquote>
<p>  扇出是指一个函数直接调用（控制）其它函数的数目，而扇入是指有多少上级函数调用它。</p>
<p>  扇出过大，表明函数过分复杂，需要控制和协调过多的下级函数；而扇出过小，例如：总是1，表明函数的调用层次可能过多，这样不利于程序阅读</p>
<p>  和函数结构的分析，并且程序运行时会对系统资源如堆栈空间等造成压力。通常函数比较合理的扇出（调度函数除外）通常是3~5</p>
</blockquote>
<ul>
<li><em>扇出太大，一般是由于缺乏中间层次，可适当增加中间层次的函数。扇出太小，可把下级函数进一步分解多个函数，或合并到上级函数中。当然分解或合并函数时，不能改变要实现的功能，也不能违背函数间的独立性</em></li>
<li><em>扇入越大，表明使用此函数的上级函数越多，这样的函数使用效率高，但不能违背函数间的独立性而单纯地追求高扇入。公共模块中的函数及底层函数应该有较高的扇入</em></li>
</ul>
</li>
<li><p><strong>废弃代码（没有被调用的函数和变量)要及时清除</strong></p>
<blockquote>
<p>  程序中的废弃代码不仅占用额外的空间，而且还常常影响程序的功能与性能，很可能给程序的测试、维护等造成不必要的麻烦</p>
</blockquote>
</li>
</ol>
</li>
<li><p><strong>建议</strong></p>
<ol>
<li><p><strong><em>函数不变参数使用const</em></strong></p>
<blockquote>
<p>  不变的值更易于理解&#x2F;跟踪和分析，把const作为默认选项，在编译时会对其进行检查，使代码更牢固&#x2F;更安全</p>
</blockquote>
</li>
<li><p><strong><em>函数应避免使用全局变量、静态局部变量和I&#x2F;O操作，不可避免的地方应集中使用</em></strong></p>
<blockquote>
<p>  带有内部“存储器”的函数的功能可能是不可预测的，因为它的输出可能取决于内部存储器（如某标记）的状态。这样的函数既不易于理解又不利于测试和维护。在C语言中，函数的static局部变量是函数的内部存储器，有可能使函数的功能不可预测，然而，当某函数的返回值为指针类型时，则必须是static的局部变量的地址作为返回值，若为auto类，则返回为错针</p>
</blockquote>
</li>
<li><p><strong><em>检查函数所有非参数输入的有效性，如数据文件、公共变量等</em></strong></p>
<blockquote>
<p>  函数的输入主要有两种：一种是参数输入；另一种是全局变量、数据文件的输入，即非参数输入。函数在使用输入参数之前，应进行有效性检查</p>
</blockquote>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hr = root_node-&gt;get_first_child(&amp;log_item); <span class="comment">// list.xml 为空，导致读出log_item为空</span></span><br><span class="line">...</span><br><span class="line">hr = log_item-&gt;get_next_sibling(&amp;media_next_node); <span class="comment">// log_item为空，导致宕机</span></span><br></pre></td></tr></table></figure></div>


</li>
<li><p><strong>_ 函数的参数个数不超过5个_</strong></p>
<blockquote>
<p>  函数的参数过多，会使得该函数易于受外部（其他部分的代码）变化的影响，从而影响维护工作。函数的参数过多同时也会增大测试的工作量</p>
</blockquote>
</li>
<li><p><strong><em>除打印类函数外，不要使用可变长参函数</em></strong></p>
<blockquote>
<p>  可变长参函数的处理过程比较复杂容易引入错误，而且性能也比较低，使用过多的可变长参函数将导致函数的维护难度大大增加</p>
</blockquote>
</li>
<li><p><strong>_ 在源文件范围内声明和定义的所有函数，除非外部可见，否则应该增加static关键字_</strong></p>
<blockquote>
<p>  如果一个函数只是在同一文件中的其他地方调用，那么就用static声明。使用static确保只是在声明它的文件中是可见的，并且避免了和其他文件或库中的相同标识符发生混淆的可能性</p>
</blockquote>
<p>建议定义一个STATIC宏，在调试阶段，将STATIC定义为static，版本发布时，改为空，以便于后续的打热补丁等操作</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _DEBUG</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> STATIC static</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> STATIC</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure></div></li>
</ol>
</li>
</ul>
<h3 id="标识符命名与定义"><a href="#标识符命名与定义" class="headerlink" title="标识符命名与定义"></a>标识符命名与定义</h3><h4 id="通用命名规则"><a href="#通用命名规则" class="headerlink" title="通用命名规则"></a>通用命名规则</h4><ul>
<li><p><strong>原则</strong></p>
<ol>
<li><p><strong><em>标识符的命名要清晰、明了，有明确含义，同时使用完整的单词或大家基本可以理解的缩写</em></strong></p>
<blockquote>
<p>  尽可能给出描述性名称，不要节约空间，让别人很快理解你的代码更重要</p>
</blockquote>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> error_number;</span><br><span class="line"><span class="type">int</span> number_of_completed_connection;</span><br></pre></td></tr></table></figure></div>


</li>
<li><p><strong>除了常见的通用缩写以外，不使用单词缩写，不得使用汉语拼音</strong></p>
<blockquote>
<p>  较短的单词可通过去掉“元音”形成缩写，较长的单词可取单词的头几个字母形成缩写，一些单词有大家公认的缩写，常用单词的缩写必须统一。协议中的单词的缩写与协议保持一致。对于某个系统使用的专用缩写应该在注视或者某处做统一说明</p>
</blockquote>
</li>
</ol>
</li>
<li><p><strong>规则</strong></p>
<ol>
<li><p><strong><em>产品&#x2F;项目组内部应保持统一的命名风格</em></strong></p>
<blockquote>
<p>  Unix like和windows like风格均有其拥趸，产品应根据自己的部署平台，选择其中一种，并在产品内部保持一致</p>
</blockquote>
</li>
</ol>
</li>
<li><p><strong>建议</strong></p>
<ol>
<li><p><strong><em>用正确的反义词组命名具有互斥意义的变量或相反动作的函数等</em></strong></p>
</li>
<li><p><strong><em>尽量避免名字中出现数字编号，除非逻辑上的确需要编号</em></strong></p>
</li>
<li><p><strong><em>标识符前不应添加模块、项目、产品、部门的名称作为前缀</em></strong></p>
<blockquote>
<p>  很多已有代码中已经习惯在文件名中增加模块名，这种写法类似匈牙利命名法，导致文件名不可读，并且带来带来如下问题</p>
</blockquote>
</li>
<li><p><strong><em>平台&#x2F;驱动等适配代码的标识符命名风格保持和平台&#x2F;驱动一致</em></strong></p>
</li>
<li><p><strong>_ 重构&#x2F;修改部分代码时，应保持和原有代码的命名风格一致_</strong></p>
<blockquote>
<p>  根据源代码现有的风格继续编写代码，有利于保持总体一致</p>
</blockquote>
</li>
</ol>
</li>
</ul>
<h4 id="文件命名规则"><a href="#文件命名规则" class="headerlink" title="文件命名规则"></a>文件命名规则</h4><ul>
<li><p><strong>建议</strong></p>
<ol>
<li><p><strong><em>文件命名统一采用小写字符</em></strong></p>
<blockquote>
<p>  因为不同系统对文件名大小写处理会不同（如MS的DOS、Windows系统不区分大小写，但是Linux系统则区分），所以代码文件命名建议统一采用全小写字母命名</p>
</blockquote>
</li>
</ol>
</li>
</ul>
<h4 id="变量命名规则"><a href="#变量命名规则" class="headerlink" title="变量命名规则"></a>变量命名规则</h4><ul>
<li><strong>规则</strong><ol>
<li><em><strong>全局变量应增加“g_”前缀</strong></em></li>
<li><em><strong>静态变量应增加“s_”前缀</strong></em></li>
<li><strong><em>禁止使用单字节命名变量，但允许定义i、j、k作为局部循环变量</em></strong></li>
</ol>
</li>
<li><strong>建议</strong><ol>
<li><strong><em>不建议使用匈牙利命名法</em></strong></li>
<li><strong><em>使用名词或者形容词＋名词方式命名变量</em></strong></li>
</ol>
</li>
</ul>
<h4 id="函数命名规则"><a href="#函数命名规则" class="headerlink" title="函数命名规则"></a>函数命名规则</h4><ul>
<li><p><strong>建议</strong></p>
<ol>
<li><p><strong><em>函数命名应以函数要执行的动作命名，一般采用动词或者动词＋名词的结构</em></strong></p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DWORD <span class="title function_">GetCurrentDirectory</span><span class="params">( DWORD BufferLength, LPTSTR Buffer )</span>;</span><br></pre></td></tr></table></figure></div>


</li>
<li><p><strong><em>函数指针除了前缀，其他按照函数的命名规则命名</em></strong></p>
</li>
</ol>
</li>
</ul>
<h4 id="宏的命名规则"><a href="#宏的命名规则" class="headerlink" title="宏的命名规则"></a>宏的命名规则</h4><ul>
<li><p><strong>规则</strong></p>
<ol>
<li><p><strong><em>对于数值或者字符串等等常量的定义，建议采用全大写字母，单词之间加下划线‘_’的方式命名（枚举同样建议使用此方式定义）</em></strong></p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> PI_ROUNDED 3.14</span></span><br></pre></td></tr></table></figure></div>


</li>
<li><p><em><strong>除了头文件或编译开关等特殊标识定义，宏定义不能使用下划线‘_’开头和结尾</strong></em></p>
</li>
</ol>
</li>
</ul>
<h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><ul>
<li><p><strong>原则</strong></p>
<ol>
<li><p><strong><em>一个变量只有一个功能，不能把一个变量用作多种用途</em></strong></p>
<blockquote>
<p>  一个变量只用来表示一个特定功能，不能把一个变量作多种用途，即同一变量取值不同时，其代表的意义也不同</p>
</blockquote>
</li>
<li><p><strong><em>结构功能单一；不要设计面面俱到的数据结构</em></strong></p>
<blockquote>
<p>  相关的一组信息才是构成一个结构体的基础，结构的定义应该可以明确的描述一个对象，而不是一组相关性不强的数据的集合</p>
</blockquote>
</li>
<li><p><strong><em>不用或者少用全局变量</em></strong></p>
<blockquote>
<p>  单个文件内部可以使用static的全局变量，可以将其理解为类的私有成员变量</p>
</blockquote>
<p>全局变量应该是模块的私有数据，不能作用对外的接口使用，使用static类型定义，可以有效防止外部文件的非正常访问，建议定义一个STATIC宏，在调试阶段，将STATIC定义为static，版本发布时，改为空，以便于后续的打补丁等操作</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _DEBUG</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> STATIC static</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> STATIC</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure></div></li>
</ol>
</li>
<li><p><strong>规则</strong></p>
<ol>
<li><p><strong><em>防止局部变量与全局变量同名</em></strong></p>
<blockquote>
<p>  尽管局部变量和全局变量的作用域不同而不会发生语法错误，但容易使人误解</p>
</blockquote>
</li>
<li><p><strong>_ 通讯过程中使用的结构，必须注意字节序_</strong></p>
<blockquote>
<p>  对于这种跨平台的交互，数据成员发送前，都应该进行主机序到网络序的转换；接收时，也必须进行网络序到主机序的转换</p>
</blockquote>
</li>
<li><p><strong><em>严禁使用未经初始化的变量作为右值</em></strong></p>
<blockquote>
<p>  在首次使用前初始化变量，初始化的地方离使用的地方越近越好。可以有效避免未初始化错误</p>
</blockquote>
</li>
</ol>
</li>
<li><p><strong>建议</strong></p>
<ol>
<li><p><strong><em>构造仅有一个模块或函数可以修改、创建，而其余有关模块或函数只访问的全局变量，防止多个不同模块或函数都可以修改、创建同一全局变量的现象</em></strong></p>
<blockquote>
<p>  降低全局变量耦合度</p>
</blockquote>
</li>
<li><p><strong><em>使用面向接口编程思想，通过API访问数据：如果本模块的数据需要对外部模块开放，应提供接口函数来设置、获取，同时注意全局数据的访问互斥</em></strong></p>
<blockquote>
<p>  避免直接暴露内部数据给外部模型使用，是防止模块间耦合最简单有效的方法</p>
</blockquote>
</li>
<li><p><strong><em>在首次使用前初始化变量，初始化的地方离使用的地方越近越好</em></strong></p>
<blockquote>
<p>  未初始化变量是C和C++程序中错误的常见来源。在变量首次使用前确保正确初始化</p>
</blockquote>
</li>
<li><p><strong><em>明确全局变量的初始化顺序，避免跨模块的初始化依赖</em></strong></p>
<blockquote>
<p>  系统启动阶段，使用全局变量前，要考虑到该全局变量在什么时候初始化，使用全局变量和初始化全局变量，两者之间的时序关系，谁先谁后，一定要分析清楚，不然后果往往是低级而又灾难性的</p>
</blockquote>
</li>
<li><p><strong><em>尽量减少没有必要的数据类型默认转换与强制转换</em></strong></p>
<blockquote>
<p>  当进行数据类型强制转换时，其数据的意义、转换后的取值等都有可能发生变化，而这些细节若考虑不周，就很有可能留下隐患</p>
</blockquote>
</li>
</ol>
</li>
</ul>
<h3 id="宏-常量"><a href="#宏-常量" class="headerlink" title="宏 常量"></a>宏 常量</h3><ul>
<li><p><strong>规则</strong></p>
<ol>
<li><p><strong><em>用宏定义表达式时，要使用完备的括号</em></strong></p>
<blockquote>
<p>  因为宏只是简单的代码替换，不会像函数一样先将参数计算后，再传递</p>
</blockquote>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> RECTANGLE_AREA(a, b) a * b</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RECTANGLE_AREA(a, b) (a * b)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RECTANGLE_AREA(a, b) (a) * (b)		<span class="comment">// 有风险</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RECTANGLE_AREA(a, b) ((a) * (b))	<span class="comment">// 安全</span></span></span><br></pre></td></tr></table></figure></div>


</li>
<li><p><strong><em>将宏所定义的多条表达式放在大括号中</em></strong></p>
<blockquote>
<p>  更好的方法是多条语句写成do while(0)的方式</p>
</blockquote>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> FOO(x) do &#123; \</span></span><br><span class="line"><span class="meta">    printf(<span class="string">&quot;arg is %s\n&quot;</span>, x); \</span></span><br><span class="line"><span class="meta">    do_something_useful(x); \</span></span><br><span class="line"><span class="meta">&#125; while(0)</span></span><br></pre></td></tr></table></figure></div>


</li>
<li><p><strong><em>使用宏时，不允许参数发生变化</em></strong></p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> SQUARE(a) ((a) * (a))</span></span><br><span class="line"><span class="type">int</span> a = <span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> b;</span><br><span class="line">b = SQUARE(a++); <span class="comment">// 结果：a = 7，即执行了两次增。</span></span><br></pre></td></tr></table></figure></div>


</li>
<li><p><strong><em>不允许直接使用魔鬼数字</em></strong></p>
<blockquote>
<p>  使用魔鬼数字的弊端：代码难以理解；如果一个有含义的数字多处使用，一旦需要修改这个数值，代价惨重</p>
</blockquote>
<p>对于局部使用的唯一含义的魔鬼数字，可以在代码周围增加说明注释，也可以定义局部const变量，变量命名自注释。</p>
<p>对于广泛使用的数字，必须定义const全局变量&#x2F;宏；同样变量&#x2F;宏命名应是自注释的。</p>
<p>0作为一个特殊的数字，作为一般默认值使用没有歧义时，不用特别定义。</p>
</li>
</ol>
</li>
<li><p><strong>建议</strong></p>
<ol>
<li><p><strong><em>除非必要，应尽可能使用函数代替宏</em></strong></p>
</li>
<li><p><strong><em>常量建议使用const定义代替宏</em></strong></p>
</li>
<li><p><strong><em>宏定义中尽量不使用return、goto、continue、break等改变程序流程的语句</em></strong></p>
<blockquote>
<p>  如果在宏定义中使用这些改变流程的语句，很容易引起资源泄漏问题，使用者很难自己察觉</p>
</blockquote>
</li>
</ol>
</li>
</ul>
<h3 id="代码质量"><a href="#代码质量" class="headerlink" title="代码质量"></a>代码质量</h3><ul>
<li><p><strong>原则</strong></p>
<ol>
<li><p><strong><em>代码质量保证优先原则</em></strong></p>
<ul>
<li><em>正确性，指程序要实现设计要求的功能</em></li>
<li><em>简洁性，指程序易于理解并且易于实现</em></li>
<li><em>可维护性，指程序被修改的能力，包括纠错、改进、新需求或功能规格变化的适应能力</em></li>
<li><em>可靠性，指程序在给定时间间隔和环境条件下，按设计要求成功运行程序的概率</em></li>
<li><em>代码可测试性，指软件发现故障并隔离、定位故障的能力，以及在一定的时间和成本前提下，进行测试设计、测试执行的能力</em></li>
<li><em>代码性能高效，指是尽可能少地占用系统资源，包括内存和执行时间</em></li>
<li><em>可移植性，指为了在原来设计的特定环境之外运行，对系统进行修改的能力</em></li>
<li><em>个人表达方式&#x2F;个人方便性，指个人编程习惯</em></li>
</ul>
</li>
<li><p><strong><em>必须了解编译系统的内存分配方式，特别是编译系统对不同类型的变量的内存分配规则，如局部变量在何处分配、静态变量在何处分配等</em></strong></p>
</li>
<li><p><strong><em>不仅关注接口，同样要关注实现</em></strong></p>
</li>
</ol>
</li>
<li><p><strong>规则</strong></p>
<ol>
<li><p><strong><em>禁止内存操作越界</em></strong></p>
<blockquote>
<p>  内存操作主要是指对数组、指针、内存地址等的操作。内存操作越界是软件系统主要错误之一，后果往往非常严重，所以当我们进行这些操作时一定要仔细小心</p>
</blockquote>
<p>坚持下列措施可以避免内存越界：</p>
<ul>
<li><em>数组的大小要考虑最大情况，避免数组分配空间不够</em></li>
<li><em>避免使用危险函数sprintf&#x2F;vsprintf&#x2F;strcpy&#x2F;strcat&#x2F;gets操作字符串，使用相对安全的函数snprintf&#x2F;strncpy&#x2F;strncat&#x2F;fgets代替</em></li>
<li><em>使用memcpy&#x2F;memset时一定要确保长度不要越界</em></li>
<li><em>字符串考虑最后的’\0’，确保所有字符串是以’\0’结束</em></li>
<li><em>指针加减操作时，考虑指针类型长度</em></li>
<li><em>数组下标进行检查</em></li>
<li><em>使用时sizeof或者strlen计算结构&#x2F;字符串长度，避免手工计算</em></li>
</ul>
</li>
<li><p><strong><em>禁止内存泄漏</em></strong></p>
<blockquote>
<p>  内存和资源（包括定时器&#x2F;文件句柄&#x2F;Socket&#x2F;队列&#x2F;信号量&#x2F;GUI等各种资源）泄漏是常见的错误</p>
</blockquote>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">MsgDBDEV = (PDBDevMsg)GetBuff( <span class="keyword">sizeof</span>( DBDevMsg ), __LINE__);</span><br><span class="line"><span class="keyword">if</span> (MsgDBDEV == <span class="literal">NULL</span>) </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125; </span><br><span class="line">MsgDBAppToLogic = (LPDBSelfMsg)GetBuff( <span class="keyword">sizeof</span>(DBSelfMsg), __LINE__ );</span><br><span class="line"><span class="keyword">if</span> ( MsgDBAppToLogic == <span class="literal">NULL</span> ) </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span>; <span class="comment">//MsgDB_DEV指向的内存丢失</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>坚持下列措施可以避免内存泄漏：</p>
<ul>
<li>异常出口处检查内存、定时器&#x2F;文件句柄&#x2F;Socket&#x2F;队列&#x2F;信号量&#x2F;GUI等资源是否全部释放</li>
<li>删除结构指针时，必须从底层向上层顺序删除</li>
<li>使用指针数组时，确保在释放数组时，数组中的每个元素指针是否已经提前被释放了</li>
<li>避免重复分配内存</li>
<li>小心使用有return、break语句的宏，确保前面资源已经释放</li>
<li>检查队列中每个成员是否释放</li>
</ul>
</li>
<li><p><strong>_ 禁止引用已经释放的内存空间_</strong></p>
<blockquote>
<p>  在实际编程过程中，稍不留心就会出现在一个模块中释放了某个内存块，而另一模块在随后的某个时刻又使用了它。要防止这种情况发生</p>
</blockquote>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>* <span class="title function_">foobar</span> <span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> local_auto = <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">return</span> &amp;local_auto;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>坚持下列措施可以避免引用已经释放的内存空间：</p>
<ul>
<li>内存释放后，把指针置为NULL；使用内存指针前进行非空判断。</li>
<li>耦合度较强的模块互相调用时，一定要仔细考虑其调用关系，防止已经删除的对象被再次使用。</li>
<li>避免操作已发送消息的内存。</li>
<li>自动存储对象的地址不应赋值给其他的在第一个对象已经停止存在后仍然保持的对象（具有更大作用域的对象或者静态对象或者从一个函数返回的对象）</li>
</ul>
</li>
<li><p><strong>_ 编程时，要防止差1错误_</strong></p>
<blockquote>
<p>  此类错误一般是由于把“&lt;&#x3D;”误写成“&lt;”或“&gt;&#x3D;”误写成“&gt;”等造成的，由此引起的后果，很多情况下是很严重的，所以编程时，一定要在这些地方小心。当编完程序后，应对这些操作符进行彻底检查。使用变量时要注意其边界值的情况</p>
</blockquote>
</li>
<li><p><strong><em>所有的if … else if结构应该由else子句结束；switch语句必须有default分支</em></strong></p>
</li>
</ol>
</li>
<li><p><strong>建议</strong></p>
<ol>
<li><p><strong><em>函数中分配的内存，在函数退出之前要释放</em></strong></p>
</li>
<li><p><strong><em>if语句尽量加上else分支，对没有else分支的语句要小心对待</em></strong></p>
</li>
<li><p><strong><em>不要滥用goto语句</em></strong></p>
</li>
<li><p><strong><em>时刻注意表达式是否会上溢、下溢</em></strong></p>
</li>
</ol>
</li>
</ul>
<h3 id="程序效率"><a href="#程序效率" class="headerlink" title="程序效率"></a>程序效率</h3><ul>
<li><p><strong>原则</strong></p>
<ol>
<li><p><strong>在保证软件系统的正确性、简洁、可维护性、可靠性及可测性的前提下，提高代码效率</strong></p>
<blockquote>
<p>  不能一味地追求代码效率，而对软件的正确、简洁、可维护性、可靠性及可测性造成影响 </p>
</blockquote>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">foo</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (异常条件) &#123;</span><br><span class="line">        异常处理;</span><br><span class="line">        <span class="keyword">return</span> ERR_CODE_1;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (异常条件) &#123;</span><br><span class="line">        异常处理;</span><br><span class="line">        <span class="keyword">return</span> ERR_CODE_2;</span><br><span class="line">    &#125;</span><br><span class="line">    正常处理;</span><br><span class="line">    <span class="keyword">return</span> SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">foo</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (满足条件) &#123;</span><br><span class="line">        正常处理;</span><br><span class="line">        <span class="keyword">return</span> SUCCESS;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (概率比较大的异常条件) &#123;</span><br><span class="line">        异常处理;</span><br><span class="line">        <span class="keyword">return</span> ERR_CODE_1;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        异常处理;</span><br><span class="line">        <span class="keyword">return</span> ERR_CODE_2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>除非证明foo函数是性能瓶颈，否则按照本规则，应优先选用前面一种写法</p>
</li>
<li><p><strong><em>通过对数据结构、程序算法的优化来提高效率</em></strong></p>
</li>
</ol>
</li>
<li><p><strong>建议</strong></p>
<ol>
<li><p><strong><em>将不变条件的计算移到循环体外</em></strong></p>
</li>
<li><p><strong><em>对于多维大数组，避免来回跳跃式访问数组成员</em></strong></p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; SIZE_B; i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; SIZE_A; j++)</span><br><span class="line">    &#123;</span><br><span class="line">        sum += x[i][j];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>SIZE_B 数值较大时，这种写法效率更高</p>
</li>
<li><p><strong><em>创建资源库，以减少分配对象的开销</em></strong></p>
<blockquote>
<p>  使用线程池机制，避免线程频繁创建、销毁的系统调用；使用内存池，对于频繁申请、释放的小块内存，一次性申请一个大块的内存，当系统申请内存时，从内存池获取小块内存，使用完毕再释放到内存池中，避免内存申请释放的频繁系统调用</p>
</blockquote>
</li>
<li><p><strong><em>将多次被调用的 “小函数”改为inline函数或者宏实现</em></strong></p>
<blockquote>
<p>  如果编译器支持inline，可以采用inline函数。否则可以采用宏</p>
</blockquote>
</li>
</ol>
</li>
</ul>
<h3 id="注释-1"><a href="#注释-1" class="headerlink" title="注释"></a>注释</h3><ul>
<li><p><strong>原则</strong></p>
<ol>
<li><p><strong><em>优秀的代码可以自我解释，不通过注释即可轻易读懂</em></strong></p>
</li>
<li><p><strong><em>注释的内容要清楚、明了，含义准确，防止注释二义性</em></strong></p>
<blockquote>
<p>  有歧义的注释反而会导致维护者更难看懂代码</p>
</blockquote>
</li>
<li><p><strong><em>在代码的功能、意图层次上进行注释，即注释解释代码难以直接表达的意图，而不是重复描述代码</em></strong></p>
<blockquote>
<p>  注释的目的是解释代码的目的、功能和采用的方法，提供代码以外的信息，帮助读者理解代码，防止没必要的重复注释信息</p>
<p>  注释不是为了名词解释（what），而是说明用途（why）</p>
</blockquote>
</li>
</ol>
</li>
<li><p><strong>规则</strong></p>
<ol>
<li><p><strong><em>修改代码时，维护代码周边的所有注释，以保证注释与代码的一致性。不再有用的注释要删除</em></strong></p>
<blockquote>
<p>  不要将无用的代码留在注释中，随时可以从源代码配置库中找回代码；即使只是想暂时排除代码，也要留个标注，不然可能会忘记处理它</p>
</blockquote>
</li>
<li><p><strong><em>文件头部应进行注释，注释必须列出：版权说明、版本号、生成日期、作者姓名、工号、内容、功能说明、与其它文件的关系、修改日志等，头文件的注释中还应有函数功能简要说明</em></strong></p>
<blockquote>
<p>  通常头文件要对功能和用法作简单说明，源文件包含了更多的实现细节或算法讨论</p>
</blockquote>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*************************************************</span></span><br><span class="line"><span class="comment">Copyright © Huawei Technologies Co., Ltd. 1998-2011. All rights reserved.</span></span><br><span class="line"><span class="comment">File name:      // 文件名</span></span><br><span class="line"><span class="comment">Author:        ID：      Version:       Date: // 作者、工号、版本及完成日期</span></span><br><span class="line"><span class="comment">Description:    // 用于详细说明此程序文件完成的主要功能，与其他模块</span></span><br><span class="line"><span class="comment">                // 或函数的接口，输出值、取值范围、含义及参数间的控</span></span><br><span class="line"><span class="comment">                // 制、顺序、独立或依赖等关系</span></span><br><span class="line"><span class="comment">Others:         // 其它内容的说明</span></span><br><span class="line"><span class="comment">History:        // 修改历史记录列表，每条修改记录应包括修改日期、修改</span></span><br><span class="line"><span class="comment">                // 者及修改内容简述 </span></span><br><span class="line"><span class="comment">    1. Date:</span></span><br><span class="line"><span class="comment">    Author:               ID:</span></span><br><span class="line"><span class="comment">    Modification:</span></span><br><span class="line"><span class="comment">    2. ...</span></span><br><span class="line"><span class="comment">*************************************************/</span></span><br></pre></td></tr></table></figure></div>


</li>
<li><p><strong>_ 函数声明处注释描述函数功能、性能及用法，包括输入和输出参数、函数返回值、可重入的要求等；定义处详细描述函数功能和实现要点，如实现的简要步骤、实现的理由、设计约束_</strong></p>
<blockquote>
<p>  重要的、复杂的函数，提供外部使用的接口函数应编写详细的注释</p>
</blockquote>
</li>
<li><p><strong><em>全局变量要有较详细的注释，包括对其功能、取值范围以及存取时注意事项等的说明</em></strong></p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* The ErrorCode when SCCP translate */</span></span><br><span class="line"><span class="comment">/* Global Title failure, as follows */</span>      <span class="comment">/* 变量作用、含义*/</span></span><br><span class="line"><span class="comment">/* 0 －SUCCESS   1 －GT Table error */</span></span><br><span class="line"><span class="comment">/* 2 －GT error  Others －no use  */</span>       <span class="comment">/* 变量取值范围*/</span></span><br><span class="line"><span class="comment">/* only  function  SCCPTranslate() in */</span></span><br><span class="line"><span class="comment">/* this modual can modify it,  and  other */</span></span><br><span class="line"><span class="comment">/* module can visit it through call */</span></span><br><span class="line"><span class="comment">/* the  function GetGTTransErrorCode() */</span>    <span class="comment">/* 使用方法*/</span></span><br><span class="line">BYTE g_GTTranErrorCode;</span><br></pre></td></tr></table></figure></div>


</li>
<li><p><strong><em>注释应放在其代码上方相邻位置或右方，不可放在下面。如放于上方则需与其上面的代码用空行隔开，且与下方代码缩进相同</em></strong></p>
<p>exp:</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* active statistic task number */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_ACT_TASK_NUMBER 1000</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_ACT_TASK_NUMBER 1000 <span class="comment">/* active statistic task number */</span></span></span><br></pre></td></tr></table></figure></div>

<p>按如下形式说明枚举&#x2F;数据&#x2F;联合结构</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* sccp interface with sccp user primitive message name */</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">SCCP_USER_PRIMITIVE</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    N_UNITDATA_IND, <span class="comment">/* sccp notify sccp user unit data come */</span></span><br><span class="line">    N_NOTICE_IND, <span class="comment">/* sccp notify user the No.7 network can not transmission this message */</span></span><br><span class="line">    N_UNITDATA_REQ, <span class="comment">/* sccp user&#x27;s unit data transmission request*/</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>


</li>
<li><p><strong><em>对于switch语句下的case语句，如果因为特殊情况需要处理完一个case后进入下一个case处理，必须在该case语句处理完、下一个case语句前加上明确的注释</em></strong></p>
<blockquote>
<p>  这样比较清楚程序编写者的意图，有效防止无故遗漏break语句</p>
</blockquote>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> CMD_FWD:</span><br><span class="line">    ProcessFwd();</span><br><span class="line">    <span class="comment">/* now jump into case CMD_A */</span></span><br><span class="line"><span class="keyword">case</span> CMD_A:</span><br><span class="line">    ProcessA();</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line"><span class="comment">// 对于中间无处理的连续case，已能较清晰说明意图，不强制注释</span></span><br></pre></td></tr></table></figure></div>


</li>
<li><p><strong><em>避免在注释中使用缩写，除非是业界通用或子系统内标准化的缩写</em></strong></p>
</li>
<li><p><strong><em>同一产品或项目组统一注释风格</em></strong></p>
</li>
</ol>
</li>
<li><p><strong>建议</strong></p>
<ol>
<li><p><strong><em>避免在一行代码或表达式的中间插入注释</em></strong></p>
<blockquote>
<p>  除非必要，不应在代码或表达中间插入注释，否则容易使代码可理解性变差</p>
</blockquote>
</li>
<li><p><strong><em>注释应考虑程序易读及外观排版的因素，使用的语言若是中、英兼有的，建议多使用中文，除非能用非常流利准确的英文表达</em></strong></p>
<blockquote>
<p>  注释语言不统一，影响程序易读性和外观排版，出于对维护人员的考虑，建议使用中文</p>
</blockquote>
</li>
<li><p><strong><em>文件头、函数头、全局常量变量、类型定义的注释格式采用工具可识别的格式</em></strong></p>
<blockquote>
<p>  采用工具可识别的注释格式，例如doxygen格式，方便工具导出注释形成帮助文档</p>
</blockquote>
<ul>
<li><p><em>文件头</em></p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment">*  @file           （本文件的文件名eg：mib.h）</span></span><br><span class="line"><span class="comment">*  @brief          （本文件实现的功能的简述）</span></span><br><span class="line"><span class="comment">*  @version 1.1    （版本声明）</span></span><br><span class="line"><span class="comment">*  @author        （作者，eg：张三）</span></span><br><span class="line"><span class="comment">*  @date          （文件创建日期，eg：2010年12月15日）</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure></div>


</li>
<li><p><em>函数头</em></p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*@ Description:向接收方发送SET请求</span></span><br><span class="line"><span class="comment">* @param req - 指向整个SNMP SET 请求报文.</span></span><br><span class="line"><span class="comment">* @param ind - 需要处理的subrequest 索引.</span></span><br><span class="line"><span class="comment">* @return 成功：SNMP_ERROR_SUCCESS，失败：SNMP_ERROR_COMITFAIL</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line">Int <span class="title function_">commit_set_request</span><span class="params">(Request *req, <span class="type">int</span> ind)</span>;</span><br></pre></td></tr></table></figure></div>


</li>
<li><p><em>全局变量</em></p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**  模拟的Agent MIB */</span></span><br><span class="line">agentpp_simulation_mib * g_agtSimMib;</span><br></pre></td></tr></table></figure></div></li>
</ul>
</li>
</ol>
</li>
</ul>
<h3 id="排版与格式"><a href="#排版与格式" class="headerlink" title="排版与格式"></a>排版与格式</h3><ul>
<li><p><strong>文件内容的一般规则</strong></p>
<ol>
<li><p><strong><em>各个源文件必须有一个头文件说明，头文件各部分内容</em></strong></p>
<ul>
<li><em>Header File Header Section</em></li>
<li><em>Multi-Include-Prevent Section</em></li>
<li><em>Debug Switch Section</em></li>
<li><em>Include File Section</em></li>
<li><em>Macro Define Section</em></li>
<li><em>Structure Define Section</em></li>
<li><em>Prototype Declare Section</em></li>
</ul>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/************************************************************************</span></span><br><span class="line"><span class="comment">* 文件名 版权信息 模块名 创建日期</span></span><br><span class="line"><span class="comment">* 作者/岗位</span></span><br><span class="line"><span class="comment">* 文件描述</span></span><br><span class="line"><span class="comment">*---------------------------Revision History-----------------------------</span></span><br><span class="line"><span class="comment">* 文件版本及更改信息</span></span><br><span class="line"><span class="comment">************************************************************************/</span></span><br><span class="line"><span class="comment">/* Multi-Include-Prevent Section */</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __FN_FILENAME_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __FN_FILENAME_H</span></span><br><span class="line"><span class="comment">/* Debug switch Section */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> D_DISP_BASE</span></span><br><span class="line"><span class="comment">/* Include File Section */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;IncFile.h&quot;</span></span></span><br><span class="line"><span class="comment">/* Macro Define Section */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_TIMER_OUT (4)</span></span><br><span class="line"><span class="comment">/* Struct Define Section */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">CM_RadiationDose</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> ucCtgID;</span><br><span class="line">    <span class="type">char</span> cPatId_a[MAX_PATI_LEN];</span><br><span class="line">&#125;CM_RadiationDose_st, *CM_RadiationDose_pst;</span><br><span class="line"><span class="comment">/* Prototype Declare Section */</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> <span class="title function_">MD_guiGetScanTimes</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure></div>


</li>
<li><p><strong><em>源文件内容</em></strong></p>
<ul>
<li><em>Source File Header Section</em></li>
<li><em>Debug Switch Section</em></li>
<li><em>Include File Section</em></li>
<li><em>Macro Define Section</em></li>
<li><em>Structure Define Section</em></li>
<li><em>Prototype Declare Section</em></li>
<li><em>Global Variable Declare Section</em></li>
<li><em>File Static Variable Define Section</em></li>
<li><em>Function Define Section</em></li>
</ul>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/************************************************************************</span></span><br><span class="line"><span class="comment">* 文件名 版权信息 模块名 创建日期</span></span><br><span class="line"><span class="comment">* 作者/岗位</span></span><br><span class="line"><span class="comment">* 文件描述</span></span><br><span class="line"><span class="comment">*---------------------------Revision History-----------------------------</span></span><br><span class="line"><span class="comment">* 文件版本及更改信息</span></span><br><span class="line"><span class="comment">************************************************************************/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Debug switch Section */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> D_DISP_BASE</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Include File Section */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;IncFile.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Macro Define Section */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_TIMER_OUT (4)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Structure Define Section */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">CM_RadiationDose</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> ucCtgID;</span><br><span class="line">    <span class="type">char</span> cPatId_a[MAX_PATI_LEN];</span><br><span class="line">&#125;CM_RadiationDose_st, *pCM_RadiationDose_st;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Prototype Declare Section */</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> <span class="title function_">MD_guiGetScanTimes</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Global Variable Declare Section */</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">unsigned</span> <span class="type">int</span> MD_guiHoldBreathStatus;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* File Static Variable Define Section */</span></span><br><span class="line"><span class="type">static</span> <span class="type">unsigned</span> <span class="type">int</span> nuiNaviSysStatus;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Function Define Section */</span></span><br></pre></td></tr></table></figure></div></li>
</ol>
</li>
<li><p><strong>规则</strong></p>
<ol>
<li><p><strong><em>程序块采用缩进风格编写，每级缩进为4个空格</em></strong></p>
</li>
<li><p><strong><em>相对独立的程序块之间、变量说明之后必须加空行</em></strong></p>
</li>
<li><p><strong><em>一条语句不能过长，如不能拆分需要分行写。一行到底多少字符换行比较合适，产品可以自行确定</em></strong></p>
<p>换行时有如下建议：</p>
<ul>
<li><em>换行时要增加一级缩进，使代码可读性更好</em></li>
<li><em>低优先级操作符处划分新行；换行时操作符应该也放下来，放在新行首</em></li>
<li><em>换行时建议一个完整的语句放在一行，不要根据字符数断行</em></li>
</ul>
</li>
<li><p><strong><em>多个短语句（包括赋值语句）不允许写在同一行内，即一行只写一条语句</em></strong></p>
</li>
<li><p><strong><em>if、for、do、while、case、switch、default等语句独占一行</em></strong></p>
</li>
<li><p><strong><em>在两个以上的关键字、变量、常量进行对等操作时，它们之间的操作符之前、之后或者前后要加空格；进行非对等操作时，如果是关系密切的立即操作符（如－&gt;），后不应加空格</em></strong></p>
</li>
</ol>
</li>
<li><p><strong>建议</strong></p>
<ol>
<li><p><strong><em>注释符（包括‘&#x2F;<em>’‘&#x2F;&#x2F;’‘</em>&#x2F;’）与注释内容之间要用一个空格进行分隔</em></strong></p>
</li>
<li><p><strong><em>源程序中关系较为紧密的代码应尽可能相邻</em></strong></p>
</li>
</ol>
</li>
</ul>
<h3 id="表达式-1"><a href="#表达式-1" class="headerlink" title="表达式"></a>表达式</h3><ul>
<li><p><strong>规则</strong></p>
<ol>
<li><p><strong><em>表达式的值在标准所允许的任何运算次序下都应该是相同的</em></strong></p>
<blockquote>
<p>  将复合表达式分开写成若干个简单表达式，明确表达式的运算次序，就可以有效消除非预期副作用</p>
</blockquote>
</li>
</ol>
</li>
<li><p><strong>建议</strong></p>
<ol>
<li><p><strong><em>函数调用不要作为另一个函数的参数使用，否则对于代码的调试、阅读都不利</em></strong></p>
</li>
<li><p><strong><em>赋值语句不要写在if等语句中，或者作为函数的参数使用</em></strong></p>
</li>
<li><p><strong><em>用括号明确表达式的操作顺序，避免过分依赖默认优先级</em></strong></p>
<blockquote>
<p>  使用括号强调所使用的操作符，防止因默认的优先级与设计思想不符而导致程序出错；同时使得代码更为清晰可读，然而过多的括号会分散代码使其降低了可读性</p>
</blockquote>
</li>
<li><p><strong><em>赋值操作符不能使用在产生布尔值的表达式上</em></strong></p>
</li>
</ol>
</li>
</ul>
<h3 id="代码编辑-编译"><a href="#代码编辑-编译" class="headerlink" title="代码编辑 编译"></a>代码编辑 编译</h3><ul>
<li><p><strong>规则</strong></p>
<ol>
<li><p><strong><em>使用编译器的最高告警级别，理解所有的告警，通过修改代码而不是降低告警级别来消除所有告警</em></strong></p>
<blockquote>
<p>  编译器是你的朋友，如果它发出某个告警，这经常说明你的代码中存在潜在的问题</p>
</blockquote>
</li>
<li><p><strong><em>在产品软件（项目组）中，要统一编译开关、静态检查选项以及相应告警清除策略</em></strong></p>
<blockquote>
<p>  如果必须禁用某个告警，应尽可能单独局部禁用，并且编写一个清晰的注释，说明为什么屏蔽</p>
<p>  某些语句经编译&#x2F;静态检查产生告警，但如果你认为它是正确的，那么应通过某种手段去掉告警信息</p>
</blockquote>
</li>
<li><p><strong><em>本地构建工具（如PC-Lint）的配置应该和持续集成的一致</em></strong></p>
<blockquote>
<p>  两者一致，避免经过本地构建的代码在持续集成上构建失败</p>
</blockquote>
</li>
<li><p><strong><em>使用版本控制（配置管理）系统，及时签入通过本地构建的代码，确保签入的代码不会影响构建成功</em></strong></p>
<blockquote>
<p>  及时签入代码降低集成难度</p>
</blockquote>
</li>
</ol>
</li>
<li><p><strong>建议</strong></p>
<ol>
<li><strong><em>要小心地使用编辑器提供的块拷贝功能编程</em></strong></li>
</ol>
</li>
</ul>
<h3 id="可测性"><a href="#可测性" class="headerlink" title="可测性"></a>可测性</h3><ul>
<li><p><strong>原则</strong></p>
<ol>
<li><p><strong><em>模块划分清晰，接口明确，耦合性小，有明确输入和输出，否则单元测试实施困难</em></strong></p>
<p>单元测试实施依赖于：</p>
<ul>
<li><em>模块间的接口定义清楚、完整、稳定</em></li>
<li><em>模块功能的有明确的验收条件（包括：预置条件、输入和预期结果）</em></li>
<li><em>模块内部的关键状态和关键数据可以查询，可以修改</em></li>
<li><em>模块原子功能的入口唯一</em></li>
<li><em>模块原子功能的出口唯一</em></li>
<li><em>依赖集中处理：和模块相关的全局变量尽量的少，或者采用某种封装形式</em></li>
</ul>
</li>
</ol>
</li>
<li><p><strong>规则</strong></p>
<ol>
<li><p><strong><em>在同一项目组或产品组内，要有一套统一的为集成测试与系统联调准备的调测开关及相应打印函数，并且要有详细的说明</em></strong></p>
<blockquote>
<p>  本规则是针对项目组或产品组的。代码至始至终只有一份代码，不存在开发版本和测试版本的说法。测试与最终发行的版本是通过编译开关的不同来实现的。并且编译开关要规范统一。统一使用编译开关来实现测试版本与发行版本的区别，一般不允许再定义其它新的编译开关</p>
</blockquote>
</li>
<li><p><strong><em>在同一项目组或产品组内，调测打印的日志要有统一的规定</em></strong></p>
<p>统一的调测日志记录便于集成测试，具体包括：</p>
<ul>
<li><em>统一的日志分类以及日志级别</em></li>
<li><em>通过命令行、网管等方式可以配置和改变日志输出的内容和格式</em></li>
<li><em>在关键分支要记录日志，日志建议不要记录在原子函数中，否则难以定位</em></li>
<li><em>调试日志记录的内容需要包括文件名&#x2F;模块名、代码行号、函数名、被调用函数名、错误码、错误发生的环境等</em></li>
</ul>
</li>
<li><p><strong><em>使用断言记录内部假设</em></strong></p>
<blockquote>
<p>  断言是对某种内部模块的假设条件进行检查，如果假设不成立，说明存在编程、设计错误。断言可以对在系统中隐藏很深，用其它手段极难发现的问题进行定位，从而缩短软件问题定位时间，提高系统的可测性</p>
</blockquote>
</li>
<li><p><strong><em>不能用断言来检查运行时错误</em></strong></p>
<blockquote>
<p>  断言是用来处理内部编程或设计是否符合假设；不能处理对于可能会发生的且必须处理的情况要写防错程序，而不是断言。如某模块收到其它模块或链路上的消息后，要对消息的合理性进行检查，此过程为正常的错误检查，不能用断言来实现</p>
</blockquote>
</li>
</ol>
</li>
<li><p><strong>建议</strong></p>
<ol>
<li><strong><em>为单元测试和系统故障注入测试准备好方法和通道</em></strong></li>
</ol>
</li>
</ul>
<h3 id="安全性"><a href="#安全性" class="headerlink" title="安全性"></a>安全性</h3><ul>
<li><p><strong>原则</strong></p>
<ol>
<li><p><strong><em>对用户输入进行检查</em></strong></p>
<p>不能假定用户输入都是合法的，因为难以保证不存在恶意用户，即使是合法用户也可能由于误用误操作而产生非法输入。用户输入通常需要经过检验以保证安全，特别是以下场景：</p>
<ul>
<li><em>用户输入作为循环条件</em></li>
<li><em>用户输入作为数组下标</em></li>
<li><em>用户输入作为内存分配的尺寸参数</em></li>
<li><em>用户输入作为格式化字符串</em></li>
<li><em>用户输入作为业务数据（如作为命令执行参数、拼装sql语句、以特定格式持久化）</em></li>
</ul>
<p>这些情况下如果不对用户数据做合法性验证，很可能导致DOS、内存越界、格式化字符串漏洞、命令注入、SQL注入、缓冲区溢出、数据破坏等问题</p>
<p>可采取以下措施对用户输入检查：</p>
<ul>
<li><em>用户输入作为数值的，做数值范围检查</em></li>
<li><em>用户输入是字符串的，检查字符串长度</em></li>
<li><em>用户输入作为格式化字符串的，检查关键字“%”</em></li>
<li><em>用户输入作为业务数据，对关键字进行检查、转义</em></li>
</ul>
</li>
</ol>
</li>
</ul>
<h4 id="字符串操作安全"><a href="#字符串操作安全" class="headerlink" title="字符串操作安全"></a>字符串操作安全</h4><ul>
<li><p><strong>规则</strong></p>
<ol>
<li><p><strong><em>确保所有字符串是以NULL结束</em></strong></p>
<blockquote>
<p>  C语言中’\0’作为字符串的结束符，即NULL结束符。标准字符串处理函数（如strcpy()、strlen()）依赖NULL结束符来确定字符串的长度。</p>
<p>  没有正确使用NULL结束字符串会导致缓冲区溢出和其它未定义的行为。</p>
<p>  为了避免缓冲区溢出，常常会用相对安全的限制字符数量的字符串操作函数代替一些危险函数</p>
</blockquote>
<ul>
<li>用strncpy()代替strcpy()</li>
<li>用strncat()代替strcat()</li>
<li>用snprintf()代替sprintf()</li>
<li>用fgets()代替gets()</li>
</ul>
<p>这些函数会截断超出指定限制的字符串，但是要注意它们并不能保证目标字符串总是以NULL结尾。如果源字符串的前n个字符中不存在NULL字符，目标字符串就不是以NULL结尾</p>
</li>
<li><p><strong><em>不要将边界不明确的字符串写到固定长度的数组中</em></strong></p>
<blockquote>
<p>  边界不明确的字符串（如来自gets()、getenv()、scanf()的字符串），长度可能大于目标数组长度，直接拷贝到固定长度的数组中容易导致缓冲区溢出</p>
</blockquote>
<p>exp:</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> buff[<span class="number">256</span>];</span><br><span class="line"><span class="type">char</span> *editor = getenv(<span class="string">&quot;EDITOR&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (editor != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">strcpy</span>(buff, editor);</span><br><span class="line">&#125;									<span class="comment">// 不安全</span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span> *buff;</span><br><span class="line"><span class="type">char</span> *editor = getenv(<span class="string">&quot;EDITOR&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (editor != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">    buff = <span class="built_in">malloc</span>(<span class="built_in">strlen</span>(editor) + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (buff != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">strcpy</span>(buff, editor);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;									<span class="comment">// 正确写法</span></span><br></pre></td></tr></table></figure></div></li>
</ol>
</li>
</ul>
<h4 id="整数安全"><a href="#整数安全" class="headerlink" title="整数安全"></a>整数安全</h4><ul>
<li><p><strong>规则</strong></p>
<ol>
<li><p><strong><em>避免整数溢出</em></strong></p>
<blockquote>
<p>  当一个整数被增加超过其最大值时会发生整数上溢，被减小小于其最小值时会发生整数下溢。带符号和无符号的数都有可能发生溢出</p>
</blockquote>
</li>
<li><p><strong><em>避免符号错误</em></strong></p>
<blockquote>
<p>  有时从带符号整型转换到无符号整型会发生符号错误，符号错误并不丢失数据，但数据失去了原来的含义</p>
</blockquote>
</li>
<li><p><strong><em>避免截断错误</em></strong></p>
<blockquote>
<p>  将一个较大整型转换为较小整型，并且该数的原值超出较小类型的表示范围，就会发生截断错误，原值的低位被保留而高位被丢弃。截断错误会引起数据丢失</p>
</blockquote>
</li>
</ol>
</li>
</ul>
<h4 id="格式化输出安全"><a href="#格式化输出安全" class="headerlink" title="格式化输出安全"></a>格式化输出安全</h4><ul>
<li><p><strong>规则</strong></p>
<ol>
<li><p><strong><em>确保格式字符和参数匹配</em></strong></p>
<blockquote>
<p>  使用格式化字符串应该小心，确保格式字符和参数之间的匹配，保留数量和数据类型。格式字符和参数之间的不匹配会导致未定义的行为。大多数情况下，不正确的格式化字符串会导致程序异常终止</p>
</blockquote>
<p>exp:</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> *error_msg = <span class="string">&quot;Resource not available to user.&quot;</span>;</span><br><span class="line"><span class="type">int</span> error_type = <span class="number">3</span>;</span><br><span class="line"><span class="comment">/* 格式字符和参数的类型不匹配*/</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Error (type %s): %d\n&quot;</span>, error_type, error_msg);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 格式字符和参数的数量不匹配*/</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Error: %s\n&quot;</span>);</span><br></pre></td></tr></table></figure></div>


</li>
<li><p><strong><em>避免将用户输入作为格式化字符串的一部分或者全部</em></strong></p>
<blockquote>
<p>  调用格式化I&#x2F;O函数时，不要直接或者间接将用户输入作为格式化字符串的一部分或者全部。攻击者对一个格式化字符串拥有部分或完全控制，存在以下风险：进程崩溃、查看栈的内容、改写内存、甚至执行任意代码</p>
</blockquote>
</li>
</ol>
</li>
</ul>
<h4 id="文件IO安全"><a href="#文件IO安全" class="headerlink" title="文件IO安全"></a>文件IO安全</h4><ul>
<li><p><strong>规则</strong></p>
<ol>
<li><p><strong><em>避免使用strlen()计算二进制数据的长度</em></strong></p>
<blockquote>
<p>  strlen()函数用于计算字符串的长度，它返回字符串中第一个NULL结束符之前的字符的数量。因此用strlen()处理文件I&#x2F;O函数读取的内容时要小心，因为这些内容可能是二进制也可能是文本</p>
</blockquote>
<p>在不能确定从文件读取到的数据的类型时，不要使用依赖NULL结束符的字符串操作函数</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> buf[BUF_SIZE + <span class="number">1</span>];</span><br><span class="line"><span class="type">char</span> *p;</span><br><span class="line"><span class="keyword">if</span> (fgets(buf, <span class="keyword">sizeof</span>(buf), fp)) </span><br><span class="line">&#123;</span><br><span class="line">    p = <span class="built_in">strchr</span>(buf, <span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">    <span class="keyword">if</span> (p) </span><br><span class="line">    &#123;</span><br><span class="line">        *p = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* handle error condition */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>


</li>
<li><p><strong><em>使用int类型变量来接受字符I&#x2F;O函数的返回值</em></strong></p>
<blockquote>
<p>  字符I&#x2F;O函数fgetc()、getc()和getchar()都从一个流读取一个字符，并把它以int值的形式返回。如果这个流到达了文件尾或者发生读取错误，函数返回EOF。fputc()、putc()、putchar()和ungetc()也返回一个字符或EOF</p>
</blockquote>
</li>
</ol>
</li>
<li><p><strong>规则</strong></p>
<ol>
<li><p><strong><em>防止命令注入</em></strong></p>
<blockquote>
<p>  C99函数system()通过调用一个系统定义的命令解析器（如UNIX的shell，Windows的CMD.exe）来执行一个指定的程序&#x2F;命令。类似的还有POSIX的函数popen()</p>
</blockquote>
<p>如果system()的参数由用户的输入组成，恶意用户可以通过构造恶意输入，改变system()调用的行为</p>
<p>使用POSIX函数execve()代替system()</p>
<p>Windows环境可能对execve()的支持不是很完善，建议使用Win32 API CreateProcess()代替system()</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">secuExec</span> <span class="params">(<span class="type">char</span> *input)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">pid_t</span> pid;</span><br><span class="line">    <span class="type">char</span> *<span class="type">const</span> args[] = &#123;<span class="string">&quot;&quot;</span>, input, <span class="literal">NULL</span>&#125;;</span><br><span class="line">    <span class="type">char</span> *<span class="type">const</span> envs[] = &#123;<span class="literal">NULL</span>&#125;;</span><br><span class="line">    pid = fork();</span><br><span class="line">    <span class="keyword">if</span> (pid == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;fork error&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (pid == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (execve(<span class="string">&quot;/usr/bin/any_exe&quot;</span>, args, envs) == <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">puts</span>(<span class="string">&quot;Error executing any_exe&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></li>
</ol>
</li>
</ul>
<h3 id="单元测试"><a href="#单元测试" class="headerlink" title="单元测试"></a>单元测试</h3><ul>
<li><p><strong>规则</strong></p>
<ol>
<li><strong><em>在编写代码的同时，或者编写代码前，编写单元测试用例验证软件设计&#x2F;编码的正确</em></strong></li>
</ol>
</li>
<li><p><strong>建议</strong></p>
<ol>
<li><p><strong><em>单元测试关注单元的行为而不是实现，避免针对函数的测试</em></strong></p>
<blockquote>
<p>  应该将被测单元看做一个被测的整体，根据实际资源、进度和质量风险，权衡代码覆盖、打桩工作量、补充测试用例的难度、被测对象的稳定程度等，一般情况下建议关注模块&#x2F;组件的测试，尽量避免针对函数的测试。尽管有时候单个用例只能专注于对某个具体函数的测试，但我们关注的应该是函数的行为而不是其具体实现细节</p>
</blockquote>
</li>
</ol>
</li>
</ul>
<h3 id="可移植性"><a href="#可移植性" class="headerlink" title="可移植性"></a>可移植性</h3><ul>
<li><p><strong>规则</strong></p>
<ol>
<li><strong><em>不能定义、重定义或取消定义标准库&#x2F;平台中保留的标识符、宏和函数</em></strong></li>
</ol>
</li>
<li><p><strong>建议</strong></p>
<ol>
<li><p><strong><em>不使用与硬件或操作系统关系很大的语句，而使用建议的标准语句，以提高软件的可移植性和可重用性</em></strong></p>
<blockquote>
<p>  使用标准的数据类型，有利于程序的移植</p>
</blockquote>
</li>
<li><p><strong><em>除非为了满足特殊需求，避免使用嵌入式汇编</em></strong></p>
<blockquote>
<p>  程序中嵌入式汇编，一般都对可移植性有较大的影响</p>
</blockquote>
</li>
</ol>
</li>
</ul>
<h2 id="杂项"><a href="#杂项" class="headerlink" title="杂项"></a>杂项</h2><h3 id="void使用"><a href="#void使用" class="headerlink" title="void使用"></a>void使用</h3><p><strong><em>void定义变量没有任何意义的，void真正的作用是对函数返回的限定以及对函数参数的限定</em></strong></p>
<ul>
<li><p><strong>void *</strong></p>
<blockquote>
<p>  <em>任何类型的指针都可以直接赋值给他，无需进行强制类型转换</em></p>
</blockquote>
</li>
<li><p><strong>void修饰函数返回值</strong></p>
<p><strong><em>如果函数无返回值，应该声明为void类型</em></strong></p>
</li>
<li><p><strong>void修饰函数参数</strong></p>
<p><strong><em>如果函数无参数，应该声明其参数为void</em></strong></p>
</li>
</ul>
<blockquote>
<p>  <em>不要对void *类型的指针进行非法操作</em></p>
  <div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> * pvoid;</span><br><span class="line">pvoid++;</span><br><span class="line">pvoid += <span class="number">1</span>;			<span class="comment">// 都是非法的(ANSI),而在GNU标准下是合法的</span></span><br></pre></td></tr></table></figure></div>
</blockquote>
<h3 id="零值比较"><a href="#零值比较" class="headerlink" title="零值比较"></a>零值比较</h3><ul>
<li><p><strong>bool</strong></p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> bTestFlag = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">if</span> (bTestFlag);   <span class="keyword">if</span> (!bTestFlag);</span><br></pre></td></tr></table></figure></div>

<p><strong><em>推荐使用上面的写法</em></strong></p>
</li>
<li><p><strong>float(double)</strong></p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">float</span> fTestVal = <span class="number">0.0f</span>;</span><br><span class="line"><span class="keyword">if</span> ((fTestVal &gt;= -EPSINON) &amp;&amp; (fTestVal &lt;= EPSINON)); <span class="comment">// ESPINON为定义好的精度</span></span><br></pre></td></tr></table></figure></div>

<p><strong><em>浮点数的存储是有精度限制的，不能直接比较，推荐使用预定义的精度来实现在某个精度区间内的比较</em></strong></p>
</li>
<li><p><strong>pointer</strong></p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> *p = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">if</span> (<span class="literal">NULL</span> == p);		<span class="keyword">if</span> (<span class="literal">NULL</span> != p);</span><br></pre></td></tr></table></figure></div>

<p><strong><em>NULL在前可以防止漏写一个&#x3D;时可以被编译器捕获错误</em></strong></p>
</li>
</ul>
<blockquote>
<p>  <em>关于空语句推荐写法是：&#x3D;&#x3D;NULL;&#x3D;&#x3D;</em></p>
</blockquote>
<h1 id="C-标准库函数指南"><a href="#C-标准库函数指南" class="headerlink" title="C 标准库函数指南"></a>C 标准库函数指南</h1><h2 id="一、-标准输入-输出"><a href="#一、-标准输入-输出" class="headerlink" title="一、&lt;stdio.h&gt; 标准输入&#x2F;输出"></a>一、&lt;stdio.h&gt; 标准输入&#x2F;输出</h2><blockquote>
<p>  <code>stdin</code>控制台输入，<code>stdout</code>控制台输出，<code>stderr</code>控制台错误</p>
</blockquote>
<h3 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h3><div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">fprintf</span><span class="params">(FILE *fp, <span class="type">const</span> <span class="type">char</span> *format, ...)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">printf</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *format, ...)</span>;</span><br></pre></td></tr></table></figure></div>

<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">putchar</span><span class="params">(<span class="type">int</span> ch)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">putc</span><span class="params">(<span class="type">int</span> ch, FILE *fp)</span>;</span><br></pre></td></tr></table></figure></div>

<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">fputs</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *s, FILE *fp)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">puts</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *)</span>;</span><br></pre></td></tr></table></figure></div>

<h3 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h3><div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">fscanf</span><span class="params">(FILE *fp, <span class="type">const</span> <span class="type">char</span> *format, ...)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">scanf</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *format, ...)</span>;</span><br></pre></td></tr></table></figure></div>

<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">getchar</span><span class="params">()</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">fgetc</span><span class="params">(FILE *fp)</span>;</span><br></pre></td></tr></table></figure></div>

<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> *<span class="title function_">fgets</span><span class="params">(<span class="type">char</span> buf[], <span class="type">int</span> buflen, FILE *fp)</span>;</span><br></pre></td></tr></table></figure></div>

<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">feof</span><span class="params">(FILE *fp)</span>;</span><br></pre></td></tr></table></figure></div>

<h3 id="文件操作"><a href="#文件操作" class="headerlink" title="文件操作"></a>文件操作</h3><div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">FILE *<span class="title function_">fopen</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *filename, <span class="type">const</span> <span class="type">char</span> *mode)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">fclose</span><span class="params">(FILE *fp)</span>;</span><br></pre></td></tr></table></figure></div>

<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">fflush</span><span class="params">(FILE *fp)</span>;</span><br></pre></td></tr></table></figure></div>

<h3 id="字符串输入输出"><a href="#字符串输入输出" class="headerlink" title="字符串输入输出"></a>字符串输入输出</h3><div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">sprintf</span><span class="params">(<span class="type">char</span> *s, <span class="type">const</span> <span class="type">char</span> *format, ...)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">sscanf</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *s, <span class="type">const</span> <span class="type">char</span> *format, ...)</span>;</span><br></pre></td></tr></table></figure></div>



<h2 id="二、-标准库实用程序"><a href="#二、-标准库实用程序" class="headerlink" title="二、&lt;stdlib.h&gt; 标准库实用程序"></a>二、&lt;stdlib.h&gt; 标准库实用程序</h2><h3 id="实用函数"><a href="#实用函数" class="headerlink" title="实用函数"></a>实用函数</h3><h4 id="随机数"><a href="#随机数" class="headerlink" title="随机数"></a>随机数</h4><div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">rand</span><span class="params">()</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">srand</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> seed)</span>;</span><br></pre></td></tr></table></figure></div>

<h4 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h4><div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">qsort</span><span class="params">(<span class="type">void</span> *base, <span class="type">size_t</span> nmemb, <span class="type">size_t</span> elemsz, <span class="type">int</span> (*compar)(<span class="type">const</span> <span class="type">void</span> *, <span class="type">const</span> <span class="type">void</span> *))</span>;</span><br></pre></td></tr></table></figure></div>

<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> *<span class="title function_">bsearch</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *key, <span class="type">const</span> <span class="type">void</span> *base, <span class="type">size_t</span> nmemb, <span class="type">size_t</span> elemsz, <span class="type">int</span> (*compar)(<span class="type">const</span> <span class="type">void</span> *, <span class="type">const</span> <span class="type">void</span> *))</span>;</span><br></pre></td></tr></table></figure></div>

<h4 id="非标准GNU头文件"><a href="#非标准GNU头文件" class="headerlink" title="非标准GNU头文件 &lt;search.h&gt;"></a>非标准GNU头文件 &lt;search.h&gt;</h4><div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span>   *<span class="title function_">lfind</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *key, <span class="type">const</span> <span class="type">void</span> *base, <span class="type">size_t</span> *nmemb, <span class="type">size_t</span> elemsz, <span class="type">int</span> (*compar)(<span class="type">const</span> <span class="type">void</span> *, <span class="type">const</span> <span class="type">void</span> *))</span></span><br><span class="line"><span class="type">void</span> *<span class="title function_">lsearch</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *key, <span class="type">void</span> *base, <span class="type">size_t</span> *nmemb, <span class="type">size_t</span> elemsz, <span class="type">int</span> (*compar)(<span class="type">const</span> <span class="type">void</span> *, <span class="type">const</span> <span class="type">void</span> *))</span></span><br></pre></td></tr></table></figure></div>

<h3 id="动态内存管理"><a href="#动态内存管理" class="headerlink" title="动态内存管理"></a>动态内存管理</h3><div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> *<span class="title function_">malloc</span><span class="params">(<span class="type">size_t</span> size)</span>;</span><br><span class="line"><span class="type">void</span> *<span class="title function_">calloc</span><span class="params">(<span class="type">size_t</span> num, <span class="type">size_t</span> size)</span>;</span><br><span class="line"><span class="type">void</span> *<span class="title function_">realloc</span><span class="params">(<span class="type">void</span> *p, <span class="type">size_t</span> size)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">free</span><span class="params">(<span class="type">void</span> *p)</span></span><br></pre></td></tr></table></figure></div>

<h3 id="程序控制"><a href="#程序控制" class="headerlink" title="程序控制"></a>程序控制</h3><div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">exit</span><span class="params">(<span class="type">int</span> status)</span>;</span><br></pre></td></tr></table></figure></div>



<h2 id="三、-字符串函数"><a href="#三、-字符串函数" class="headerlink" title="三、&lt;string.h&gt; 字符串函数"></a>三、&lt;string.h&gt; 字符串函数</h2><blockquote>
<p>  字符串函数不会在滥用时引发有用的错误，例如访问超出范围、缺少终止符、分配不足的内存等。</p>
<p>  如果使用不当，函数将在请求中出错，导致数据损坏和&#x2F;或崩溃</p>
</blockquote>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">size_t</span> <span class="title function_">strlen</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *s)</span>;</span><br></pre></td></tr></table></figure></div>

<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> *<span class="title function_">strcpy</span><span class="params">(<span class="type">char</span> *dest, <span class="type">const</span> <span class="type">char</span> *src)</span>;</span><br><span class="line"><span class="type">char</span> *<span class="title function_">strncpy</span><span class="params">(<span class="type">char</span> *dest, <span class="type">const</span> <span class="type">char</span> *src, <span class="type">size_t</span> n)</span>;</span><br></pre></td></tr></table></figure></div>

<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> *<span class="title function_">strcat</span><span class="params">(<span class="type">char</span> *dest, <span class="type">const</span> <span class="type">char</span> *src)</span>;</span><br><span class="line"><span class="type">char</span> *<span class="title function_">strncat</span><span class="params">(<span class="type">char</span> *dest, <span class="type">const</span> <span class="type">char</span> *src, <span class="type">size_t</span> n)</span>;</span><br></pre></td></tr></table></figure></div>

<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">strcmp</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *s1, <span class="type">const</span> <span class="type">char</span> *s2)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">strncmp</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *s1, <span class="type">const</span> <span class="type">char</span> *s2, <span class="type">size_t</span> n)</span>;</span><br></pre></td></tr></table></figure></div>

<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> *<span class="title function_">strchr</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *s, <span class="type">int</span> c)</span>;</span><br><span class="line"><span class="type">char</span> *<span class="title function_">strrchr</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *s, <span class="type">int</span> c)</span>;</span><br></pre></td></tr></table></figure></div>

<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">har *<span class="title function_">strstr</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *haystack, <span class="type">const</span> <span class="type">char</span> *needle)</span>;</span><br></pre></td></tr></table></figure></div>

<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> *<span class="title function_">strdup</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *s)</span>;</span><br></pre></td></tr></table></figure></div>

<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">size_t</span> <span class="title function_">strspn</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *s, <span class="type">const</span> <span class="type">char</span> *accept)</span>;</span><br><span class="line"><span class="type">size_t</span> <span class="title function_">strcspn</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *s, <span class="type">const</span> <span class="type">char</span> *reject)</span>;</span><br></pre></td></tr></table></figure></div>

<h3 id="数据操作"><a href="#数据操作" class="headerlink" title="数据操作"></a>数据操作</h3><div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> *<span class="title function_">memcpy</span><span class="params">(<span class="type">void</span> *dest, <span class="type">const</span> <span class="type">void</span> *src, <span class="type">size_t</span> n)</span>;</span><br><span class="line"><span class="type">void</span> *<span class="title function_">memmove</span><span class="params">(<span class="type">void</span> *dest, <span class="type">const</span> <span class="type">void</span> *src, <span class="type">size_t</span> n)</span>;</span><br><span class="line"><span class="type">void</span> *<span class="title function_">memset</span><span class="params">(<span class="type">void</span> *dest, <span class="type">int</span> ch, <span class="type">size_t</span> n)</span>;</span><br></pre></td></tr></table></figure></div>



<h2 id="四、-字符函数"><a href="#四、-字符函数" class="headerlink" title="四、&lt;ctype.h&gt; 字符函数"></a>四、&lt;ctype.h&gt; 字符函数</h2><div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">isdigit</span><span class="params">(<span class="type">int</span> ch)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">isalpha</span><span class="params">(<span class="type">int</span> ch)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">isupper</span><span class="params">(<span class="type">int</span> ch)</span>...</span><br></pre></td></tr></table></figure></div>

<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">toupper</span><span class="params">(<span class="type">int</span> ch)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">tolower</span><span class="params">(<span class="type">int</span> ch)</span>;</span><br></pre></td></tr></table></figure></div>



<h3 id="五、-断言"><a href="#五、-断言" class="headerlink" title="五、&lt;assert.h&gt; 断言"></a>五、&lt;assert.h&gt; 断言</h3><div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">assert(expr);</span><br></pre></td></tr></table></figure></div>

        </div>

        

        
            <ul class="post-tags-box text-lg mt-1.5 flex-wrap justify-center flex md:hidden">
                
                    <li class="tag-item mx-0.5">
                        <a href="/tags/C%E8%AF%AD%E8%A8%80/">#C语言</a>&nbsp;
                    </li>
                
            </ul>
        

        

        
            <div class="article-nav my-8 flex justify-between items-center px-2 sm:px-6 md:px-8">
                
                    <div class="article-prev border-border-color shadow-redefine-flat shadow-shadow-color-2 rounded-medium px-4 py-2 hover:shadow-redefine-flat-hover hover:shadow-shadow-color-2">
                        <a class="prev"
                        rel="prev"
                        href="/2022/02/06/2022-02-06-cpp/"
                        >
                            <span class="left arrow-icon flex justify-center items-center">
                                <i class="fa-solid fa-chevron-left"></i>
                            </span>
                            <span class="title flex justify-center items-center">
                                <span class="post-nav-title-item">Cpp基础</span>
                                <span class="post-nav-item">上一篇</span>
                            </span>
                        </a>
                    </div>
                
                
                    <div class="article-next border-border-color shadow-redefine-flat shadow-shadow-color-2 rounded-medium px-4 py-2 hover:shadow-redefine-flat-hover hover:shadow-shadow-color-2">
                        <a class="next"
                        rel="next"
                        href="/2021/12/12/2021-12-12-stl/"
                        >
                            <span class="title flex justify-center items-center">
                                <span class="post-nav-title-item">STL</span>
                                <span class="post-nav-item">下一篇</span>
                            </span>
                            <span class="right arrow-icon flex justify-center items-center">
                                <i class="fa-solid fa-chevron-right"></i>
                            </span>
                        </a>
                    </div>
                
            </div>
        


        
    </div>

    
        <div class="toc-content-container">
            <div class="post-toc-wrap">
    <div class="post-toc">
        <div class="toc-title">此页目录</div>
        <div class="page-title">C语言</div>
        <ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#cppreference-C"><span class="nav-text">cppreference - C</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="nav-text">基本概念</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B3%A8%E9%87%8A"><span class="nav-text">注释</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#C-%E9%A3%8E%E6%A0%BC%E6%B3%A8%E9%87%8A"><span class="nav-text">C 风格注释</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#C-%E9%A3%8E%E6%A0%BC%E6%B3%A8%E9%87%8A-1"><span class="nav-text">C++ 风格注释</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ASCII"><span class="nav-text">ASCII</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%89%93%E5%8D%B0ASCII%E7%A0%81%E8%A1%A8"><span class="nav-text">打印ASCII码表</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BD%AC%E4%B9%89%E5%BA%8F%E5%88%97"><span class="nav-text">转义序列</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BF%BB%E8%AF%91%E9%98%B6%E6%AE%B5"><span class="nav-text">翻译阶段</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%98%B6%E6%AE%B5%E4%B8%80"><span class="nav-text">阶段一</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%98%B6%E6%AE%B5%E4%BA%8C"><span class="nav-text">阶段二</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%98%B6%E6%AE%B5%E4%B8%89"><span class="nav-text">阶段三</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%98%B6%E6%AE%B5%E5%9B%9B"><span class="nav-text">阶段四</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%98%B6%E6%AE%B5%E4%BA%94"><span class="nav-text">阶段五</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%98%B6%E6%AE%B5%E5%85%AD"><span class="nav-text">阶段六</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%98%B6%E6%AE%B5%E4%B8%83"><span class="nav-text">阶段七</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%98%B6%E6%AE%B5%E5%85%AB"><span class="nav-text">阶段八</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A0%87%E7%82%B9"><span class="nav-text">标点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A0%87%E8%AF%86%E7%AC%A6"><span class="nav-text">标识符</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%9C%E7%94%A8%E5%9F%9F"><span class="nav-text">作用域</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%B5%8C%E5%A5%97%E4%BD%9C%E7%94%A8%E5%9F%9F"><span class="nav-text">嵌套作用域</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9D%97%E4%BD%9C%E7%94%A8%E5%9F%9F"><span class="nav-text">块作用域</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%96%87%E4%BB%B6%E4%BD%9C%E7%94%A8%E5%9F%9F"><span class="nav-text">文件作用域</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%87%BD%E6%95%B0%E4%BD%9C%E7%94%A8%E5%9F%9F"><span class="nav-text">函数作用域</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%87%BD%E6%95%B0%E5%8E%9F%E5%9E%8B%E4%BD%9C%E7%94%A8%E5%9F%9F"><span class="nav-text">函数原型作用域</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A3%B0%E6%98%8E%E7%82%B9"><span class="nav-text">声明点</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%94%9F%E5%AD%98%E6%9C%9F"><span class="nav-text">生存期</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%B4%E6%97%B6%E7%94%9F%E5%AD%98%E6%9C%9F"><span class="nav-text">临时生存期</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9F%A5%E6%89%BE%E4%B8%8E%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4"><span class="nav-text">查找与命名空间</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%B3%A8%E8%A7%A3"><span class="nav-text">注解</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%B1%BB%E5%9E%8B"><span class="nav-text">类型</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%B1%BB%E5%9E%8B%E5%88%86%E7%B1%BB"><span class="nav-text">类型分类</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%B1%BB%E5%9E%8B%E7%BB%84%E5%88%AB"><span class="nav-text">类型组别</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%85%BC%E5%AE%B9%E7%B1%BB%E5%9E%8B"><span class="nav-text">兼容类型</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%90%88%E6%88%90%E7%B1%BB%E5%9E%8B"><span class="nav-text">合成类型</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%8D%E5%AE%8C%E6%95%B4%E7%B1%BB%E5%9E%8B"><span class="nav-text">不完整类型</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%B1%BB%E5%9E%8B%E5%90%8D"><span class="nav-text">类型名</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AF%B9%E8%B1%A1%E4%B8%8E%E5%AF%B9%E9%BD%90"><span class="nav-text">对象与对齐</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AF%B9%E8%B1%A1%E8%A1%A8%E7%A4%BA"><span class="nav-text">对象表示</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9C%89%E6%95%88%E7%B1%BB%E5%9E%8B"><span class="nav-text">有效类型</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%A5%E6%A0%BC%E5%88%AB%E5%90%8D%E4%BD%BF%E7%94%A8"><span class="nav-text">严格别名使用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AF%B9%E9%BD%90"><span class="nav-text">对齐</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%BB%E5%87%BD%E6%95%B0"><span class="nav-text">主函数</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8F%82%E6%95%B0"><span class="nav-text">参数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%BF%94%E5%9B%9E%E5%80%BC"><span class="nav-text">返回值</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9C%AA%E5%AE%9A%E4%B9%89%E8%A1%8C%E4%B8%BA"><span class="nav-text">未定义行为</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#UB%E4%B8%8E%E4%BC%98%E5%8C%96"><span class="nav-text">UB与优化</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%9C%89%E7%AC%A6%E5%8F%B7%E6%BA%A2%E5%87%BA"><span class="nav-text">有符号溢出</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%B6%8A%E7%95%8C%E8%AE%BF%E9%97%AE"><span class="nav-text">越界访问</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%9C%AA%E5%88%9D%E5%A7%8B%E5%8C%96%E6%A0%87%E9%87%8F"><span class="nav-text">未初始化标量</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%9D%9E%E6%B3%95%E6%A0%87%E9%87%8F"><span class="nav-text">非法标量</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%A9%BA%E6%8C%87%E9%92%88%E8%A7%A3%E5%BC%95%E7%94%A8"><span class="nav-text">空指针解引用</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%AE%BF%E9%97%AE%E4%BC%A0%E9%80%92%E7%BB%99realloc%E7%9A%84%E6%8C%87%E9%92%88"><span class="nav-text">访问传递给realloc的指针</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%97%A0%E5%89%AF%E6%95%88%E5%BA%94%E7%9A%84%E6%97%A0%E9%99%90%E5%BE%AA%E7%8E%AF"><span class="nav-text">无副效应的无限循环</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B"><span class="nav-text">内存模型</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AD%97%E8%8A%82"><span class="nav-text">字节</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%86%85%E5%AD%98%E4%BD%8D%E7%BD%AE"><span class="nav-text">内存位置</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E5%8F%8A%E6%95%B0%E6%8D%AE%E7%AB%9E%E4%BA%89"><span class="nav-text">线程及数据竞争</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%86%85%E5%AD%98%E9%A1%BA%E5%BA%8F"><span class="nav-text">内存顺序</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%85%B3%E9%94%AE%E8%AF%8D"><span class="nav-text">关键词</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%A2%84%E5%A4%84%E7%90%86%E5%99%A8"><span class="nav-text">预处理器</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9D%A1%E4%BB%B6%E5%8C%85%E5%90%AB"><span class="nav-text">条件包含</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%AF%AD%E6%B3%95"><span class="nav-text">语法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%A7%A3%E9%87%8A"><span class="nav-text">解释</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9D%A1%E4%BB%B6%E7%9A%84%E6%B1%82%E5%80%BC"><span class="nav-text">条件的求值</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9B%BF%E6%8D%A2%E6%96%87%E6%9C%AC%E5%AE%8F"><span class="nav-text">替换文本宏</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%AF%AD%E6%B3%95-1"><span class="nav-text">语法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%A7%A3%E9%87%8A-1"><span class="nav-text">解释</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#define-%E6%8C%87%E4%BB%A4"><span class="nav-text">#define 指令</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BB%BF%E5%87%BD%E6%95%B0%E5%AE%8F"><span class="nav-text">仿函数宏</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%8E-%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="nav-text"># 与 ## 运算符</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#undef"><span class="nav-text">#undef</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%A2%84%E5%AE%9A%E4%B9%89%E5%AE%8F"><span class="nav-text">预定义宏</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%BA%90%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB"><span class="nav-text">源文件包含</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%AF%AD%E6%B3%95-2"><span class="nav-text">语法</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AF%8A%E6%96%AD%E6%8C%87%E4%BB%A4"><span class="nav-text">诊断指令</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%AF%AD%E6%B3%95-3"><span class="nav-text">语法</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%9E%E7%8E%B0%E5%AE%9A%E4%B9%89%E7%9A%84%E8%A1%8C%E4%B8%BA%E6%8E%A7%E5%88%B6"><span class="nav-text">实现定义的行为控制</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%AF%AD%E6%B3%95-4"><span class="nav-text">语法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#pragma-STDC"><span class="nav-text">#pragma STDC</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#pragma-once"><span class="nav-text">#pragma once</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#pragma-pack"><span class="nav-text">#pragma pack</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%96%87%E4%BB%B6%E5%90%8D%E5%92%8C%E8%A1%8C%E4%BF%A1%E6%81%AF"><span class="nav-text">文件名和行信息</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%AF%AD%E6%B3%95-5"><span class="nav-text">语法</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="nav-text">表达式</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%80%BC%E7%B1%BB%E5%88%AB"><span class="nav-text">值类别</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%B7%A6%E5%80%BC%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="nav-text">左值表达式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8F%AF%E4%BF%AE%E6%94%B9%E5%B7%A6%E5%80%BC%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="nav-text">可修改左值表达式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%9D%9E%E5%B7%A6%E5%80%BC%E5%AF%B9%E8%B1%A1%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="nav-text">非左值对象表达式</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B1%82%E5%80%BC%E9%A1%BA%E5%BA%8F"><span class="nav-text">求值顺序</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B8%B8%E9%87%8F%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="nav-text">常量表达式</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%A2%84%E5%A4%84%E7%90%86%E5%99%A8%E5%B8%B8%E9%87%8F%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="nav-text">预处理器常量表达式</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#C%E5%9F%BA%E7%A1%80"><span class="nav-text">C基础</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="nav-text">数据类型</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%95%B4%E5%9E%8B"><span class="nav-text">整型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B5%AE%E7%82%B9%E5%9E%8B"><span class="nav-text">浮点型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AD%97%E7%AC%A6%E5%9E%8B"><span class="nav-text">字符型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%B6%E5%AE%83"><span class="nav-text">其它</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A0%BC%E5%BC%8F%E5%8C%96%E8%BE%93%E5%87%BA"><span class="nav-text">格式化输出</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="nav-text">运算符</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%87%BD%E6%95%B0"><span class="nav-text">函数</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E5%87%BD%E6%95%B0"><span class="nav-text">使用函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%95%B0%E7%BB%84%E4%BD%9C%E4%B8%BA%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0"><span class="nav-text">数组作为函数参数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%87%BD%E6%95%B0%E5%92%8C%E6%8C%87%E9%92%88"><span class="nav-text">函数和指针</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%95%B0%E7%BB%84"><span class="nav-text">数组</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%80%E7%BB%B4%E6%95%B0%E7%BB%84"><span class="nav-text">一维数组</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BA%8C%E7%BB%B4%E5%8F%8A%E5%A4%9A%E7%BB%B4%E6%95%B0%E7%BB%84"><span class="nav-text">二维及多维数组</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#VLA"><span class="nav-text">VLA</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A4%8D%E5%90%88%E5%AD%97%E9%9D%A2%E9%87%8F"><span class="nav-text">复合字面量</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%8C%87%E9%92%88"><span class="nav-text">指针</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8C%87%E9%92%88%E5%92%8C%E6%95%B0%E7%BB%84"><span class="nav-text">指针和数组</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8C%87%E9%92%88%E4%B8%8Econst"><span class="nav-text">指针与const</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8C%87%E9%92%88%E7%9A%84%E5%85%BC%E5%AE%B9%E6%80%A7"><span class="nav-text">指针的兼容性</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="nav-text">字符串</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A1%A8%E7%A4%BA%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="nav-text">表示字符串</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BE%93%E5%85%A5"><span class="nav-text">字符串输入</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BE%93%E5%87%BA"><span class="nav-text">字符串输出</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%87%BD%E6%95%B0"><span class="nav-text">字符串函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BD%AC%E5%8C%96%E4%B8%BA%E6%95%B0%E5%AD%97-stdlib-h"><span class="nav-text">字符串转化为数字(stdlib.h)</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%96%87%E4%BB%B6%E8%BE%93%E5%85%A5-%E8%BE%93%E5%87%BA"><span class="nav-text">文件输入&#x2F;输出</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%8E%E6%96%87%E4%BB%B6%E8%BF%9B%E8%A1%8C%E9%80%9A%E4%BF%A1"><span class="nav-text">与文件进行通信</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A0%87%E5%87%86IO"><span class="nav-text">标准IO</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%96%87%E4%BB%B6IO"><span class="nav-text">文件IO</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%9A%8F%E6%9C%BA%E8%AE%BF%E9%97%AE"><span class="nav-text">随机访问</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%B6%E5%AE%83%E6%A0%87%E5%87%86IO%E5%87%BD%E6%95%B0"><span class="nav-text">其它标准IO函数</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BB%93%E6%9E%84%E5%92%8C%E5%85%B6%E4%BB%96%E6%95%B0%E6%8D%AE%E5%BD%A2%E5%BC%8F"><span class="nav-text">结构和其他数据形式</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%9A%E4%B9%89%E7%BB%93%E6%9E%84"><span class="nav-text">定义结构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8C%87%E5%90%91%E7%BB%93%E6%9E%84%E7%9A%84%E6%8C%87%E9%92%88"><span class="nav-text">指向结构的指针</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%B3%E4%BA%8E%E7%BB%93%E6%9E%84%E4%B8%80%E4%BA%9B%E7%89%B9%E6%AE%8A%E5%A4%84%E7%90%86"><span class="nav-text">关于结构一些特殊处理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%81%94%E5%90%88union"><span class="nav-text">联合union</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9E%9A%E4%B8%BEenum"><span class="nav-text">枚举enum</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#typedef"><span class="nav-text">typedef</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BD%8D%E6%93%8D%E4%BD%9C"><span class="nav-text">位操作</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#C%E6%8C%89%E4%BD%8D%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="nav-text">C按位运算符</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%8D%E5%AD%97%E6%AE%B5"><span class="nav-text">位字段</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AF%B9%E9%BD%90%E7%89%B9%E6%80%A7"><span class="nav-text">对齐特性</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#C%E8%BF%9B%E9%98%B6"><span class="nav-text">C进阶</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%A2%84%E5%A4%84%E7%90%86"><span class="nav-text">预处理</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BC%96%E8%AF%91%E6%B5%81%E7%A8%8B"><span class="nav-text">编译流程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%B6%E4%BB%96%E5%91%BD%E4%BB%A4"><span class="nav-text">其他命令</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%86%85%E8%81%94%E5%87%BD%E6%95%B0"><span class="nav-text">内联函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#const-define"><span class="nav-text">const &amp; define</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%8C%87%E9%92%88%E5%92%8C%E6%95%B0%E7%BB%84-1"><span class="nav-text">指针和数组</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%A4%E7%A7%8D%E8%AE%BF%E9%97%AE%E5%BD%A2%E5%BC%8F"><span class="nav-text">两种访问形式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%80%E7%BB%B4%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E4%B8%8E%E6%8C%87%E9%92%88"><span class="nav-text">一维二维数组与指针</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8C%87%E9%92%88%E6%95%B0%E7%BB%84%E4%B8%8E%E5%87%BD%E6%95%B0%E6%8C%87%E9%92%88"><span class="nav-text">指针数组与函数指针</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86"><span class="nav-text">内存管理</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A0%86-%E6%A0%88-%E9%9D%99%E6%80%81%E5%8C%BA"><span class="nav-text">堆 栈 静态区</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B8%B8%E8%A7%81%E7%9A%84%E5%86%85%E5%AD%98%E9%94%99%E8%AF%AF"><span class="nav-text">常见的内存错误</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AD%98%E5%82%A8%E7%B1%BB%E5%88%AB"><span class="nav-text">存储类别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%86%E9%85%8D%E5%86%85%E5%AD%98"><span class="nav-text">分配内存</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ANSI-C%E7%B1%BB%E5%9E%8B%E9%99%90%E5%AE%9A%E7%AC%A6"><span class="nav-text">ANSI C类型限定符</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BC%96%E7%A0%81%E9%A3%8E%E6%A0%BC"><span class="nav-text">编码风格</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%90%88%E7%90%86%E8%A7%84%E8%8C%83%E5%A4%B4%E6%96%87%E4%BB%B6"><span class="nav-text">合理规范头文件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%87%BD%E6%95%B0-1"><span class="nav-text">函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A0%87%E8%AF%86%E7%AC%A6%E5%91%BD%E5%90%8D%E4%B8%8E%E5%AE%9A%E4%B9%89"><span class="nav-text">标识符命名与定义</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%80%9A%E7%94%A8%E5%91%BD%E5%90%8D%E8%A7%84%E5%88%99"><span class="nav-text">通用命名规则</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%96%87%E4%BB%B6%E5%91%BD%E5%90%8D%E8%A7%84%E5%88%99"><span class="nav-text">文件命名规则</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8F%98%E9%87%8F%E5%91%BD%E5%90%8D%E8%A7%84%E5%88%99"><span class="nav-text">变量命名规则</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%87%BD%E6%95%B0%E5%91%BD%E5%90%8D%E8%A7%84%E5%88%99"><span class="nav-text">函数命名规则</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AE%8F%E7%9A%84%E5%91%BD%E5%90%8D%E8%A7%84%E5%88%99"><span class="nav-text">宏的命名规则</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%98%E9%87%8F"><span class="nav-text">变量</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%8F-%E5%B8%B8%E9%87%8F"><span class="nav-text">宏 常量</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%A3%E7%A0%81%E8%B4%A8%E9%87%8F"><span class="nav-text">代码质量</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%A8%8B%E5%BA%8F%E6%95%88%E7%8E%87"><span class="nav-text">程序效率</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B3%A8%E9%87%8A-1"><span class="nav-text">注释</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8E%92%E7%89%88%E4%B8%8E%E6%A0%BC%E5%BC%8F"><span class="nav-text">排版与格式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A1%A8%E8%BE%BE%E5%BC%8F-1"><span class="nav-text">表达式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%A3%E7%A0%81%E7%BC%96%E8%BE%91-%E7%BC%96%E8%AF%91"><span class="nav-text">代码编辑 编译</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%AF%E6%B5%8B%E6%80%A7"><span class="nav-text">可测性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%89%E5%85%A8%E6%80%A7"><span class="nav-text">安全性</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%93%8D%E4%BD%9C%E5%AE%89%E5%85%A8"><span class="nav-text">字符串操作安全</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%95%B4%E6%95%B0%E5%AE%89%E5%85%A8"><span class="nav-text">整数安全</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A0%BC%E5%BC%8F%E5%8C%96%E8%BE%93%E5%87%BA%E5%AE%89%E5%85%A8"><span class="nav-text">格式化输出安全</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%96%87%E4%BB%B6IO%E5%AE%89%E5%85%A8"><span class="nav-text">文件IO安全</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95"><span class="nav-text">单元测试</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%AF%E7%A7%BB%E6%A4%8D%E6%80%A7"><span class="nav-text">可移植性</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9D%82%E9%A1%B9"><span class="nav-text">杂项</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#void%E4%BD%BF%E7%94%A8"><span class="nav-text">void使用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%9B%B6%E5%80%BC%E6%AF%94%E8%BE%83"><span class="nav-text">零值比较</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#C-%E6%A0%87%E5%87%86%E5%BA%93%E5%87%BD%E6%95%B0%E6%8C%87%E5%8D%97"><span class="nav-text">C 标准库函数指南</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%80%E3%80%81-%E6%A0%87%E5%87%86%E8%BE%93%E5%85%A5-%E8%BE%93%E5%87%BA"><span class="nav-text">一、&lt;stdio.h&gt; 标准输入&#x2F;输出</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BE%93%E5%87%BA"><span class="nav-text">输出</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BE%93%E5%85%A5"><span class="nav-text">输入</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C"><span class="nav-text">文件操作</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA"><span class="nav-text">字符串输入输出</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%8C%E3%80%81-%E6%A0%87%E5%87%86%E5%BA%93%E5%AE%9E%E7%94%A8%E7%A8%8B%E5%BA%8F"><span class="nav-text">二、&lt;stdlib.h&gt; 标准库实用程序</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%9E%E7%94%A8%E5%87%BD%E6%95%B0"><span class="nav-text">实用函数</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%9A%8F%E6%9C%BA%E6%95%B0"><span class="nav-text">随机数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%AE%97%E6%B3%95"><span class="nav-text">算法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%9D%9E%E6%A0%87%E5%87%86GNU%E5%A4%B4%E6%96%87%E4%BB%B6"><span class="nav-text">非标准GNU头文件 &lt;search.h&gt;</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86"><span class="nav-text">动态内存管理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%A8%8B%E5%BA%8F%E6%8E%A7%E5%88%B6"><span class="nav-text">程序控制</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%89%E3%80%81-%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%87%BD%E6%95%B0"><span class="nav-text">三、&lt;string.h&gt; 字符串函数</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E6%93%8D%E4%BD%9C"><span class="nav-text">数据操作</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9B%9B%E3%80%81-%E5%AD%97%E7%AC%A6%E5%87%BD%E6%95%B0"><span class="nav-text">四、&lt;ctype.h&gt; 字符函数</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BA%94%E3%80%81-%E6%96%AD%E8%A8%80"><span class="nav-text">五、&lt;assert.h&gt; 断言</span></a></li></ol></li></ol></li></ol>

    </div>
</div>
        </div>
    
</div>



                

            </div>

            

        </div>

        <div class="main-content-footer">
            <footer class="footer mt-5 py-5 h-auto text-base text-third-text-color relative border-t-2 border-t-border-color">
    <div class="info-container py-3 text-center">
        
        <div class="text-center">
            &copy;
            
            2024&nbsp;&nbsp;<i class="fa-solid fa-heart fa-beat" style="--fa-animation-duration: 0.5s; color: #f54545"></i>&nbsp;&nbsp;<a href="/">fetch150zy</a>
            
                
                <p class="post-count space-x-0.5">
                    <span>
                        共 54 篇文章
                    </span>
                    
                </p>
            
        </div>
        
        <div class="relative text-center lg:absolute lg:left-[20px] lg:top-1/2 lg:-translate-y-1/2 lg:text-left">
            <span class="lg:block text-sm">由 <?xml version="1.0" encoding="utf-8"?><!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd"><svg class="relative top-[2px] inline-block align-baseline" version="1.1" id="圖層_1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px" width="1rem" height="1rem" viewBox="0 0 512 512" enable-background="new 0 0 512 512" xml:space="preserve"><path fill="#0E83CD" d="M256.4,25.8l-200,115.5L56,371.5l199.6,114.7l200-115.5l0.4-230.2L256.4,25.8z M349,354.6l-18.4,10.7l-18.6-11V275H200v79.6l-18.4,10.7l-18.6-11v-197l18.5-10.6l18.5,10.8V237h112v-79.6l18.5-10.6l18.5,10.8V354.6z"/></svg><a target="_blank" class="text-base" href="https://hexo.io">Hexo</a> 驱动</span>
            <span class="text-sm lg:block">主题&nbsp;<a class="text-base" target="_blank" href="https://github.com/EvanNotFound/hexo-theme-redefine">Redefine v2.6.1</a></span>
        </div>
        
        
        
        
        
    </div>  
</footer>
        </div>
    </div>

    
        <div class="post-tools">
            <div class="post-tools-container">
    <ul class="article-tools-list">
        <!-- TOC aside toggle -->
        
            <li class="right-bottom-tools page-aside-toggle">
                <i class="fa-regular fa-outdent"></i>
            </li>
        

        <!-- go comment -->
        
    </ul>
</div>

        </div>
    

    <div class="right-side-tools-container">
        <div class="side-tools-container">
    <ul class="hidden-tools-list">
        <li class="right-bottom-tools tool-font-adjust-plus flex justify-center items-center">
            <i class="fa-regular fa-magnifying-glass-plus"></i>
        </li>

        <li class="right-bottom-tools tool-font-adjust-minus flex justify-center items-center">
            <i class="fa-regular fa-magnifying-glass-minus"></i>
        </li>

        <li class="right-bottom-tools tool-dark-light-toggle flex justify-center items-center">
            <i class="fa-regular fa-moon"></i>
        </li>

        <!-- rss -->
        

        

        <li class="right-bottom-tools tool-scroll-to-bottom flex justify-center items-center">
            <i class="fa-regular fa-arrow-down"></i>
        </li>
    </ul>

    <ul class="visible-tools-list">
        <li class="right-bottom-tools toggle-tools-list flex justify-center items-center">
            <i class="fa-regular fa-cog fa-spin"></i>
        </li>
        
            <li class="right-bottom-tools tool-scroll-to-top flex justify-center items-center">
                <i class="arrow-up fas fa-arrow-up"></i>
                <span class="percent"></span>
            </li>
        
        
    </ul>
</div>

    </div>

    <div class="image-viewer-container">
    <img src="">
</div>


    

</main>


    
<script src="/js/libs/Swup.min.js"></script>

<script src="/js/libs/SwupSlideTheme.min.js"></script>

<script src="/js/libs/SwupScriptsPlugin.min.js"></script>

<script src="/js/libs/SwupProgressPlugin.min.js"></script>

<script src="/js/libs/SwupScrollPlugin.min.js"></script>

<script src="/js/libs/SwupPreloadPlugin.min.js"></script>

<script>
    const swup = new Swup({
        plugins: [
            new SwupScriptsPlugin({
                optin: true,
            }),
            new SwupProgressPlugin(),
            new SwupScrollPlugin({
                offset: 80,
            }),
            new SwupSlideTheme({
                mainElement: ".main-content-body",
            }),
            new SwupPreloadPlugin(),
        ],
        containers: ["#swup"],
    });
</script>







<script src="/js/tools/imageViewer.js" type="module"></script>

<script src="/js/utils.js" type="module"></script>

<script src="/js/main.js" type="module"></script>

<script src="/js/layouts/navbarShrink.js" type="module"></script>

<script src="/js/tools/scrollTopBottom.js" type="module"></script>

<script src="/js/tools/lightDarkSwitch.js" type="module"></script>

<script src="/js/layouts/categoryList.js" type="module"></script>







    
<script src="/js/layouts/lazyload.js" type="module"></script>






  
<script src="/js/libs/Typed.min.js"></script>

  
<script src="/js/plugins/typed.js" type="module"></script>









<div class="post-scripts" data-swup-reload-script>
    
        
<script src="/js/tools/tocToggle.js" type="module"></script>

<script src="/js/layouts/toc.js" type="module"></script>

<script src="/js/plugins/tabs.js" type="module"></script>

    
</div>


</body>
</html>
